
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Component
 * 
 */
export type Component = $Result.DefaultSelection<Prisma.$ComponentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Motherboard
 * 
 */
export type Motherboard = $Result.DefaultSelection<Prisma.$MotherboardPayload>
/**
 * Model Processor
 * 
 */
export type Processor = $Result.DefaultSelection<Prisma.$ProcessorPayload>
/**
 * Model GPU
 * 
 */
export type GPU = $Result.DefaultSelection<Prisma.$GPUPayload>
/**
 * Model RAM
 * 
 */
export type RAM = $Result.DefaultSelection<Prisma.$RAMPayload>
/**
 * Model Storage
 * 
 */
export type Storage = $Result.DefaultSelection<Prisma.$StoragePayload>
/**
 * Model PowerSupply
 * 
 */
export type PowerSupply = $Result.DefaultSelection<Prisma.$PowerSupplyPayload>
/**
 * Model PCCase
 * 
 */
export type PCCase = $Result.DefaultSelection<Prisma.$PCCasePayload>
/**
 * Model ParcialPCConfiguration
 * 
 */
export type ParcialPCConfiguration = $Result.DefaultSelection<Prisma.$ParcialPCConfigurationPayload>
/**
 * Model PCConfiguration
 * 
 */
export type PCConfiguration = $Result.DefaultSelection<Prisma.$PCConfigurationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const ComponentType: {
  MOTHERBOARD: 'MOTHERBOARD',
  PROCESSOR: 'PROCESSOR',
  GPU: 'GPU',
  RAM: 'RAM',
  STORAGE: 'STORAGE',
  POWERSUPPLY: 'POWERSUPPLY',
  PCCASE: 'PCCASE'
};

export type ComponentType = (typeof ComponentType)[keyof typeof ComponentType]


export const ComputerType: {
  DESKTOP: 'DESKTOP',
  LAPTOP: 'LAPTOP'
};

export type ComputerType = (typeof ComputerType)[keyof typeof ComputerType]


export const ConfigurationType: {
  GAMING: 'GAMING',
  OFFICE: 'OFFICE',
  WORK: 'WORK',
  HIGH_END: 'HIGH_END',
  DEFAULT: 'DEFAULT'
};

export type ConfigurationType = (typeof ConfigurationType)[keyof typeof ConfigurationType]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type ComponentType = $Enums.ComponentType

export const ComponentType: typeof $Enums.ComponentType

export type ComputerType = $Enums.ComputerType

export const ComputerType: typeof $Enums.ComputerType

export type ConfigurationType = $Enums.ConfigurationType

export const ConfigurationType: typeof $Enums.ConfigurationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sessions
 * const sessions = await prisma.session.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **Component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.ComponentDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.motherboard`: Exposes CRUD operations for the **Motherboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motherboards
    * const motherboards = await prisma.motherboard.findMany()
    * ```
    */
  get motherboard(): Prisma.MotherboardDelegate<ExtArgs>;

  /**
   * `prisma.processor`: Exposes CRUD operations for the **Processor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processors
    * const processors = await prisma.processor.findMany()
    * ```
    */
  get processor(): Prisma.ProcessorDelegate<ExtArgs>;

  /**
   * `prisma.gPU`: Exposes CRUD operations for the **GPU** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GPUS
    * const gPUS = await prisma.gPU.findMany()
    * ```
    */
  get gPU(): Prisma.GPUDelegate<ExtArgs>;

  /**
   * `prisma.rAM`: Exposes CRUD operations for the **RAM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RAMS
    * const rAMS = await prisma.rAM.findMany()
    * ```
    */
  get rAM(): Prisma.RAMDelegate<ExtArgs>;

  /**
   * `prisma.storage`: Exposes CRUD operations for the **Storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storages
    * const storages = await prisma.storage.findMany()
    * ```
    */
  get storage(): Prisma.StorageDelegate<ExtArgs>;

  /**
   * `prisma.powerSupply`: Exposes CRUD operations for the **PowerSupply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PowerSupplies
    * const powerSupplies = await prisma.powerSupply.findMany()
    * ```
    */
  get powerSupply(): Prisma.PowerSupplyDelegate<ExtArgs>;

  /**
   * `prisma.pCCase`: Exposes CRUD operations for the **PCCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PCCases
    * const pCCases = await prisma.pCCase.findMany()
    * ```
    */
  get pCCase(): Prisma.PCCaseDelegate<ExtArgs>;

  /**
   * `prisma.parcialPCConfiguration`: Exposes CRUD operations for the **ParcialPCConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParcialPCConfigurations
    * const parcialPCConfigurations = await prisma.parcialPCConfiguration.findMany()
    * ```
    */
  get parcialPCConfiguration(): Prisma.ParcialPCConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.pCConfiguration`: Exposes CRUD operations for the **PCConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PCConfigurations
    * const pCConfigurations = await prisma.pCConfiguration.findMany()
    * ```
    */
  get pCConfiguration(): Prisma.PCConfigurationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.0
   * Query Engine version: 5fe21811a6ba0b952a3bc71400666511fe3b902f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Session: 'Session',
    Component: 'Component',
    User: 'User',
    Motherboard: 'Motherboard',
    Processor: 'Processor',
    GPU: 'GPU',
    RAM: 'RAM',
    Storage: 'Storage',
    PowerSupply: 'PowerSupply',
    PCCase: 'PCCase',
    ParcialPCConfiguration: 'ParcialPCConfiguration',
    PCConfiguration: 'PCConfiguration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "session" | "component" | "user" | "motherboard" | "processor" | "gPU" | "rAM" | "storage" | "powerSupply" | "pCCase" | "parcialPCConfiguration" | "pCConfiguration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Component: {
        payload: Prisma.$ComponentPayload<ExtArgs>
        fields: Prisma.ComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findFirst: {
            args: Prisma.ComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findMany: {
            args: Prisma.ComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          create: {
            args: Prisma.ComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          createMany: {
            args: Prisma.ComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          delete: {
            args: Prisma.ComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          update: {
            args: Prisma.ComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          deleteMany: {
            args: Prisma.ComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.ComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Motherboard: {
        payload: Prisma.$MotherboardPayload<ExtArgs>
        fields: Prisma.MotherboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MotherboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MotherboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>
          }
          findFirst: {
            args: Prisma.MotherboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MotherboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>
          }
          findMany: {
            args: Prisma.MotherboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>[]
          }
          create: {
            args: Prisma.MotherboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>
          }
          createMany: {
            args: Prisma.MotherboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MotherboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>[]
          }
          delete: {
            args: Prisma.MotherboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>
          }
          update: {
            args: Prisma.MotherboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>
          }
          deleteMany: {
            args: Prisma.MotherboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MotherboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MotherboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotherboardPayload>
          }
          aggregate: {
            args: Prisma.MotherboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMotherboard>
          }
          groupBy: {
            args: Prisma.MotherboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<MotherboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.MotherboardCountArgs<ExtArgs>
            result: $Utils.Optional<MotherboardCountAggregateOutputType> | number
          }
        }
      }
      Processor: {
        payload: Prisma.$ProcessorPayload<ExtArgs>
        fields: Prisma.ProcessorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>
          }
          findFirst: {
            args: Prisma.ProcessorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>
          }
          findMany: {
            args: Prisma.ProcessorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>[]
          }
          create: {
            args: Prisma.ProcessorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>
          }
          createMany: {
            args: Prisma.ProcessorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>[]
          }
          delete: {
            args: Prisma.ProcessorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>
          }
          update: {
            args: Prisma.ProcessorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>
          }
          deleteMany: {
            args: Prisma.ProcessorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessorPayload>
          }
          aggregate: {
            args: Prisma.ProcessorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessor>
          }
          groupBy: {
            args: Prisma.ProcessorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessorCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessorCountAggregateOutputType> | number
          }
        }
      }
      GPU: {
        payload: Prisma.$GPUPayload<ExtArgs>
        fields: Prisma.GPUFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GPUFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GPUFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>
          }
          findFirst: {
            args: Prisma.GPUFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GPUFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>
          }
          findMany: {
            args: Prisma.GPUFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>[]
          }
          create: {
            args: Prisma.GPUCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>
          }
          createMany: {
            args: Prisma.GPUCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GPUCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>[]
          }
          delete: {
            args: Prisma.GPUDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>
          }
          update: {
            args: Prisma.GPUUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>
          }
          deleteMany: {
            args: Prisma.GPUDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GPUUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GPUUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPUPayload>
          }
          aggregate: {
            args: Prisma.GPUAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGPU>
          }
          groupBy: {
            args: Prisma.GPUGroupByArgs<ExtArgs>
            result: $Utils.Optional<GPUGroupByOutputType>[]
          }
          count: {
            args: Prisma.GPUCountArgs<ExtArgs>
            result: $Utils.Optional<GPUCountAggregateOutputType> | number
          }
        }
      }
      RAM: {
        payload: Prisma.$RAMPayload<ExtArgs>
        fields: Prisma.RAMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RAMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RAMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>
          }
          findFirst: {
            args: Prisma.RAMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RAMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>
          }
          findMany: {
            args: Prisma.RAMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>[]
          }
          create: {
            args: Prisma.RAMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>
          }
          createMany: {
            args: Prisma.RAMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RAMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>[]
          }
          delete: {
            args: Prisma.RAMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>
          }
          update: {
            args: Prisma.RAMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>
          }
          deleteMany: {
            args: Prisma.RAMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RAMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RAMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAMPayload>
          }
          aggregate: {
            args: Prisma.RAMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRAM>
          }
          groupBy: {
            args: Prisma.RAMGroupByArgs<ExtArgs>
            result: $Utils.Optional<RAMGroupByOutputType>[]
          }
          count: {
            args: Prisma.RAMCountArgs<ExtArgs>
            result: $Utils.Optional<RAMCountAggregateOutputType> | number
          }
        }
      }
      Storage: {
        payload: Prisma.$StoragePayload<ExtArgs>
        fields: Prisma.StorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          findFirst: {
            args: Prisma.StorageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          findMany: {
            args: Prisma.StorageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>[]
          }
          create: {
            args: Prisma.StorageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          createMany: {
            args: Prisma.StorageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>[]
          }
          delete: {
            args: Prisma.StorageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          update: {
            args: Prisma.StorageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          deleteMany: {
            args: Prisma.StorageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          aggregate: {
            args: Prisma.StorageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorage>
          }
          groupBy: {
            args: Prisma.StorageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageCountArgs<ExtArgs>
            result: $Utils.Optional<StorageCountAggregateOutputType> | number
          }
        }
      }
      PowerSupply: {
        payload: Prisma.$PowerSupplyPayload<ExtArgs>
        fields: Prisma.PowerSupplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PowerSupplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PowerSupplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>
          }
          findFirst: {
            args: Prisma.PowerSupplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PowerSupplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>
          }
          findMany: {
            args: Prisma.PowerSupplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>[]
          }
          create: {
            args: Prisma.PowerSupplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>
          }
          createMany: {
            args: Prisma.PowerSupplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PowerSupplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>[]
          }
          delete: {
            args: Prisma.PowerSupplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>
          }
          update: {
            args: Prisma.PowerSupplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>
          }
          deleteMany: {
            args: Prisma.PowerSupplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PowerSupplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PowerSupplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerSupplyPayload>
          }
          aggregate: {
            args: Prisma.PowerSupplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePowerSupply>
          }
          groupBy: {
            args: Prisma.PowerSupplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PowerSupplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PowerSupplyCountArgs<ExtArgs>
            result: $Utils.Optional<PowerSupplyCountAggregateOutputType> | number
          }
        }
      }
      PCCase: {
        payload: Prisma.$PCCasePayload<ExtArgs>
        fields: Prisma.PCCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PCCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PCCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>
          }
          findFirst: {
            args: Prisma.PCCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PCCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>
          }
          findMany: {
            args: Prisma.PCCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>[]
          }
          create: {
            args: Prisma.PCCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>
          }
          createMany: {
            args: Prisma.PCCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PCCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>[]
          }
          delete: {
            args: Prisma.PCCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>
          }
          update: {
            args: Prisma.PCCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>
          }
          deleteMany: {
            args: Prisma.PCCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PCCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PCCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCCasePayload>
          }
          aggregate: {
            args: Prisma.PCCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePCCase>
          }
          groupBy: {
            args: Prisma.PCCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PCCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PCCaseCountArgs<ExtArgs>
            result: $Utils.Optional<PCCaseCountAggregateOutputType> | number
          }
        }
      }
      ParcialPCConfiguration: {
        payload: Prisma.$ParcialPCConfigurationPayload<ExtArgs>
        fields: Prisma.ParcialPCConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParcialPCConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParcialPCConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ParcialPCConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParcialPCConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>
          }
          findMany: {
            args: Prisma.ParcialPCConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>[]
          }
          create: {
            args: Prisma.ParcialPCConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>
          }
          createMany: {
            args: Prisma.ParcialPCConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParcialPCConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ParcialPCConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>
          }
          update: {
            args: Prisma.ParcialPCConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ParcialPCConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParcialPCConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParcialPCConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcialPCConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ParcialPCConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParcialPCConfiguration>
          }
          groupBy: {
            args: Prisma.ParcialPCConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParcialPCConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParcialPCConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ParcialPCConfigurationCountAggregateOutputType> | number
          }
        }
      }
      PCConfiguration: {
        payload: Prisma.$PCConfigurationPayload<ExtArgs>
        fields: Prisma.PCConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PCConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PCConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>
          }
          findFirst: {
            args: Prisma.PCConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PCConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>
          }
          findMany: {
            args: Prisma.PCConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>[]
          }
          create: {
            args: Prisma.PCConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>
          }
          createMany: {
            args: Prisma.PCConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PCConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>[]
          }
          delete: {
            args: Prisma.PCConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>
          }
          update: {
            args: Prisma.PCConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.PCConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PCConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PCConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PCConfigurationPayload>
          }
          aggregate: {
            args: Prisma.PCConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePCConfiguration>
          }
          groupBy: {
            args: Prisma.PCConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PCConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PCConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<PCConfigurationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userconfigurations: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userconfigurations?: boolean | UserCountOutputTypeCountUserconfigurationsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserconfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type MotherboardCountOutputType
   */

  export type MotherboardCountOutputType = {
    configurations: number
    partial: number
  }

  export type MotherboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | MotherboardCountOutputTypeCountConfigurationsArgs
    partial?: boolean | MotherboardCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * MotherboardCountOutputType without action
   */
  export type MotherboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherboardCountOutputType
     */
    select?: MotherboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MotherboardCountOutputType without action
   */
  export type MotherboardCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * MotherboardCountOutputType without action
   */
  export type MotherboardCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type ProcessorCountOutputType
   */

  export type ProcessorCountOutputType = {
    configurations: number
    partial: number
  }

  export type ProcessorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | ProcessorCountOutputTypeCountConfigurationsArgs
    partial?: boolean | ProcessorCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * ProcessorCountOutputType without action
   */
  export type ProcessorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessorCountOutputType
     */
    select?: ProcessorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessorCountOutputType without action
   */
  export type ProcessorCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * ProcessorCountOutputType without action
   */
  export type ProcessorCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type GPUCountOutputType
   */

  export type GPUCountOutputType = {
    configurations: number
    partial: number
  }

  export type GPUCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | GPUCountOutputTypeCountConfigurationsArgs
    partial?: boolean | GPUCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * GPUCountOutputType without action
   */
  export type GPUCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPUCountOutputType
     */
    select?: GPUCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GPUCountOutputType without action
   */
  export type GPUCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * GPUCountOutputType without action
   */
  export type GPUCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type RAMCountOutputType
   */

  export type RAMCountOutputType = {
    configurations: number
    partial: number
  }

  export type RAMCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | RAMCountOutputTypeCountConfigurationsArgs
    partial?: boolean | RAMCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * RAMCountOutputType without action
   */
  export type RAMCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAMCountOutputType
     */
    select?: RAMCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RAMCountOutputType without action
   */
  export type RAMCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * RAMCountOutputType without action
   */
  export type RAMCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type StorageCountOutputType
   */

  export type StorageCountOutputType = {
    configurations: number
    partial: number
  }

  export type StorageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | StorageCountOutputTypeCountConfigurationsArgs
    partial?: boolean | StorageCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageCountOutputType
     */
    select?: StorageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type PowerSupplyCountOutputType
   */

  export type PowerSupplyCountOutputType = {
    configurations: number
    partial: number
  }

  export type PowerSupplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | PowerSupplyCountOutputTypeCountConfigurationsArgs
    partial?: boolean | PowerSupplyCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * PowerSupplyCountOutputType without action
   */
  export type PowerSupplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupplyCountOutputType
     */
    select?: PowerSupplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PowerSupplyCountOutputType without action
   */
  export type PowerSupplyCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * PowerSupplyCountOutputType without action
   */
  export type PowerSupplyCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type PCCaseCountOutputType
   */

  export type PCCaseCountOutputType = {
    configurations: number
    partial: number
  }

  export type PCCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configurations?: boolean | PCCaseCountOutputTypeCountConfigurationsArgs
    partial?: boolean | PCCaseCountOutputTypeCountPartialArgs
  }

  // Custom InputTypes
  /**
   * PCCaseCountOutputType without action
   */
  export type PCCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCaseCountOutputType
     */
    select?: PCCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PCCaseCountOutputType without action
   */
  export type PCCaseCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
  }

  /**
   * PCCaseCountOutputType without action
   */
  export type PCCaseCountOutputTypeCountPartialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
  }


  /**
   * Count Type ParcialPCConfigurationCountOutputType
   */

  export type ParcialPCConfigurationCountOutputType = {
    rams: number
    storages: number
  }

  export type ParcialPCConfigurationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rams?: boolean | ParcialPCConfigurationCountOutputTypeCountRamsArgs
    storages?: boolean | ParcialPCConfigurationCountOutputTypeCountStoragesArgs
  }

  // Custom InputTypes
  /**
   * ParcialPCConfigurationCountOutputType without action
   */
  export type ParcialPCConfigurationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfigurationCountOutputType
     */
    select?: ParcialPCConfigurationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParcialPCConfigurationCountOutputType without action
   */
  export type ParcialPCConfigurationCountOutputTypeCountRamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RAMWhereInput
  }

  /**
   * ParcialPCConfigurationCountOutputType without action
   */
  export type ParcialPCConfigurationCountOutputTypeCountStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
  }


  /**
   * Count Type PCConfigurationCountOutputType
   */

  export type PCConfigurationCountOutputType = {
    rams: number
    storages: number
  }

  export type PCConfigurationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rams?: boolean | PCConfigurationCountOutputTypeCountRamsArgs
    storages?: boolean | PCConfigurationCountOutputTypeCountStoragesArgs
  }

  // Custom InputTypes
  /**
   * PCConfigurationCountOutputType without action
   */
  export type PCConfigurationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfigurationCountOutputType
     */
    select?: PCConfigurationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PCConfigurationCountOutputType without action
   */
  export type PCConfigurationCountOutputTypeCountRamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RAMWhereInput
  }

  /**
   * PCConfigurationCountOutputType without action
   */
  export type PCConfigurationCountOutputTypeCountStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    userId: string | null
    userType: $Enums.UserType | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    userId: string | null
    userType: $Enums.UserType | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    createdAt: number
    expiresAt: number
    userId: number
    userType: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    userId?: true
    userType?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    userId?: true
    userType?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    userId?: true
    userType?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    createdAt: Date
    expiresAt: Date
    userId: string
    userType: $Enums.UserType
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    userType?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    userType?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    userType?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      expiresAt: Date
      userId: string
      userType: $Enums.UserType
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly userType: FieldRef<"Session", 'UserType'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    price: number | null
  }

  export type ComponentSumAggregateOutputType = {
    price: number | null
  }

  export type ComponentMinAggregateOutputType = {
    id: string | null
    name: string | null
    componentType: $Enums.ComponentType | null
    price: number | null
    manufacturer: string | null
    imageUrl: string | null
    deletedAt: Date | null
  }

  export type ComponentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    componentType: $Enums.ComponentType | null
    price: number | null
    manufacturer: string | null
    imageUrl: string | null
    deletedAt: Date | null
  }

  export type ComponentCountAggregateOutputType = {
    id: number
    name: number
    componentType: number
    price: number
    manufacturer: number
    imageUrl: number
    deletedAt: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    price?: true
  }

  export type ComponentSumAggregateInputType = {
    price?: true
  }

  export type ComponentMinAggregateInputType = {
    id?: true
    name?: true
    componentType?: true
    price?: true
    manufacturer?: true
    imageUrl?: true
    deletedAt?: true
  }

  export type ComponentMaxAggregateInputType = {
    id?: true
    name?: true
    componentType?: true
    price?: true
    manufacturer?: true
    imageUrl?: true
    deletedAt?: true
  }

  export type ComponentCountAggregateInputType = {
    id?: true
    name?: true
    componentType?: true
    price?: true
    manufacturer?: true
    imageUrl?: true
    deletedAt?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Component to aggregate.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type ComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithAggregationInput | ComponentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: ComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    id: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt: Date | null
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends ComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type ComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    componentType?: boolean
    price?: boolean
    manufacturer?: boolean
    imageUrl?: boolean
    deletedAt?: boolean
    motherboard?: boolean | Component$motherboardArgs<ExtArgs>
    processor?: boolean | Component$processorArgs<ExtArgs>
    gpu?: boolean | Component$gpuArgs<ExtArgs>
    ram?: boolean | Component$ramArgs<ExtArgs>
    storage?: boolean | Component$storageArgs<ExtArgs>
    powerSupply?: boolean | Component$powerSupplyArgs<ExtArgs>
    pcCase?: boolean | Component$pcCaseArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    componentType?: boolean
    price?: boolean
    manufacturer?: boolean
    imageUrl?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectScalar = {
    id?: boolean
    name?: boolean
    componentType?: boolean
    price?: boolean
    manufacturer?: boolean
    imageUrl?: boolean
    deletedAt?: boolean
  }

  export type ComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motherboard?: boolean | Component$motherboardArgs<ExtArgs>
    processor?: boolean | Component$processorArgs<ExtArgs>
    gpu?: boolean | Component$gpuArgs<ExtArgs>
    ram?: boolean | Component$ramArgs<ExtArgs>
    storage?: boolean | Component$storageArgs<ExtArgs>
    powerSupply?: boolean | Component$powerSupplyArgs<ExtArgs>
    pcCase?: boolean | Component$pcCaseArgs<ExtArgs>
  }
  export type ComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Component"
    objects: {
      motherboard: Prisma.$MotherboardPayload<ExtArgs> | null
      processor: Prisma.$ProcessorPayload<ExtArgs> | null
      gpu: Prisma.$GPUPayload<ExtArgs> | null
      ram: Prisma.$RAMPayload<ExtArgs> | null
      storage: Prisma.$StoragePayload<ExtArgs> | null
      powerSupply: Prisma.$PowerSupplyPayload<ExtArgs> | null
      pcCase: Prisma.$PCCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      componentType: $Enums.ComponentType
      price: number
      manufacturer: string
      imageUrl: string
      deletedAt: Date | null
    }, ExtArgs["result"]["component"]>
    composites: {}
  }

  type ComponentGetPayload<S extends boolean | null | undefined | ComponentDefaultArgs> = $Result.GetResult<Prisma.$ComponentPayload, S>

  type ComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface ComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Component'], meta: { name: 'Component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {ComponentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentFindUniqueArgs>(args: SelectSubset<T, ComponentFindUniqueArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Component that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComponentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentFindFirstArgs>(args?: SelectSubset<T, ComponentFindFirstArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentWithIdOnly = await prisma.component.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentFindManyArgs>(args?: SelectSubset<T, ComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Component.
     * @param {ComponentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
     */
    create<T extends ComponentCreateArgs>(args: SelectSubset<T, ComponentCreateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Components.
     * @param {ComponentCreateManyArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentCreateManyArgs>(args?: SelectSubset<T, ComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Components and returns the data saved in the database.
     * @param {ComponentCreateManyAndReturnArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Component.
     * @param {ComponentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
     */
    delete<T extends ComponentDeleteArgs>(args: SelectSubset<T, ComponentDeleteArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Component.
     * @param {ComponentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentUpdateArgs>(args: SelectSubset<T, ComponentUpdateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Components.
     * @param {ComponentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentDeleteManyArgs>(args?: SelectSubset<T, ComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentUpdateManyArgs>(args: SelectSubset<T, ComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component.
     * @param {ComponentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
     */
    upsert<T extends ComponentUpsertArgs>(args: SelectSubset<T, ComponentUpsertArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends ComponentCountArgs>(
      args?: Subset<T, ComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Component model
   */
  readonly fields: ComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    motherboard<T extends Component$motherboardArgs<ExtArgs> = {}>(args?: Subset<T, Component$motherboardArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processor<T extends Component$processorArgs<ExtArgs> = {}>(args?: Subset<T, Component$processorArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    gpu<T extends Component$gpuArgs<ExtArgs> = {}>(args?: Subset<T, Component$gpuArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ram<T extends Component$ramArgs<ExtArgs> = {}>(args?: Subset<T, Component$ramArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    storage<T extends Component$storageArgs<ExtArgs> = {}>(args?: Subset<T, Component$storageArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    powerSupply<T extends Component$powerSupplyArgs<ExtArgs> = {}>(args?: Subset<T, Component$powerSupplyArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pcCase<T extends Component$pcCaseArgs<ExtArgs> = {}>(args?: Subset<T, Component$pcCaseArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Component model
   */ 
  interface ComponentFieldRefs {
    readonly id: FieldRef<"Component", 'String'>
    readonly name: FieldRef<"Component", 'String'>
    readonly componentType: FieldRef<"Component", 'ComponentType'>
    readonly price: FieldRef<"Component", 'Float'>
    readonly manufacturer: FieldRef<"Component", 'String'>
    readonly imageUrl: FieldRef<"Component", 'String'>
    readonly deletedAt: FieldRef<"Component", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Component findUnique
   */
  export type ComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findUniqueOrThrow
   */
  export type ComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findFirst
   */
  export type ComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findFirstOrThrow
   */
  export type ComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findMany
   */
  export type ComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Components to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component create
   */
  export type ComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a Component.
     */
    data: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
  }

  /**
   * Component createMany
   */
  export type ComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Component createManyAndReturn
   */
  export type ComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Component update
   */
  export type ComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a Component.
     */
    data: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
    /**
     * Choose, which Component to update.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component updateMany
   */
  export type ComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
  }

  /**
   * Component upsert
   */
  export type ComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the Component to update in case it exists.
     */
    where: ComponentWhereUniqueInput
    /**
     * In case the Component found by the `where` argument doesn't exist, create a new Component with this data.
     */
    create: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
    /**
     * In case the Component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
  }

  /**
   * Component delete
   */
  export type ComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter which Component to delete.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component deleteMany
   */
  export type ComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Components to delete
     */
    where?: ComponentWhereInput
  }

  /**
   * Component.motherboard
   */
  export type Component$motherboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    where?: MotherboardWhereInput
  }

  /**
   * Component.processor
   */
  export type Component$processorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    where?: ProcessorWhereInput
  }

  /**
   * Component.gpu
   */
  export type Component$gpuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    where?: GPUWhereInput
  }

  /**
   * Component.ram
   */
  export type Component$ramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    where?: RAMWhereInput
  }

  /**
   * Component.storage
   */
  export type Component$storageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
  }

  /**
   * Component.powerSupply
   */
  export type Component$powerSupplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    where?: PowerSupplyWhereInput
  }

  /**
   * Component.pcCase
   */
  export type Component$pcCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    where?: PCCaseWhereInput
  }

  /**
   * Component without action
   */
  export type ComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    userType: $Enums.UserType | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    userType: $Enums.UserType | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    userType: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    userType?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    userType?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    userType?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    userType: $Enums.UserType
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
    userconfigurations?: boolean | User$userconfigurationsArgs<ExtArgs>
    partialUserConfiguration?: boolean | User$partialUserConfigurationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userconfigurations?: boolean | User$userconfigurationsArgs<ExtArgs>
    partialUserConfiguration?: boolean | User$partialUserConfigurationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userconfigurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partialUserConfiguration: Prisma.$ParcialPCConfigurationPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      userType: $Enums.UserType
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userconfigurations<T extends User$userconfigurationsArgs<ExtArgs> = {}>(args?: Subset<T, User$userconfigurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partialUserConfiguration<T extends User$partialUserConfigurationArgs<ExtArgs> = {}>(args?: Subset<T, User$partialUserConfigurationArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'UserType'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.userconfigurations
   */
  export type User$userconfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * User.partialUserConfiguration
   */
  export type User$partialUserConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Motherboard
   */

  export type AggregateMotherboard = {
    _count: MotherboardCountAggregateOutputType | null
    _avg: MotherboardAvgAggregateOutputType | null
    _sum: MotherboardSumAggregateOutputType | null
    _min: MotherboardMinAggregateOutputType | null
    _max: MotherboardMaxAggregateOutputType | null
  }

  export type MotherboardAvgAggregateOutputType = {
    ramSlots: number | null
  }

  export type MotherboardSumAggregateOutputType = {
    ramSlots: number | null
  }

  export type MotherboardMinAggregateOutputType = {
    id: string | null
    socket: string | null
    formFactor: string | null
    ramSlots: number | null
    ramType: string | null
    gpuInterface: string | null
    stroageBusType: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type MotherboardMaxAggregateOutputType = {
    id: string | null
    socket: string | null
    formFactor: string | null
    ramSlots: number | null
    ramType: string | null
    gpuInterface: string | null
    stroageBusType: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type MotherboardCountAggregateOutputType = {
    id: number
    socket: number
    formFactor: number
    ramSlots: number
    ramType: number
    gpuInterface: number
    stroageBusType: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type MotherboardAvgAggregateInputType = {
    ramSlots?: true
  }

  export type MotherboardSumAggregateInputType = {
    ramSlots?: true
  }

  export type MotherboardMinAggregateInputType = {
    id?: true
    socket?: true
    formFactor?: true
    ramSlots?: true
    ramType?: true
    gpuInterface?: true
    stroageBusType?: true
    componentId?: true
    deletedAt?: true
  }

  export type MotherboardMaxAggregateInputType = {
    id?: true
    socket?: true
    formFactor?: true
    ramSlots?: true
    ramType?: true
    gpuInterface?: true
    stroageBusType?: true
    componentId?: true
    deletedAt?: true
  }

  export type MotherboardCountAggregateInputType = {
    id?: true
    socket?: true
    formFactor?: true
    ramSlots?: true
    ramType?: true
    gpuInterface?: true
    stroageBusType?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type MotherboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motherboard to aggregate.
     */
    where?: MotherboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motherboards to fetch.
     */
    orderBy?: MotherboardOrderByWithRelationInput | MotherboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotherboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motherboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motherboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Motherboards
    **/
    _count?: true | MotherboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotherboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotherboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotherboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotherboardMaxAggregateInputType
  }

  export type GetMotherboardAggregateType<T extends MotherboardAggregateArgs> = {
        [P in keyof T & keyof AggregateMotherboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotherboard[P]>
      : GetScalarType<T[P], AggregateMotherboard[P]>
  }




  export type MotherboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotherboardWhereInput
    orderBy?: MotherboardOrderByWithAggregationInput | MotherboardOrderByWithAggregationInput[]
    by: MotherboardScalarFieldEnum[] | MotherboardScalarFieldEnum
    having?: MotherboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotherboardCountAggregateInputType | true
    _avg?: MotherboardAvgAggregateInputType
    _sum?: MotherboardSumAggregateInputType
    _min?: MotherboardMinAggregateInputType
    _max?: MotherboardMaxAggregateInputType
  }

  export type MotherboardGroupByOutputType = {
    id: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    componentId: string
    deletedAt: Date | null
    _count: MotherboardCountAggregateOutputType | null
    _avg: MotherboardAvgAggregateOutputType | null
    _sum: MotherboardSumAggregateOutputType | null
    _min: MotherboardMinAggregateOutputType | null
    _max: MotherboardMaxAggregateOutputType | null
  }

  type GetMotherboardGroupByPayload<T extends MotherboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotherboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotherboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotherboardGroupByOutputType[P]>
            : GetScalarType<T[P], MotherboardGroupByOutputType[P]>
        }
      >
    >


  export type MotherboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    socket?: boolean
    formFactor?: boolean
    ramSlots?: boolean
    ramType?: boolean
    gpuInterface?: boolean
    stroageBusType?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | Motherboard$configurationsArgs<ExtArgs>
    partial?: boolean | Motherboard$partialArgs<ExtArgs>
    _count?: boolean | MotherboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motherboard"]>

  export type MotherboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    socket?: boolean
    formFactor?: boolean
    ramSlots?: boolean
    ramType?: boolean
    gpuInterface?: boolean
    stroageBusType?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motherboard"]>

  export type MotherboardSelectScalar = {
    id?: boolean
    socket?: boolean
    formFactor?: boolean
    ramSlots?: boolean
    ramType?: boolean
    gpuInterface?: boolean
    stroageBusType?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type MotherboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | Motherboard$configurationsArgs<ExtArgs>
    partial?: boolean | Motherboard$partialArgs<ExtArgs>
    _count?: boolean | MotherboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MotherboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $MotherboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Motherboard"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      socket: string
      formFactor: string
      ramSlots: number
      ramType: string
      gpuInterface: string
      stroageBusType: string
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["motherboard"]>
    composites: {}
  }

  type MotherboardGetPayload<S extends boolean | null | undefined | MotherboardDefaultArgs> = $Result.GetResult<Prisma.$MotherboardPayload, S>

  type MotherboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MotherboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MotherboardCountAggregateInputType | true
    }

  export interface MotherboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Motherboard'], meta: { name: 'Motherboard' } }
    /**
     * Find zero or one Motherboard that matches the filter.
     * @param {MotherboardFindUniqueArgs} args - Arguments to find a Motherboard
     * @example
     * // Get one Motherboard
     * const motherboard = await prisma.motherboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MotherboardFindUniqueArgs>(args: SelectSubset<T, MotherboardFindUniqueArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Motherboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MotherboardFindUniqueOrThrowArgs} args - Arguments to find a Motherboard
     * @example
     * // Get one Motherboard
     * const motherboard = await prisma.motherboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MotherboardFindUniqueOrThrowArgs>(args: SelectSubset<T, MotherboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Motherboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardFindFirstArgs} args - Arguments to find a Motherboard
     * @example
     * // Get one Motherboard
     * const motherboard = await prisma.motherboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MotherboardFindFirstArgs>(args?: SelectSubset<T, MotherboardFindFirstArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Motherboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardFindFirstOrThrowArgs} args - Arguments to find a Motherboard
     * @example
     * // Get one Motherboard
     * const motherboard = await prisma.motherboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MotherboardFindFirstOrThrowArgs>(args?: SelectSubset<T, MotherboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Motherboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motherboards
     * const motherboards = await prisma.motherboard.findMany()
     * 
     * // Get first 10 Motherboards
     * const motherboards = await prisma.motherboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motherboardWithIdOnly = await prisma.motherboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MotherboardFindManyArgs>(args?: SelectSubset<T, MotherboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Motherboard.
     * @param {MotherboardCreateArgs} args - Arguments to create a Motherboard.
     * @example
     * // Create one Motherboard
     * const Motherboard = await prisma.motherboard.create({
     *   data: {
     *     // ... data to create a Motherboard
     *   }
     * })
     * 
     */
    create<T extends MotherboardCreateArgs>(args: SelectSubset<T, MotherboardCreateArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Motherboards.
     * @param {MotherboardCreateManyArgs} args - Arguments to create many Motherboards.
     * @example
     * // Create many Motherboards
     * const motherboard = await prisma.motherboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MotherboardCreateManyArgs>(args?: SelectSubset<T, MotherboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Motherboards and returns the data saved in the database.
     * @param {MotherboardCreateManyAndReturnArgs} args - Arguments to create many Motherboards.
     * @example
     * // Create many Motherboards
     * const motherboard = await prisma.motherboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Motherboards and only return the `id`
     * const motherboardWithIdOnly = await prisma.motherboard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MotherboardCreateManyAndReturnArgs>(args?: SelectSubset<T, MotherboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Motherboard.
     * @param {MotherboardDeleteArgs} args - Arguments to delete one Motherboard.
     * @example
     * // Delete one Motherboard
     * const Motherboard = await prisma.motherboard.delete({
     *   where: {
     *     // ... filter to delete one Motherboard
     *   }
     * })
     * 
     */
    delete<T extends MotherboardDeleteArgs>(args: SelectSubset<T, MotherboardDeleteArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Motherboard.
     * @param {MotherboardUpdateArgs} args - Arguments to update one Motherboard.
     * @example
     * // Update one Motherboard
     * const motherboard = await prisma.motherboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MotherboardUpdateArgs>(args: SelectSubset<T, MotherboardUpdateArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Motherboards.
     * @param {MotherboardDeleteManyArgs} args - Arguments to filter Motherboards to delete.
     * @example
     * // Delete a few Motherboards
     * const { count } = await prisma.motherboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MotherboardDeleteManyArgs>(args?: SelectSubset<T, MotherboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motherboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motherboards
     * const motherboard = await prisma.motherboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MotherboardUpdateManyArgs>(args: SelectSubset<T, MotherboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Motherboard.
     * @param {MotherboardUpsertArgs} args - Arguments to update or create a Motherboard.
     * @example
     * // Update or create a Motherboard
     * const motherboard = await prisma.motherboard.upsert({
     *   create: {
     *     // ... data to create a Motherboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motherboard we want to update
     *   }
     * })
     */
    upsert<T extends MotherboardUpsertArgs>(args: SelectSubset<T, MotherboardUpsertArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Motherboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardCountArgs} args - Arguments to filter Motherboards to count.
     * @example
     * // Count the number of Motherboards
     * const count = await prisma.motherboard.count({
     *   where: {
     *     // ... the filter for the Motherboards we want to count
     *   }
     * })
    **/
    count<T extends MotherboardCountArgs>(
      args?: Subset<T, MotherboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotherboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motherboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotherboardAggregateArgs>(args: Subset<T, MotherboardAggregateArgs>): Prisma.PrismaPromise<GetMotherboardAggregateType<T>>

    /**
     * Group by Motherboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotherboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotherboardGroupByArgs['orderBy'] }
        : { orderBy?: MotherboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotherboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotherboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Motherboard model
   */
  readonly fields: MotherboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Motherboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MotherboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends Motherboard$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, Motherboard$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends Motherboard$partialArgs<ExtArgs> = {}>(args?: Subset<T, Motherboard$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Motherboard model
   */ 
  interface MotherboardFieldRefs {
    readonly id: FieldRef<"Motherboard", 'String'>
    readonly socket: FieldRef<"Motherboard", 'String'>
    readonly formFactor: FieldRef<"Motherboard", 'String'>
    readonly ramSlots: FieldRef<"Motherboard", 'Int'>
    readonly ramType: FieldRef<"Motherboard", 'String'>
    readonly gpuInterface: FieldRef<"Motherboard", 'String'>
    readonly stroageBusType: FieldRef<"Motherboard", 'String'>
    readonly componentId: FieldRef<"Motherboard", 'String'>
    readonly deletedAt: FieldRef<"Motherboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Motherboard findUnique
   */
  export type MotherboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * Filter, which Motherboard to fetch.
     */
    where: MotherboardWhereUniqueInput
  }

  /**
   * Motherboard findUniqueOrThrow
   */
  export type MotherboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * Filter, which Motherboard to fetch.
     */
    where: MotherboardWhereUniqueInput
  }

  /**
   * Motherboard findFirst
   */
  export type MotherboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * Filter, which Motherboard to fetch.
     */
    where?: MotherboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motherboards to fetch.
     */
    orderBy?: MotherboardOrderByWithRelationInput | MotherboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motherboards.
     */
    cursor?: MotherboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motherboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motherboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motherboards.
     */
    distinct?: MotherboardScalarFieldEnum | MotherboardScalarFieldEnum[]
  }

  /**
   * Motherboard findFirstOrThrow
   */
  export type MotherboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * Filter, which Motherboard to fetch.
     */
    where?: MotherboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motherboards to fetch.
     */
    orderBy?: MotherboardOrderByWithRelationInput | MotherboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motherboards.
     */
    cursor?: MotherboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motherboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motherboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motherboards.
     */
    distinct?: MotherboardScalarFieldEnum | MotherboardScalarFieldEnum[]
  }

  /**
   * Motherboard findMany
   */
  export type MotherboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * Filter, which Motherboards to fetch.
     */
    where?: MotherboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motherboards to fetch.
     */
    orderBy?: MotherboardOrderByWithRelationInput | MotherboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Motherboards.
     */
    cursor?: MotherboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motherboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motherboards.
     */
    skip?: number
    distinct?: MotherboardScalarFieldEnum | MotherboardScalarFieldEnum[]
  }

  /**
   * Motherboard create
   */
  export type MotherboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Motherboard.
     */
    data: XOR<MotherboardCreateInput, MotherboardUncheckedCreateInput>
  }

  /**
   * Motherboard createMany
   */
  export type MotherboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Motherboards.
     */
    data: MotherboardCreateManyInput | MotherboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Motherboard createManyAndReturn
   */
  export type MotherboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Motherboards.
     */
    data: MotherboardCreateManyInput | MotherboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Motherboard update
   */
  export type MotherboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Motherboard.
     */
    data: XOR<MotherboardUpdateInput, MotherboardUncheckedUpdateInput>
    /**
     * Choose, which Motherboard to update.
     */
    where: MotherboardWhereUniqueInput
  }

  /**
   * Motherboard updateMany
   */
  export type MotherboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Motherboards.
     */
    data: XOR<MotherboardUpdateManyMutationInput, MotherboardUncheckedUpdateManyInput>
    /**
     * Filter which Motherboards to update
     */
    where?: MotherboardWhereInput
  }

  /**
   * Motherboard upsert
   */
  export type MotherboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Motherboard to update in case it exists.
     */
    where: MotherboardWhereUniqueInput
    /**
     * In case the Motherboard found by the `where` argument doesn't exist, create a new Motherboard with this data.
     */
    create: XOR<MotherboardCreateInput, MotherboardUncheckedCreateInput>
    /**
     * In case the Motherboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotherboardUpdateInput, MotherboardUncheckedUpdateInput>
  }

  /**
   * Motherboard delete
   */
  export type MotherboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    /**
     * Filter which Motherboard to delete.
     */
    where: MotherboardWhereUniqueInput
  }

  /**
   * Motherboard deleteMany
   */
  export type MotherboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motherboards to delete
     */
    where?: MotherboardWhereInput
  }

  /**
   * Motherboard.configurations
   */
  export type Motherboard$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * Motherboard.partial
   */
  export type Motherboard$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * Motherboard without action
   */
  export type MotherboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
  }


  /**
   * Model Processor
   */

  export type AggregateProcessor = {
    _count: ProcessorCountAggregateOutputType | null
    _avg: ProcessorAvgAggregateOutputType | null
    _sum: ProcessorSumAggregateOutputType | null
    _min: ProcessorMinAggregateOutputType | null
    _max: ProcessorMaxAggregateOutputType | null
  }

  export type ProcessorAvgAggregateOutputType = {
    cores: number | null
    threads: number | null
    bits: number | null
  }

  export type ProcessorSumAggregateOutputType = {
    cores: number | null
    threads: number | null
    bits: number | null
  }

  export type ProcessorMinAggregateOutputType = {
    id: string | null
    architecture: string | null
    cores: number | null
    threads: number | null
    bits: number | null
    socket: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type ProcessorMaxAggregateOutputType = {
    id: string | null
    architecture: string | null
    cores: number | null
    threads: number | null
    bits: number | null
    socket: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type ProcessorCountAggregateOutputType = {
    id: number
    architecture: number
    cores: number
    threads: number
    bits: number
    socket: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type ProcessorAvgAggregateInputType = {
    cores?: true
    threads?: true
    bits?: true
  }

  export type ProcessorSumAggregateInputType = {
    cores?: true
    threads?: true
    bits?: true
  }

  export type ProcessorMinAggregateInputType = {
    id?: true
    architecture?: true
    cores?: true
    threads?: true
    bits?: true
    socket?: true
    componentId?: true
    deletedAt?: true
  }

  export type ProcessorMaxAggregateInputType = {
    id?: true
    architecture?: true
    cores?: true
    threads?: true
    bits?: true
    socket?: true
    componentId?: true
    deletedAt?: true
  }

  export type ProcessorCountAggregateInputType = {
    id?: true
    architecture?: true
    cores?: true
    threads?: true
    bits?: true
    socket?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type ProcessorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processor to aggregate.
     */
    where?: ProcessorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processors to fetch.
     */
    orderBy?: ProcessorOrderByWithRelationInput | ProcessorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processors
    **/
    _count?: true | ProcessorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessorMaxAggregateInputType
  }

  export type GetProcessorAggregateType<T extends ProcessorAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessor[P]>
      : GetScalarType<T[P], AggregateProcessor[P]>
  }




  export type ProcessorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessorWhereInput
    orderBy?: ProcessorOrderByWithAggregationInput | ProcessorOrderByWithAggregationInput[]
    by: ProcessorScalarFieldEnum[] | ProcessorScalarFieldEnum
    having?: ProcessorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessorCountAggregateInputType | true
    _avg?: ProcessorAvgAggregateInputType
    _sum?: ProcessorSumAggregateInputType
    _min?: ProcessorMinAggregateInputType
    _max?: ProcessorMaxAggregateInputType
  }

  export type ProcessorGroupByOutputType = {
    id: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    componentId: string
    deletedAt: Date | null
    _count: ProcessorCountAggregateOutputType | null
    _avg: ProcessorAvgAggregateOutputType | null
    _sum: ProcessorSumAggregateOutputType | null
    _min: ProcessorMinAggregateOutputType | null
    _max: ProcessorMaxAggregateOutputType | null
  }

  type GetProcessorGroupByPayload<T extends ProcessorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessorGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessorGroupByOutputType[P]>
        }
      >
    >


  export type ProcessorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    architecture?: boolean
    cores?: boolean
    threads?: boolean
    bits?: boolean
    socket?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | Processor$configurationsArgs<ExtArgs>
    partial?: boolean | Processor$partialArgs<ExtArgs>
    _count?: boolean | ProcessorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processor"]>

  export type ProcessorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    architecture?: boolean
    cores?: boolean
    threads?: boolean
    bits?: boolean
    socket?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processor"]>

  export type ProcessorSelectScalar = {
    id?: boolean
    architecture?: boolean
    cores?: boolean
    threads?: boolean
    bits?: boolean
    socket?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type ProcessorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | Processor$configurationsArgs<ExtArgs>
    partial?: boolean | Processor$partialArgs<ExtArgs>
    _count?: boolean | ProcessorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $ProcessorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Processor"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      architecture: string
      cores: number
      threads: number
      bits: number
      socket: string
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["processor"]>
    composites: {}
  }

  type ProcessorGetPayload<S extends boolean | null | undefined | ProcessorDefaultArgs> = $Result.GetResult<Prisma.$ProcessorPayload, S>

  type ProcessorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessorCountAggregateInputType | true
    }

  export interface ProcessorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Processor'], meta: { name: 'Processor' } }
    /**
     * Find zero or one Processor that matches the filter.
     * @param {ProcessorFindUniqueArgs} args - Arguments to find a Processor
     * @example
     * // Get one Processor
     * const processor = await prisma.processor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessorFindUniqueArgs>(args: SelectSubset<T, ProcessorFindUniqueArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Processor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessorFindUniqueOrThrowArgs} args - Arguments to find a Processor
     * @example
     * // Get one Processor
     * const processor = await prisma.processor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Processor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorFindFirstArgs} args - Arguments to find a Processor
     * @example
     * // Get one Processor
     * const processor = await prisma.processor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessorFindFirstArgs>(args?: SelectSubset<T, ProcessorFindFirstArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Processor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorFindFirstOrThrowArgs} args - Arguments to find a Processor
     * @example
     * // Get one Processor
     * const processor = await prisma.processor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Processors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processors
     * const processors = await prisma.processor.findMany()
     * 
     * // Get first 10 Processors
     * const processors = await prisma.processor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processorWithIdOnly = await prisma.processor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessorFindManyArgs>(args?: SelectSubset<T, ProcessorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Processor.
     * @param {ProcessorCreateArgs} args - Arguments to create a Processor.
     * @example
     * // Create one Processor
     * const Processor = await prisma.processor.create({
     *   data: {
     *     // ... data to create a Processor
     *   }
     * })
     * 
     */
    create<T extends ProcessorCreateArgs>(args: SelectSubset<T, ProcessorCreateArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Processors.
     * @param {ProcessorCreateManyArgs} args - Arguments to create many Processors.
     * @example
     * // Create many Processors
     * const processor = await prisma.processor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessorCreateManyArgs>(args?: SelectSubset<T, ProcessorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Processors and returns the data saved in the database.
     * @param {ProcessorCreateManyAndReturnArgs} args - Arguments to create many Processors.
     * @example
     * // Create many Processors
     * const processor = await prisma.processor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Processors and only return the `id`
     * const processorWithIdOnly = await prisma.processor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Processor.
     * @param {ProcessorDeleteArgs} args - Arguments to delete one Processor.
     * @example
     * // Delete one Processor
     * const Processor = await prisma.processor.delete({
     *   where: {
     *     // ... filter to delete one Processor
     *   }
     * })
     * 
     */
    delete<T extends ProcessorDeleteArgs>(args: SelectSubset<T, ProcessorDeleteArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Processor.
     * @param {ProcessorUpdateArgs} args - Arguments to update one Processor.
     * @example
     * // Update one Processor
     * const processor = await prisma.processor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessorUpdateArgs>(args: SelectSubset<T, ProcessorUpdateArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Processors.
     * @param {ProcessorDeleteManyArgs} args - Arguments to filter Processors to delete.
     * @example
     * // Delete a few Processors
     * const { count } = await prisma.processor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessorDeleteManyArgs>(args?: SelectSubset<T, ProcessorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processors
     * const processor = await prisma.processor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessorUpdateManyArgs>(args: SelectSubset<T, ProcessorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Processor.
     * @param {ProcessorUpsertArgs} args - Arguments to update or create a Processor.
     * @example
     * // Update or create a Processor
     * const processor = await prisma.processor.upsert({
     *   create: {
     *     // ... data to create a Processor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Processor we want to update
     *   }
     * })
     */
    upsert<T extends ProcessorUpsertArgs>(args: SelectSubset<T, ProcessorUpsertArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Processors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorCountArgs} args - Arguments to filter Processors to count.
     * @example
     * // Count the number of Processors
     * const count = await prisma.processor.count({
     *   where: {
     *     // ... the filter for the Processors we want to count
     *   }
     * })
    **/
    count<T extends ProcessorCountArgs>(
      args?: Subset<T, ProcessorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Processor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessorAggregateArgs>(args: Subset<T, ProcessorAggregateArgs>): Prisma.PrismaPromise<GetProcessorAggregateType<T>>

    /**
     * Group by Processor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessorGroupByArgs['orderBy'] }
        : { orderBy?: ProcessorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Processor model
   */
  readonly fields: ProcessorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Processor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends Processor$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, Processor$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends Processor$partialArgs<ExtArgs> = {}>(args?: Subset<T, Processor$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Processor model
   */ 
  interface ProcessorFieldRefs {
    readonly id: FieldRef<"Processor", 'String'>
    readonly architecture: FieldRef<"Processor", 'String'>
    readonly cores: FieldRef<"Processor", 'Int'>
    readonly threads: FieldRef<"Processor", 'Int'>
    readonly bits: FieldRef<"Processor", 'Int'>
    readonly socket: FieldRef<"Processor", 'String'>
    readonly componentId: FieldRef<"Processor", 'String'>
    readonly deletedAt: FieldRef<"Processor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Processor findUnique
   */
  export type ProcessorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * Filter, which Processor to fetch.
     */
    where: ProcessorWhereUniqueInput
  }

  /**
   * Processor findUniqueOrThrow
   */
  export type ProcessorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * Filter, which Processor to fetch.
     */
    where: ProcessorWhereUniqueInput
  }

  /**
   * Processor findFirst
   */
  export type ProcessorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * Filter, which Processor to fetch.
     */
    where?: ProcessorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processors to fetch.
     */
    orderBy?: ProcessorOrderByWithRelationInput | ProcessorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processors.
     */
    cursor?: ProcessorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processors.
     */
    distinct?: ProcessorScalarFieldEnum | ProcessorScalarFieldEnum[]
  }

  /**
   * Processor findFirstOrThrow
   */
  export type ProcessorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * Filter, which Processor to fetch.
     */
    where?: ProcessorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processors to fetch.
     */
    orderBy?: ProcessorOrderByWithRelationInput | ProcessorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processors.
     */
    cursor?: ProcessorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processors.
     */
    distinct?: ProcessorScalarFieldEnum | ProcessorScalarFieldEnum[]
  }

  /**
   * Processor findMany
   */
  export type ProcessorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * Filter, which Processors to fetch.
     */
    where?: ProcessorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processors to fetch.
     */
    orderBy?: ProcessorOrderByWithRelationInput | ProcessorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processors.
     */
    cursor?: ProcessorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processors.
     */
    skip?: number
    distinct?: ProcessorScalarFieldEnum | ProcessorScalarFieldEnum[]
  }

  /**
   * Processor create
   */
  export type ProcessorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * The data needed to create a Processor.
     */
    data: XOR<ProcessorCreateInput, ProcessorUncheckedCreateInput>
  }

  /**
   * Processor createMany
   */
  export type ProcessorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processors.
     */
    data: ProcessorCreateManyInput | ProcessorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Processor createManyAndReturn
   */
  export type ProcessorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Processors.
     */
    data: ProcessorCreateManyInput | ProcessorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Processor update
   */
  export type ProcessorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * The data needed to update a Processor.
     */
    data: XOR<ProcessorUpdateInput, ProcessorUncheckedUpdateInput>
    /**
     * Choose, which Processor to update.
     */
    where: ProcessorWhereUniqueInput
  }

  /**
   * Processor updateMany
   */
  export type ProcessorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processors.
     */
    data: XOR<ProcessorUpdateManyMutationInput, ProcessorUncheckedUpdateManyInput>
    /**
     * Filter which Processors to update
     */
    where?: ProcessorWhereInput
  }

  /**
   * Processor upsert
   */
  export type ProcessorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * The filter to search for the Processor to update in case it exists.
     */
    where: ProcessorWhereUniqueInput
    /**
     * In case the Processor found by the `where` argument doesn't exist, create a new Processor with this data.
     */
    create: XOR<ProcessorCreateInput, ProcessorUncheckedCreateInput>
    /**
     * In case the Processor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessorUpdateInput, ProcessorUncheckedUpdateInput>
  }

  /**
   * Processor delete
   */
  export type ProcessorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    /**
     * Filter which Processor to delete.
     */
    where: ProcessorWhereUniqueInput
  }

  /**
   * Processor deleteMany
   */
  export type ProcessorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processors to delete
     */
    where?: ProcessorWhereInput
  }

  /**
   * Processor.configurations
   */
  export type Processor$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * Processor.partial
   */
  export type Processor$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * Processor without action
   */
  export type ProcessorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
  }


  /**
   * Model GPU
   */

  export type AggregateGPU = {
    _count: GPUCountAggregateOutputType | null
    _avg: GPUAvgAggregateOutputType | null
    _sum: GPUSumAggregateOutputType | null
    _min: GPUMinAggregateOutputType | null
    _max: GPUMaxAggregateOutputType | null
  }

  export type GPUAvgAggregateOutputType = {
    memory: number | null
    power: number | null
  }

  export type GPUSumAggregateOutputType = {
    memory: number | null
    power: number | null
  }

  export type GPUMinAggregateOutputType = {
    id: string | null
    memory: number | null
    powerConnector: string | null
    interface: string | null
    power: number | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type GPUMaxAggregateOutputType = {
    id: string | null
    memory: number | null
    powerConnector: string | null
    interface: string | null
    power: number | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type GPUCountAggregateOutputType = {
    id: number
    memory: number
    powerConnector: number
    interface: number
    power: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type GPUAvgAggregateInputType = {
    memory?: true
    power?: true
  }

  export type GPUSumAggregateInputType = {
    memory?: true
    power?: true
  }

  export type GPUMinAggregateInputType = {
    id?: true
    memory?: true
    powerConnector?: true
    interface?: true
    power?: true
    componentId?: true
    deletedAt?: true
  }

  export type GPUMaxAggregateInputType = {
    id?: true
    memory?: true
    powerConnector?: true
    interface?: true
    power?: true
    componentId?: true
    deletedAt?: true
  }

  export type GPUCountAggregateInputType = {
    id?: true
    memory?: true
    powerConnector?: true
    interface?: true
    power?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type GPUAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPU to aggregate.
     */
    where?: GPUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPUS to fetch.
     */
    orderBy?: GPUOrderByWithRelationInput | GPUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GPUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPUS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GPUS
    **/
    _count?: true | GPUCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GPUAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GPUSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GPUMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GPUMaxAggregateInputType
  }

  export type GetGPUAggregateType<T extends GPUAggregateArgs> = {
        [P in keyof T & keyof AggregateGPU]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGPU[P]>
      : GetScalarType<T[P], AggregateGPU[P]>
  }




  export type GPUGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPUWhereInput
    orderBy?: GPUOrderByWithAggregationInput | GPUOrderByWithAggregationInput[]
    by: GPUScalarFieldEnum[] | GPUScalarFieldEnum
    having?: GPUScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GPUCountAggregateInputType | true
    _avg?: GPUAvgAggregateInputType
    _sum?: GPUSumAggregateInputType
    _min?: GPUMinAggregateInputType
    _max?: GPUMaxAggregateInputType
  }

  export type GPUGroupByOutputType = {
    id: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    componentId: string
    deletedAt: Date | null
    _count: GPUCountAggregateOutputType | null
    _avg: GPUAvgAggregateOutputType | null
    _sum: GPUSumAggregateOutputType | null
    _min: GPUMinAggregateOutputType | null
    _max: GPUMaxAggregateOutputType | null
  }

  type GetGPUGroupByPayload<T extends GPUGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GPUGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GPUGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GPUGroupByOutputType[P]>
            : GetScalarType<T[P], GPUGroupByOutputType[P]>
        }
      >
    >


  export type GPUSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memory?: boolean
    powerConnector?: boolean
    interface?: boolean
    power?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | GPU$configurationsArgs<ExtArgs>
    partial?: boolean | GPU$partialArgs<ExtArgs>
    _count?: boolean | GPUCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPU"]>

  export type GPUSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memory?: boolean
    powerConnector?: boolean
    interface?: boolean
    power?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPU"]>

  export type GPUSelectScalar = {
    id?: boolean
    memory?: boolean
    powerConnector?: boolean
    interface?: boolean
    power?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type GPUInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | GPU$configurationsArgs<ExtArgs>
    partial?: boolean | GPU$partialArgs<ExtArgs>
    _count?: boolean | GPUCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GPUIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $GPUPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GPU"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memory: number
      powerConnector: string
      interface: string
      power: number
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["gPU"]>
    composites: {}
  }

  type GPUGetPayload<S extends boolean | null | undefined | GPUDefaultArgs> = $Result.GetResult<Prisma.$GPUPayload, S>

  type GPUCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GPUFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GPUCountAggregateInputType | true
    }

  export interface GPUDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GPU'], meta: { name: 'GPU' } }
    /**
     * Find zero or one GPU that matches the filter.
     * @param {GPUFindUniqueArgs} args - Arguments to find a GPU
     * @example
     * // Get one GPU
     * const gPU = await prisma.gPU.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GPUFindUniqueArgs>(args: SelectSubset<T, GPUFindUniqueArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GPU that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GPUFindUniqueOrThrowArgs} args - Arguments to find a GPU
     * @example
     * // Get one GPU
     * const gPU = await prisma.gPU.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GPUFindUniqueOrThrowArgs>(args: SelectSubset<T, GPUFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GPU that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUFindFirstArgs} args - Arguments to find a GPU
     * @example
     * // Get one GPU
     * const gPU = await prisma.gPU.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GPUFindFirstArgs>(args?: SelectSubset<T, GPUFindFirstArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GPU that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUFindFirstOrThrowArgs} args - Arguments to find a GPU
     * @example
     * // Get one GPU
     * const gPU = await prisma.gPU.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GPUFindFirstOrThrowArgs>(args?: SelectSubset<T, GPUFindFirstOrThrowArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GPUS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GPUS
     * const gPUS = await prisma.gPU.findMany()
     * 
     * // Get first 10 GPUS
     * const gPUS = await prisma.gPU.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gPUWithIdOnly = await prisma.gPU.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GPUFindManyArgs>(args?: SelectSubset<T, GPUFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GPU.
     * @param {GPUCreateArgs} args - Arguments to create a GPU.
     * @example
     * // Create one GPU
     * const GPU = await prisma.gPU.create({
     *   data: {
     *     // ... data to create a GPU
     *   }
     * })
     * 
     */
    create<T extends GPUCreateArgs>(args: SelectSubset<T, GPUCreateArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GPUS.
     * @param {GPUCreateManyArgs} args - Arguments to create many GPUS.
     * @example
     * // Create many GPUS
     * const gPU = await prisma.gPU.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GPUCreateManyArgs>(args?: SelectSubset<T, GPUCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GPUS and returns the data saved in the database.
     * @param {GPUCreateManyAndReturnArgs} args - Arguments to create many GPUS.
     * @example
     * // Create many GPUS
     * const gPU = await prisma.gPU.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GPUS and only return the `id`
     * const gPUWithIdOnly = await prisma.gPU.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GPUCreateManyAndReturnArgs>(args?: SelectSubset<T, GPUCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GPU.
     * @param {GPUDeleteArgs} args - Arguments to delete one GPU.
     * @example
     * // Delete one GPU
     * const GPU = await prisma.gPU.delete({
     *   where: {
     *     // ... filter to delete one GPU
     *   }
     * })
     * 
     */
    delete<T extends GPUDeleteArgs>(args: SelectSubset<T, GPUDeleteArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GPU.
     * @param {GPUUpdateArgs} args - Arguments to update one GPU.
     * @example
     * // Update one GPU
     * const gPU = await prisma.gPU.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GPUUpdateArgs>(args: SelectSubset<T, GPUUpdateArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GPUS.
     * @param {GPUDeleteManyArgs} args - Arguments to filter GPUS to delete.
     * @example
     * // Delete a few GPUS
     * const { count } = await prisma.gPU.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GPUDeleteManyArgs>(args?: SelectSubset<T, GPUDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GPUS
     * const gPU = await prisma.gPU.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GPUUpdateManyArgs>(args: SelectSubset<T, GPUUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GPU.
     * @param {GPUUpsertArgs} args - Arguments to update or create a GPU.
     * @example
     * // Update or create a GPU
     * const gPU = await prisma.gPU.upsert({
     *   create: {
     *     // ... data to create a GPU
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GPU we want to update
     *   }
     * })
     */
    upsert<T extends GPUUpsertArgs>(args: SelectSubset<T, GPUUpsertArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GPUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUCountArgs} args - Arguments to filter GPUS to count.
     * @example
     * // Count the number of GPUS
     * const count = await prisma.gPU.count({
     *   where: {
     *     // ... the filter for the GPUS we want to count
     *   }
     * })
    **/
    count<T extends GPUCountArgs>(
      args?: Subset<T, GPUCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GPUCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GPU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GPUAggregateArgs>(args: Subset<T, GPUAggregateArgs>): Prisma.PrismaPromise<GetGPUAggregateType<T>>

    /**
     * Group by GPU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPUGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GPUGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GPUGroupByArgs['orderBy'] }
        : { orderBy?: GPUGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GPUGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGPUGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GPU model
   */
  readonly fields: GPUFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GPU.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GPUClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends GPU$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, GPU$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends GPU$partialArgs<ExtArgs> = {}>(args?: Subset<T, GPU$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GPU model
   */ 
  interface GPUFieldRefs {
    readonly id: FieldRef<"GPU", 'String'>
    readonly memory: FieldRef<"GPU", 'Int'>
    readonly powerConnector: FieldRef<"GPU", 'String'>
    readonly interface: FieldRef<"GPU", 'String'>
    readonly power: FieldRef<"GPU", 'Int'>
    readonly componentId: FieldRef<"GPU", 'String'>
    readonly deletedAt: FieldRef<"GPU", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GPU findUnique
   */
  export type GPUFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * Filter, which GPU to fetch.
     */
    where: GPUWhereUniqueInput
  }

  /**
   * GPU findUniqueOrThrow
   */
  export type GPUFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * Filter, which GPU to fetch.
     */
    where: GPUWhereUniqueInput
  }

  /**
   * GPU findFirst
   */
  export type GPUFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * Filter, which GPU to fetch.
     */
    where?: GPUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPUS to fetch.
     */
    orderBy?: GPUOrderByWithRelationInput | GPUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPUS.
     */
    cursor?: GPUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPUS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPUS.
     */
    distinct?: GPUScalarFieldEnum | GPUScalarFieldEnum[]
  }

  /**
   * GPU findFirstOrThrow
   */
  export type GPUFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * Filter, which GPU to fetch.
     */
    where?: GPUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPUS to fetch.
     */
    orderBy?: GPUOrderByWithRelationInput | GPUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPUS.
     */
    cursor?: GPUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPUS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPUS.
     */
    distinct?: GPUScalarFieldEnum | GPUScalarFieldEnum[]
  }

  /**
   * GPU findMany
   */
  export type GPUFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * Filter, which GPUS to fetch.
     */
    where?: GPUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPUS to fetch.
     */
    orderBy?: GPUOrderByWithRelationInput | GPUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GPUS.
     */
    cursor?: GPUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPUS.
     */
    skip?: number
    distinct?: GPUScalarFieldEnum | GPUScalarFieldEnum[]
  }

  /**
   * GPU create
   */
  export type GPUCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * The data needed to create a GPU.
     */
    data: XOR<GPUCreateInput, GPUUncheckedCreateInput>
  }

  /**
   * GPU createMany
   */
  export type GPUCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GPUS.
     */
    data: GPUCreateManyInput | GPUCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPU createManyAndReturn
   */
  export type GPUCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GPUS.
     */
    data: GPUCreateManyInput | GPUCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GPU update
   */
  export type GPUUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * The data needed to update a GPU.
     */
    data: XOR<GPUUpdateInput, GPUUncheckedUpdateInput>
    /**
     * Choose, which GPU to update.
     */
    where: GPUWhereUniqueInput
  }

  /**
   * GPU updateMany
   */
  export type GPUUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GPUS.
     */
    data: XOR<GPUUpdateManyMutationInput, GPUUncheckedUpdateManyInput>
    /**
     * Filter which GPUS to update
     */
    where?: GPUWhereInput
  }

  /**
   * GPU upsert
   */
  export type GPUUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * The filter to search for the GPU to update in case it exists.
     */
    where: GPUWhereUniqueInput
    /**
     * In case the GPU found by the `where` argument doesn't exist, create a new GPU with this data.
     */
    create: XOR<GPUCreateInput, GPUUncheckedCreateInput>
    /**
     * In case the GPU was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GPUUpdateInput, GPUUncheckedUpdateInput>
  }

  /**
   * GPU delete
   */
  export type GPUDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    /**
     * Filter which GPU to delete.
     */
    where: GPUWhereUniqueInput
  }

  /**
   * GPU deleteMany
   */
  export type GPUDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPUS to delete
     */
    where?: GPUWhereInput
  }

  /**
   * GPU.configurations
   */
  export type GPU$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * GPU.partial
   */
  export type GPU$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * GPU without action
   */
  export type GPUDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
  }


  /**
   * Model RAM
   */

  export type AggregateRAM = {
    _count: RAMCountAggregateOutputType | null
    _avg: RAMAvgAggregateOutputType | null
    _sum: RAMSumAggregateOutputType | null
    _min: RAMMinAggregateOutputType | null
    _max: RAMMaxAggregateOutputType | null
  }

  export type RAMAvgAggregateOutputType = {
    capacity: number | null
  }

  export type RAMSumAggregateOutputType = {
    capacity: number | null
  }

  export type RAMMinAggregateOutputType = {
    id: string | null
    memoryType: string | null
    capacity: number | null
    computerType: $Enums.ComputerType | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type RAMMaxAggregateOutputType = {
    id: string | null
    memoryType: string | null
    capacity: number | null
    computerType: $Enums.ComputerType | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type RAMCountAggregateOutputType = {
    id: number
    memoryType: number
    capacity: number
    computerType: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type RAMAvgAggregateInputType = {
    capacity?: true
  }

  export type RAMSumAggregateInputType = {
    capacity?: true
  }

  export type RAMMinAggregateInputType = {
    id?: true
    memoryType?: true
    capacity?: true
    computerType?: true
    componentId?: true
    deletedAt?: true
  }

  export type RAMMaxAggregateInputType = {
    id?: true
    memoryType?: true
    capacity?: true
    computerType?: true
    componentId?: true
    deletedAt?: true
  }

  export type RAMCountAggregateInputType = {
    id?: true
    memoryType?: true
    capacity?: true
    computerType?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type RAMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RAM to aggregate.
     */
    where?: RAMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAMS to fetch.
     */
    orderBy?: RAMOrderByWithRelationInput | RAMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RAMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RAMS
    **/
    _count?: true | RAMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RAMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RAMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RAMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RAMMaxAggregateInputType
  }

  export type GetRAMAggregateType<T extends RAMAggregateArgs> = {
        [P in keyof T & keyof AggregateRAM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRAM[P]>
      : GetScalarType<T[P], AggregateRAM[P]>
  }




  export type RAMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RAMWhereInput
    orderBy?: RAMOrderByWithAggregationInput | RAMOrderByWithAggregationInput[]
    by: RAMScalarFieldEnum[] | RAMScalarFieldEnum
    having?: RAMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RAMCountAggregateInputType | true
    _avg?: RAMAvgAggregateInputType
    _sum?: RAMSumAggregateInputType
    _min?: RAMMinAggregateInputType
    _max?: RAMMaxAggregateInputType
  }

  export type RAMGroupByOutputType = {
    id: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    componentId: string
    deletedAt: Date | null
    _count: RAMCountAggregateOutputType | null
    _avg: RAMAvgAggregateOutputType | null
    _sum: RAMSumAggregateOutputType | null
    _min: RAMMinAggregateOutputType | null
    _max: RAMMaxAggregateOutputType | null
  }

  type GetRAMGroupByPayload<T extends RAMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RAMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RAMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RAMGroupByOutputType[P]>
            : GetScalarType<T[P], RAMGroupByOutputType[P]>
        }
      >
    >


  export type RAMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memoryType?: boolean
    capacity?: boolean
    computerType?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | RAM$configurationsArgs<ExtArgs>
    partial?: boolean | RAM$partialArgs<ExtArgs>
    _count?: boolean | RAMCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rAM"]>

  export type RAMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memoryType?: boolean
    capacity?: boolean
    computerType?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rAM"]>

  export type RAMSelectScalar = {
    id?: boolean
    memoryType?: boolean
    capacity?: boolean
    computerType?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type RAMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | RAM$configurationsArgs<ExtArgs>
    partial?: boolean | RAM$partialArgs<ExtArgs>
    _count?: boolean | RAMCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RAMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $RAMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RAM"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memoryType: string
      capacity: number
      computerType: $Enums.ComputerType
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["rAM"]>
    composites: {}
  }

  type RAMGetPayload<S extends boolean | null | undefined | RAMDefaultArgs> = $Result.GetResult<Prisma.$RAMPayload, S>

  type RAMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RAMFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RAMCountAggregateInputType | true
    }

  export interface RAMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RAM'], meta: { name: 'RAM' } }
    /**
     * Find zero or one RAM that matches the filter.
     * @param {RAMFindUniqueArgs} args - Arguments to find a RAM
     * @example
     * // Get one RAM
     * const rAM = await prisma.rAM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RAMFindUniqueArgs>(args: SelectSubset<T, RAMFindUniqueArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RAM that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RAMFindUniqueOrThrowArgs} args - Arguments to find a RAM
     * @example
     * // Get one RAM
     * const rAM = await prisma.rAM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RAMFindUniqueOrThrowArgs>(args: SelectSubset<T, RAMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RAM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMFindFirstArgs} args - Arguments to find a RAM
     * @example
     * // Get one RAM
     * const rAM = await prisma.rAM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RAMFindFirstArgs>(args?: SelectSubset<T, RAMFindFirstArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RAM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMFindFirstOrThrowArgs} args - Arguments to find a RAM
     * @example
     * // Get one RAM
     * const rAM = await prisma.rAM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RAMFindFirstOrThrowArgs>(args?: SelectSubset<T, RAMFindFirstOrThrowArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RAMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RAMS
     * const rAMS = await prisma.rAM.findMany()
     * 
     * // Get first 10 RAMS
     * const rAMS = await prisma.rAM.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rAMWithIdOnly = await prisma.rAM.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RAMFindManyArgs>(args?: SelectSubset<T, RAMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RAM.
     * @param {RAMCreateArgs} args - Arguments to create a RAM.
     * @example
     * // Create one RAM
     * const RAM = await prisma.rAM.create({
     *   data: {
     *     // ... data to create a RAM
     *   }
     * })
     * 
     */
    create<T extends RAMCreateArgs>(args: SelectSubset<T, RAMCreateArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RAMS.
     * @param {RAMCreateManyArgs} args - Arguments to create many RAMS.
     * @example
     * // Create many RAMS
     * const rAM = await prisma.rAM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RAMCreateManyArgs>(args?: SelectSubset<T, RAMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RAMS and returns the data saved in the database.
     * @param {RAMCreateManyAndReturnArgs} args - Arguments to create many RAMS.
     * @example
     * // Create many RAMS
     * const rAM = await prisma.rAM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RAMS and only return the `id`
     * const rAMWithIdOnly = await prisma.rAM.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RAMCreateManyAndReturnArgs>(args?: SelectSubset<T, RAMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RAM.
     * @param {RAMDeleteArgs} args - Arguments to delete one RAM.
     * @example
     * // Delete one RAM
     * const RAM = await prisma.rAM.delete({
     *   where: {
     *     // ... filter to delete one RAM
     *   }
     * })
     * 
     */
    delete<T extends RAMDeleteArgs>(args: SelectSubset<T, RAMDeleteArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RAM.
     * @param {RAMUpdateArgs} args - Arguments to update one RAM.
     * @example
     * // Update one RAM
     * const rAM = await prisma.rAM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RAMUpdateArgs>(args: SelectSubset<T, RAMUpdateArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RAMS.
     * @param {RAMDeleteManyArgs} args - Arguments to filter RAMS to delete.
     * @example
     * // Delete a few RAMS
     * const { count } = await prisma.rAM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RAMDeleteManyArgs>(args?: SelectSubset<T, RAMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RAMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RAMS
     * const rAM = await prisma.rAM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RAMUpdateManyArgs>(args: SelectSubset<T, RAMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RAM.
     * @param {RAMUpsertArgs} args - Arguments to update or create a RAM.
     * @example
     * // Update or create a RAM
     * const rAM = await prisma.rAM.upsert({
     *   create: {
     *     // ... data to create a RAM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RAM we want to update
     *   }
     * })
     */
    upsert<T extends RAMUpsertArgs>(args: SelectSubset<T, RAMUpsertArgs<ExtArgs>>): Prisma__RAMClient<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RAMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMCountArgs} args - Arguments to filter RAMS to count.
     * @example
     * // Count the number of RAMS
     * const count = await prisma.rAM.count({
     *   where: {
     *     // ... the filter for the RAMS we want to count
     *   }
     * })
    **/
    count<T extends RAMCountArgs>(
      args?: Subset<T, RAMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RAMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RAM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RAMAggregateArgs>(args: Subset<T, RAMAggregateArgs>): Prisma.PrismaPromise<GetRAMAggregateType<T>>

    /**
     * Group by RAM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RAMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RAMGroupByArgs['orderBy'] }
        : { orderBy?: RAMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RAMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRAMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RAM model
   */
  readonly fields: RAMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RAM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RAMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends RAM$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, RAM$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends RAM$partialArgs<ExtArgs> = {}>(args?: Subset<T, RAM$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RAM model
   */ 
  interface RAMFieldRefs {
    readonly id: FieldRef<"RAM", 'String'>
    readonly memoryType: FieldRef<"RAM", 'String'>
    readonly capacity: FieldRef<"RAM", 'Int'>
    readonly computerType: FieldRef<"RAM", 'ComputerType'>
    readonly componentId: FieldRef<"RAM", 'String'>
    readonly deletedAt: FieldRef<"RAM", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RAM findUnique
   */
  export type RAMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * Filter, which RAM to fetch.
     */
    where: RAMWhereUniqueInput
  }

  /**
   * RAM findUniqueOrThrow
   */
  export type RAMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * Filter, which RAM to fetch.
     */
    where: RAMWhereUniqueInput
  }

  /**
   * RAM findFirst
   */
  export type RAMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * Filter, which RAM to fetch.
     */
    where?: RAMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAMS to fetch.
     */
    orderBy?: RAMOrderByWithRelationInput | RAMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RAMS.
     */
    cursor?: RAMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RAMS.
     */
    distinct?: RAMScalarFieldEnum | RAMScalarFieldEnum[]
  }

  /**
   * RAM findFirstOrThrow
   */
  export type RAMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * Filter, which RAM to fetch.
     */
    where?: RAMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAMS to fetch.
     */
    orderBy?: RAMOrderByWithRelationInput | RAMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RAMS.
     */
    cursor?: RAMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RAMS.
     */
    distinct?: RAMScalarFieldEnum | RAMScalarFieldEnum[]
  }

  /**
   * RAM findMany
   */
  export type RAMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * Filter, which RAMS to fetch.
     */
    where?: RAMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAMS to fetch.
     */
    orderBy?: RAMOrderByWithRelationInput | RAMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RAMS.
     */
    cursor?: RAMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAMS.
     */
    skip?: number
    distinct?: RAMScalarFieldEnum | RAMScalarFieldEnum[]
  }

  /**
   * RAM create
   */
  export type RAMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * The data needed to create a RAM.
     */
    data: XOR<RAMCreateInput, RAMUncheckedCreateInput>
  }

  /**
   * RAM createMany
   */
  export type RAMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RAMS.
     */
    data: RAMCreateManyInput | RAMCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RAM createManyAndReturn
   */
  export type RAMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RAMS.
     */
    data: RAMCreateManyInput | RAMCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RAM update
   */
  export type RAMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * The data needed to update a RAM.
     */
    data: XOR<RAMUpdateInput, RAMUncheckedUpdateInput>
    /**
     * Choose, which RAM to update.
     */
    where: RAMWhereUniqueInput
  }

  /**
   * RAM updateMany
   */
  export type RAMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RAMS.
     */
    data: XOR<RAMUpdateManyMutationInput, RAMUncheckedUpdateManyInput>
    /**
     * Filter which RAMS to update
     */
    where?: RAMWhereInput
  }

  /**
   * RAM upsert
   */
  export type RAMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * The filter to search for the RAM to update in case it exists.
     */
    where: RAMWhereUniqueInput
    /**
     * In case the RAM found by the `where` argument doesn't exist, create a new RAM with this data.
     */
    create: XOR<RAMCreateInput, RAMUncheckedCreateInput>
    /**
     * In case the RAM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RAMUpdateInput, RAMUncheckedUpdateInput>
  }

  /**
   * RAM delete
   */
  export type RAMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    /**
     * Filter which RAM to delete.
     */
    where: RAMWhereUniqueInput
  }

  /**
   * RAM deleteMany
   */
  export type RAMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RAMS to delete
     */
    where?: RAMWhereInput
  }

  /**
   * RAM.configurations
   */
  export type RAM$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * RAM.partial
   */
  export type RAM$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * RAM without action
   */
  export type RAMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
  }


  /**
   * Model Storage
   */

  export type AggregateStorage = {
    _count: StorageCountAggregateOutputType | null
    _avg: StorageAvgAggregateOutputType | null
    _sum: StorageSumAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  export type StorageAvgAggregateOutputType = {
    capacity: number | null
  }

  export type StorageSumAggregateOutputType = {
    capacity: number | null
  }

  export type StorageMinAggregateOutputType = {
    id: string | null
    storageType: string | null
    capacity: number | null
    busType: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type StorageMaxAggregateOutputType = {
    id: string | null
    storageType: string | null
    capacity: number | null
    busType: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type StorageCountAggregateOutputType = {
    id: number
    storageType: number
    capacity: number
    busType: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type StorageAvgAggregateInputType = {
    capacity?: true
  }

  export type StorageSumAggregateInputType = {
    capacity?: true
  }

  export type StorageMinAggregateInputType = {
    id?: true
    storageType?: true
    capacity?: true
    busType?: true
    componentId?: true
    deletedAt?: true
  }

  export type StorageMaxAggregateInputType = {
    id?: true
    storageType?: true
    capacity?: true
    busType?: true
    componentId?: true
    deletedAt?: true
  }

  export type StorageCountAggregateInputType = {
    id?: true
    storageType?: true
    capacity?: true
    busType?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type StorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Storage to aggregate.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Storages
    **/
    _count?: true | StorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageMaxAggregateInputType
  }

  export type GetStorageAggregateType<T extends StorageAggregateArgs> = {
        [P in keyof T & keyof AggregateStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorage[P]>
      : GetScalarType<T[P], AggregateStorage[P]>
  }




  export type StorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithAggregationInput | StorageOrderByWithAggregationInput[]
    by: StorageScalarFieldEnum[] | StorageScalarFieldEnum
    having?: StorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageCountAggregateInputType | true
    _avg?: StorageAvgAggregateInputType
    _sum?: StorageSumAggregateInputType
    _min?: StorageMinAggregateInputType
    _max?: StorageMaxAggregateInputType
  }

  export type StorageGroupByOutputType = {
    id: string
    storageType: string
    capacity: number
    busType: string
    componentId: string
    deletedAt: Date | null
    _count: StorageCountAggregateOutputType | null
    _avg: StorageAvgAggregateOutputType | null
    _sum: StorageSumAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  type GetStorageGroupByPayload<T extends StorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageGroupByOutputType[P]>
            : GetScalarType<T[P], StorageGroupByOutputType[P]>
        }
      >
    >


  export type StorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storageType?: boolean
    capacity?: boolean
    busType?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | Storage$configurationsArgs<ExtArgs>
    partial?: boolean | Storage$partialArgs<ExtArgs>
    _count?: boolean | StorageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storage"]>

  export type StorageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storageType?: boolean
    capacity?: boolean
    busType?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storage"]>

  export type StorageSelectScalar = {
    id?: boolean
    storageType?: boolean
    capacity?: boolean
    busType?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type StorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | Storage$configurationsArgs<ExtArgs>
    partial?: boolean | Storage$partialArgs<ExtArgs>
    _count?: boolean | StorageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StorageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $StoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Storage"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storageType: string
      capacity: number
      busType: string
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["storage"]>
    composites: {}
  }

  type StorageGetPayload<S extends boolean | null | undefined | StorageDefaultArgs> = $Result.GetResult<Prisma.$StoragePayload, S>

  type StorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorageCountAggregateInputType | true
    }

  export interface StorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Storage'], meta: { name: 'Storage' } }
    /**
     * Find zero or one Storage that matches the filter.
     * @param {StorageFindUniqueArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageFindUniqueArgs>(args: SelectSubset<T, StorageFindUniqueArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Storage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorageFindUniqueOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageFindFirstArgs>(args?: SelectSubset<T, StorageFindFirstArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Storage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storages
     * const storages = await prisma.storage.findMany()
     * 
     * // Get first 10 Storages
     * const storages = await prisma.storage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageWithIdOnly = await prisma.storage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageFindManyArgs>(args?: SelectSubset<T, StorageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Storage.
     * @param {StorageCreateArgs} args - Arguments to create a Storage.
     * @example
     * // Create one Storage
     * const Storage = await prisma.storage.create({
     *   data: {
     *     // ... data to create a Storage
     *   }
     * })
     * 
     */
    create<T extends StorageCreateArgs>(args: SelectSubset<T, StorageCreateArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Storages.
     * @param {StorageCreateManyArgs} args - Arguments to create many Storages.
     * @example
     * // Create many Storages
     * const storage = await prisma.storage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageCreateManyArgs>(args?: SelectSubset<T, StorageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Storages and returns the data saved in the database.
     * @param {StorageCreateManyAndReturnArgs} args - Arguments to create many Storages.
     * @example
     * // Create many Storages
     * const storage = await prisma.storage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Storages and only return the `id`
     * const storageWithIdOnly = await prisma.storage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorageCreateManyAndReturnArgs>(args?: SelectSubset<T, StorageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Storage.
     * @param {StorageDeleteArgs} args - Arguments to delete one Storage.
     * @example
     * // Delete one Storage
     * const Storage = await prisma.storage.delete({
     *   where: {
     *     // ... filter to delete one Storage
     *   }
     * })
     * 
     */
    delete<T extends StorageDeleteArgs>(args: SelectSubset<T, StorageDeleteArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Storage.
     * @param {StorageUpdateArgs} args - Arguments to update one Storage.
     * @example
     * // Update one Storage
     * const storage = await prisma.storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageUpdateArgs>(args: SelectSubset<T, StorageUpdateArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Storages.
     * @param {StorageDeleteManyArgs} args - Arguments to filter Storages to delete.
     * @example
     * // Delete a few Storages
     * const { count } = await prisma.storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageDeleteManyArgs>(args?: SelectSubset<T, StorageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storages
     * const storage = await prisma.storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageUpdateManyArgs>(args: SelectSubset<T, StorageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Storage.
     * @param {StorageUpsertArgs} args - Arguments to update or create a Storage.
     * @example
     * // Update or create a Storage
     * const storage = await prisma.storage.upsert({
     *   create: {
     *     // ... data to create a Storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storage we want to update
     *   }
     * })
     */
    upsert<T extends StorageUpsertArgs>(args: SelectSubset<T, StorageUpsertArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageCountArgs} args - Arguments to filter Storages to count.
     * @example
     * // Count the number of Storages
     * const count = await prisma.storage.count({
     *   where: {
     *     // ... the filter for the Storages we want to count
     *   }
     * })
    **/
    count<T extends StorageCountArgs>(
      args?: Subset<T, StorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageAggregateArgs>(args: Subset<T, StorageAggregateArgs>): Prisma.PrismaPromise<GetStorageAggregateType<T>>

    /**
     * Group by Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageGroupByArgs['orderBy'] }
        : { orderBy?: StorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Storage model
   */
  readonly fields: StorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends Storage$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, Storage$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends Storage$partialArgs<ExtArgs> = {}>(args?: Subset<T, Storage$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Storage model
   */ 
  interface StorageFieldRefs {
    readonly id: FieldRef<"Storage", 'String'>
    readonly storageType: FieldRef<"Storage", 'String'>
    readonly capacity: FieldRef<"Storage", 'Int'>
    readonly busType: FieldRef<"Storage", 'String'>
    readonly componentId: FieldRef<"Storage", 'String'>
    readonly deletedAt: FieldRef<"Storage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Storage findUnique
   */
  export type StorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where: StorageWhereUniqueInput
  }

  /**
   * Storage findUniqueOrThrow
   */
  export type StorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where: StorageWhereUniqueInput
  }

  /**
   * Storage findFirst
   */
  export type StorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     */
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }

  /**
   * Storage findFirstOrThrow
   */
  export type StorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     */
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }

  /**
   * Storage findMany
   */
  export type StorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storages to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }

  /**
   * Storage create
   */
  export type StorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The data needed to create a Storage.
     */
    data: XOR<StorageCreateInput, StorageUncheckedCreateInput>
  }

  /**
   * Storage createMany
   */
  export type StorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Storages.
     */
    data: StorageCreateManyInput | StorageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Storage createManyAndReturn
   */
  export type StorageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Storages.
     */
    data: StorageCreateManyInput | StorageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Storage update
   */
  export type StorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The data needed to update a Storage.
     */
    data: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
    /**
     * Choose, which Storage to update.
     */
    where: StorageWhereUniqueInput
  }

  /**
   * Storage updateMany
   */
  export type StorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Storages.
     */
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyInput>
    /**
     * Filter which Storages to update
     */
    where?: StorageWhereInput
  }

  /**
   * Storage upsert
   */
  export type StorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The filter to search for the Storage to update in case it exists.
     */
    where: StorageWhereUniqueInput
    /**
     * In case the Storage found by the `where` argument doesn't exist, create a new Storage with this data.
     */
    create: XOR<StorageCreateInput, StorageUncheckedCreateInput>
    /**
     * In case the Storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
  }

  /**
   * Storage delete
   */
  export type StorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter which Storage to delete.
     */
    where: StorageWhereUniqueInput
  }

  /**
   * Storage deleteMany
   */
  export type StorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Storages to delete
     */
    where?: StorageWhereInput
  }

  /**
   * Storage.configurations
   */
  export type Storage$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * Storage.partial
   */
  export type Storage$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * Storage without action
   */
  export type StorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
  }


  /**
   * Model PowerSupply
   */

  export type AggregatePowerSupply = {
    _count: PowerSupplyCountAggregateOutputType | null
    _avg: PowerSupplyAvgAggregateOutputType | null
    _sum: PowerSupplySumAggregateOutputType | null
    _min: PowerSupplyMinAggregateOutputType | null
    _max: PowerSupplyMaxAggregateOutputType | null
  }

  export type PowerSupplyAvgAggregateOutputType = {
    powerOutput: number | null
  }

  export type PowerSupplySumAggregateOutputType = {
    powerOutput: number | null
  }

  export type PowerSupplyMinAggregateOutputType = {
    id: string | null
    powerOutput: number | null
    efficiency: string | null
    formFactor: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type PowerSupplyMaxAggregateOutputType = {
    id: string | null
    powerOutput: number | null
    efficiency: string | null
    formFactor: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type PowerSupplyCountAggregateOutputType = {
    id: number
    powerOutput: number
    efficiency: number
    formFactor: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type PowerSupplyAvgAggregateInputType = {
    powerOutput?: true
  }

  export type PowerSupplySumAggregateInputType = {
    powerOutput?: true
  }

  export type PowerSupplyMinAggregateInputType = {
    id?: true
    powerOutput?: true
    efficiency?: true
    formFactor?: true
    componentId?: true
    deletedAt?: true
  }

  export type PowerSupplyMaxAggregateInputType = {
    id?: true
    powerOutput?: true
    efficiency?: true
    formFactor?: true
    componentId?: true
    deletedAt?: true
  }

  export type PowerSupplyCountAggregateInputType = {
    id?: true
    powerOutput?: true
    efficiency?: true
    formFactor?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type PowerSupplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PowerSupply to aggregate.
     */
    where?: PowerSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerSupplies to fetch.
     */
    orderBy?: PowerSupplyOrderByWithRelationInput | PowerSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PowerSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PowerSupplies
    **/
    _count?: true | PowerSupplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PowerSupplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PowerSupplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PowerSupplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PowerSupplyMaxAggregateInputType
  }

  export type GetPowerSupplyAggregateType<T extends PowerSupplyAggregateArgs> = {
        [P in keyof T & keyof AggregatePowerSupply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePowerSupply[P]>
      : GetScalarType<T[P], AggregatePowerSupply[P]>
  }




  export type PowerSupplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PowerSupplyWhereInput
    orderBy?: PowerSupplyOrderByWithAggregationInput | PowerSupplyOrderByWithAggregationInput[]
    by: PowerSupplyScalarFieldEnum[] | PowerSupplyScalarFieldEnum
    having?: PowerSupplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PowerSupplyCountAggregateInputType | true
    _avg?: PowerSupplyAvgAggregateInputType
    _sum?: PowerSupplySumAggregateInputType
    _min?: PowerSupplyMinAggregateInputType
    _max?: PowerSupplyMaxAggregateInputType
  }

  export type PowerSupplyGroupByOutputType = {
    id: string
    powerOutput: number
    efficiency: string
    formFactor: string
    componentId: string
    deletedAt: Date | null
    _count: PowerSupplyCountAggregateOutputType | null
    _avg: PowerSupplyAvgAggregateOutputType | null
    _sum: PowerSupplySumAggregateOutputType | null
    _min: PowerSupplyMinAggregateOutputType | null
    _max: PowerSupplyMaxAggregateOutputType | null
  }

  type GetPowerSupplyGroupByPayload<T extends PowerSupplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PowerSupplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PowerSupplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PowerSupplyGroupByOutputType[P]>
            : GetScalarType<T[P], PowerSupplyGroupByOutputType[P]>
        }
      >
    >


  export type PowerSupplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    powerOutput?: boolean
    efficiency?: boolean
    formFactor?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | PowerSupply$configurationsArgs<ExtArgs>
    partial?: boolean | PowerSupply$partialArgs<ExtArgs>
    _count?: boolean | PowerSupplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["powerSupply"]>

  export type PowerSupplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    powerOutput?: boolean
    efficiency?: boolean
    formFactor?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["powerSupply"]>

  export type PowerSupplySelectScalar = {
    id?: boolean
    powerOutput?: boolean
    efficiency?: boolean
    formFactor?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type PowerSupplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | PowerSupply$configurationsArgs<ExtArgs>
    partial?: boolean | PowerSupply$partialArgs<ExtArgs>
    _count?: boolean | PowerSupplyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PowerSupplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $PowerSupplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PowerSupply"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      powerOutput: number
      efficiency: string
      formFactor: string
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["powerSupply"]>
    composites: {}
  }

  type PowerSupplyGetPayload<S extends boolean | null | undefined | PowerSupplyDefaultArgs> = $Result.GetResult<Prisma.$PowerSupplyPayload, S>

  type PowerSupplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PowerSupplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PowerSupplyCountAggregateInputType | true
    }

  export interface PowerSupplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PowerSupply'], meta: { name: 'PowerSupply' } }
    /**
     * Find zero or one PowerSupply that matches the filter.
     * @param {PowerSupplyFindUniqueArgs} args - Arguments to find a PowerSupply
     * @example
     * // Get one PowerSupply
     * const powerSupply = await prisma.powerSupply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PowerSupplyFindUniqueArgs>(args: SelectSubset<T, PowerSupplyFindUniqueArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PowerSupply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PowerSupplyFindUniqueOrThrowArgs} args - Arguments to find a PowerSupply
     * @example
     * // Get one PowerSupply
     * const powerSupply = await prisma.powerSupply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PowerSupplyFindUniqueOrThrowArgs>(args: SelectSubset<T, PowerSupplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PowerSupply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyFindFirstArgs} args - Arguments to find a PowerSupply
     * @example
     * // Get one PowerSupply
     * const powerSupply = await prisma.powerSupply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PowerSupplyFindFirstArgs>(args?: SelectSubset<T, PowerSupplyFindFirstArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PowerSupply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyFindFirstOrThrowArgs} args - Arguments to find a PowerSupply
     * @example
     * // Get one PowerSupply
     * const powerSupply = await prisma.powerSupply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PowerSupplyFindFirstOrThrowArgs>(args?: SelectSubset<T, PowerSupplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PowerSupplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PowerSupplies
     * const powerSupplies = await prisma.powerSupply.findMany()
     * 
     * // Get first 10 PowerSupplies
     * const powerSupplies = await prisma.powerSupply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const powerSupplyWithIdOnly = await prisma.powerSupply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PowerSupplyFindManyArgs>(args?: SelectSubset<T, PowerSupplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PowerSupply.
     * @param {PowerSupplyCreateArgs} args - Arguments to create a PowerSupply.
     * @example
     * // Create one PowerSupply
     * const PowerSupply = await prisma.powerSupply.create({
     *   data: {
     *     // ... data to create a PowerSupply
     *   }
     * })
     * 
     */
    create<T extends PowerSupplyCreateArgs>(args: SelectSubset<T, PowerSupplyCreateArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PowerSupplies.
     * @param {PowerSupplyCreateManyArgs} args - Arguments to create many PowerSupplies.
     * @example
     * // Create many PowerSupplies
     * const powerSupply = await prisma.powerSupply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PowerSupplyCreateManyArgs>(args?: SelectSubset<T, PowerSupplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PowerSupplies and returns the data saved in the database.
     * @param {PowerSupplyCreateManyAndReturnArgs} args - Arguments to create many PowerSupplies.
     * @example
     * // Create many PowerSupplies
     * const powerSupply = await prisma.powerSupply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PowerSupplies and only return the `id`
     * const powerSupplyWithIdOnly = await prisma.powerSupply.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PowerSupplyCreateManyAndReturnArgs>(args?: SelectSubset<T, PowerSupplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PowerSupply.
     * @param {PowerSupplyDeleteArgs} args - Arguments to delete one PowerSupply.
     * @example
     * // Delete one PowerSupply
     * const PowerSupply = await prisma.powerSupply.delete({
     *   where: {
     *     // ... filter to delete one PowerSupply
     *   }
     * })
     * 
     */
    delete<T extends PowerSupplyDeleteArgs>(args: SelectSubset<T, PowerSupplyDeleteArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PowerSupply.
     * @param {PowerSupplyUpdateArgs} args - Arguments to update one PowerSupply.
     * @example
     * // Update one PowerSupply
     * const powerSupply = await prisma.powerSupply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PowerSupplyUpdateArgs>(args: SelectSubset<T, PowerSupplyUpdateArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PowerSupplies.
     * @param {PowerSupplyDeleteManyArgs} args - Arguments to filter PowerSupplies to delete.
     * @example
     * // Delete a few PowerSupplies
     * const { count } = await prisma.powerSupply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PowerSupplyDeleteManyArgs>(args?: SelectSubset<T, PowerSupplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PowerSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PowerSupplies
     * const powerSupply = await prisma.powerSupply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PowerSupplyUpdateManyArgs>(args: SelectSubset<T, PowerSupplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PowerSupply.
     * @param {PowerSupplyUpsertArgs} args - Arguments to update or create a PowerSupply.
     * @example
     * // Update or create a PowerSupply
     * const powerSupply = await prisma.powerSupply.upsert({
     *   create: {
     *     // ... data to create a PowerSupply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PowerSupply we want to update
     *   }
     * })
     */
    upsert<T extends PowerSupplyUpsertArgs>(args: SelectSubset<T, PowerSupplyUpsertArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PowerSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyCountArgs} args - Arguments to filter PowerSupplies to count.
     * @example
     * // Count the number of PowerSupplies
     * const count = await prisma.powerSupply.count({
     *   where: {
     *     // ... the filter for the PowerSupplies we want to count
     *   }
     * })
    **/
    count<T extends PowerSupplyCountArgs>(
      args?: Subset<T, PowerSupplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PowerSupplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PowerSupply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PowerSupplyAggregateArgs>(args: Subset<T, PowerSupplyAggregateArgs>): Prisma.PrismaPromise<GetPowerSupplyAggregateType<T>>

    /**
     * Group by PowerSupply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerSupplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PowerSupplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PowerSupplyGroupByArgs['orderBy'] }
        : { orderBy?: PowerSupplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PowerSupplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPowerSupplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PowerSupply model
   */
  readonly fields: PowerSupplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PowerSupply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PowerSupplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends PowerSupply$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, PowerSupply$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends PowerSupply$partialArgs<ExtArgs> = {}>(args?: Subset<T, PowerSupply$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PowerSupply model
   */ 
  interface PowerSupplyFieldRefs {
    readonly id: FieldRef<"PowerSupply", 'String'>
    readonly powerOutput: FieldRef<"PowerSupply", 'Int'>
    readonly efficiency: FieldRef<"PowerSupply", 'String'>
    readonly formFactor: FieldRef<"PowerSupply", 'String'>
    readonly componentId: FieldRef<"PowerSupply", 'String'>
    readonly deletedAt: FieldRef<"PowerSupply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PowerSupply findUnique
   */
  export type PowerSupplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * Filter, which PowerSupply to fetch.
     */
    where: PowerSupplyWhereUniqueInput
  }

  /**
   * PowerSupply findUniqueOrThrow
   */
  export type PowerSupplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * Filter, which PowerSupply to fetch.
     */
    where: PowerSupplyWhereUniqueInput
  }

  /**
   * PowerSupply findFirst
   */
  export type PowerSupplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * Filter, which PowerSupply to fetch.
     */
    where?: PowerSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerSupplies to fetch.
     */
    orderBy?: PowerSupplyOrderByWithRelationInput | PowerSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PowerSupplies.
     */
    cursor?: PowerSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PowerSupplies.
     */
    distinct?: PowerSupplyScalarFieldEnum | PowerSupplyScalarFieldEnum[]
  }

  /**
   * PowerSupply findFirstOrThrow
   */
  export type PowerSupplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * Filter, which PowerSupply to fetch.
     */
    where?: PowerSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerSupplies to fetch.
     */
    orderBy?: PowerSupplyOrderByWithRelationInput | PowerSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PowerSupplies.
     */
    cursor?: PowerSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PowerSupplies.
     */
    distinct?: PowerSupplyScalarFieldEnum | PowerSupplyScalarFieldEnum[]
  }

  /**
   * PowerSupply findMany
   */
  export type PowerSupplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * Filter, which PowerSupplies to fetch.
     */
    where?: PowerSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerSupplies to fetch.
     */
    orderBy?: PowerSupplyOrderByWithRelationInput | PowerSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PowerSupplies.
     */
    cursor?: PowerSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerSupplies.
     */
    skip?: number
    distinct?: PowerSupplyScalarFieldEnum | PowerSupplyScalarFieldEnum[]
  }

  /**
   * PowerSupply create
   */
  export type PowerSupplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * The data needed to create a PowerSupply.
     */
    data: XOR<PowerSupplyCreateInput, PowerSupplyUncheckedCreateInput>
  }

  /**
   * PowerSupply createMany
   */
  export type PowerSupplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PowerSupplies.
     */
    data: PowerSupplyCreateManyInput | PowerSupplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PowerSupply createManyAndReturn
   */
  export type PowerSupplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PowerSupplies.
     */
    data: PowerSupplyCreateManyInput | PowerSupplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PowerSupply update
   */
  export type PowerSupplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * The data needed to update a PowerSupply.
     */
    data: XOR<PowerSupplyUpdateInput, PowerSupplyUncheckedUpdateInput>
    /**
     * Choose, which PowerSupply to update.
     */
    where: PowerSupplyWhereUniqueInput
  }

  /**
   * PowerSupply updateMany
   */
  export type PowerSupplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PowerSupplies.
     */
    data: XOR<PowerSupplyUpdateManyMutationInput, PowerSupplyUncheckedUpdateManyInput>
    /**
     * Filter which PowerSupplies to update
     */
    where?: PowerSupplyWhereInput
  }

  /**
   * PowerSupply upsert
   */
  export type PowerSupplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * The filter to search for the PowerSupply to update in case it exists.
     */
    where: PowerSupplyWhereUniqueInput
    /**
     * In case the PowerSupply found by the `where` argument doesn't exist, create a new PowerSupply with this data.
     */
    create: XOR<PowerSupplyCreateInput, PowerSupplyUncheckedCreateInput>
    /**
     * In case the PowerSupply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PowerSupplyUpdateInput, PowerSupplyUncheckedUpdateInput>
  }

  /**
   * PowerSupply delete
   */
  export type PowerSupplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    /**
     * Filter which PowerSupply to delete.
     */
    where: PowerSupplyWhereUniqueInput
  }

  /**
   * PowerSupply deleteMany
   */
  export type PowerSupplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PowerSupplies to delete
     */
    where?: PowerSupplyWhereInput
  }

  /**
   * PowerSupply.configurations
   */
  export type PowerSupply$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * PowerSupply.partial
   */
  export type PowerSupply$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * PowerSupply without action
   */
  export type PowerSupplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
  }


  /**
   * Model PCCase
   */

  export type AggregatePCCase = {
    _count: PCCaseCountAggregateOutputType | null
    _min: PCCaseMinAggregateOutputType | null
    _max: PCCaseMaxAggregateOutputType | null
  }

  export type PCCaseMinAggregateOutputType = {
    id: string | null
    formFactor: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type PCCaseMaxAggregateOutputType = {
    id: string | null
    formFactor: string | null
    componentId: string | null
    deletedAt: Date | null
  }

  export type PCCaseCountAggregateOutputType = {
    id: number
    formFactor: number
    componentId: number
    deletedAt: number
    _all: number
  }


  export type PCCaseMinAggregateInputType = {
    id?: true
    formFactor?: true
    componentId?: true
    deletedAt?: true
  }

  export type PCCaseMaxAggregateInputType = {
    id?: true
    formFactor?: true
    componentId?: true
    deletedAt?: true
  }

  export type PCCaseCountAggregateInputType = {
    id?: true
    formFactor?: true
    componentId?: true
    deletedAt?: true
    _all?: true
  }

  export type PCCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PCCase to aggregate.
     */
    where?: PCCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCCases to fetch.
     */
    orderBy?: PCCaseOrderByWithRelationInput | PCCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PCCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PCCases
    **/
    _count?: true | PCCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PCCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PCCaseMaxAggregateInputType
  }

  export type GetPCCaseAggregateType<T extends PCCaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePCCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePCCase[P]>
      : GetScalarType<T[P], AggregatePCCase[P]>
  }




  export type PCCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCCaseWhereInput
    orderBy?: PCCaseOrderByWithAggregationInput | PCCaseOrderByWithAggregationInput[]
    by: PCCaseScalarFieldEnum[] | PCCaseScalarFieldEnum
    having?: PCCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PCCaseCountAggregateInputType | true
    _min?: PCCaseMinAggregateInputType
    _max?: PCCaseMaxAggregateInputType
  }

  export type PCCaseGroupByOutputType = {
    id: string
    formFactor: string
    componentId: string
    deletedAt: Date | null
    _count: PCCaseCountAggregateOutputType | null
    _min: PCCaseMinAggregateOutputType | null
    _max: PCCaseMaxAggregateOutputType | null
  }

  type GetPCCaseGroupByPayload<T extends PCCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PCCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PCCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PCCaseGroupByOutputType[P]>
            : GetScalarType<T[P], PCCaseGroupByOutputType[P]>
        }
      >
    >


  export type PCCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formFactor?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | PCCase$configurationsArgs<ExtArgs>
    partial?: boolean | PCCase$partialArgs<ExtArgs>
    _count?: boolean | PCCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pCCase"]>

  export type PCCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formFactor?: boolean
    componentId?: boolean
    deletedAt?: boolean
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pCCase"]>

  export type PCCaseSelectScalar = {
    id?: boolean
    formFactor?: boolean
    componentId?: boolean
    deletedAt?: boolean
  }

  export type PCCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
    configurations?: boolean | PCCase$configurationsArgs<ExtArgs>
    partial?: boolean | PCCase$partialArgs<ExtArgs>
    _count?: boolean | PCCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PCCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $PCCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PCCase"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs>
      configurations: Prisma.$PCConfigurationPayload<ExtArgs>[]
      partial: Prisma.$ParcialPCConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formFactor: string
      componentId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["pCCase"]>
    composites: {}
  }

  type PCCaseGetPayload<S extends boolean | null | undefined | PCCaseDefaultArgs> = $Result.GetResult<Prisma.$PCCasePayload, S>

  type PCCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PCCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PCCaseCountAggregateInputType | true
    }

  export interface PCCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PCCase'], meta: { name: 'PCCase' } }
    /**
     * Find zero or one PCCase that matches the filter.
     * @param {PCCaseFindUniqueArgs} args - Arguments to find a PCCase
     * @example
     * // Get one PCCase
     * const pCCase = await prisma.pCCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PCCaseFindUniqueArgs>(args: SelectSubset<T, PCCaseFindUniqueArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PCCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PCCaseFindUniqueOrThrowArgs} args - Arguments to find a PCCase
     * @example
     * // Get one PCCase
     * const pCCase = await prisma.pCCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PCCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PCCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PCCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseFindFirstArgs} args - Arguments to find a PCCase
     * @example
     * // Get one PCCase
     * const pCCase = await prisma.pCCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PCCaseFindFirstArgs>(args?: SelectSubset<T, PCCaseFindFirstArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PCCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseFindFirstOrThrowArgs} args - Arguments to find a PCCase
     * @example
     * // Get one PCCase
     * const pCCase = await prisma.pCCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PCCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PCCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PCCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PCCases
     * const pCCases = await prisma.pCCase.findMany()
     * 
     * // Get first 10 PCCases
     * const pCCases = await prisma.pCCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pCCaseWithIdOnly = await prisma.pCCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PCCaseFindManyArgs>(args?: SelectSubset<T, PCCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PCCase.
     * @param {PCCaseCreateArgs} args - Arguments to create a PCCase.
     * @example
     * // Create one PCCase
     * const PCCase = await prisma.pCCase.create({
     *   data: {
     *     // ... data to create a PCCase
     *   }
     * })
     * 
     */
    create<T extends PCCaseCreateArgs>(args: SelectSubset<T, PCCaseCreateArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PCCases.
     * @param {PCCaseCreateManyArgs} args - Arguments to create many PCCases.
     * @example
     * // Create many PCCases
     * const pCCase = await prisma.pCCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PCCaseCreateManyArgs>(args?: SelectSubset<T, PCCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PCCases and returns the data saved in the database.
     * @param {PCCaseCreateManyAndReturnArgs} args - Arguments to create many PCCases.
     * @example
     * // Create many PCCases
     * const pCCase = await prisma.pCCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PCCases and only return the `id`
     * const pCCaseWithIdOnly = await prisma.pCCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PCCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PCCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PCCase.
     * @param {PCCaseDeleteArgs} args - Arguments to delete one PCCase.
     * @example
     * // Delete one PCCase
     * const PCCase = await prisma.pCCase.delete({
     *   where: {
     *     // ... filter to delete one PCCase
     *   }
     * })
     * 
     */
    delete<T extends PCCaseDeleteArgs>(args: SelectSubset<T, PCCaseDeleteArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PCCase.
     * @param {PCCaseUpdateArgs} args - Arguments to update one PCCase.
     * @example
     * // Update one PCCase
     * const pCCase = await prisma.pCCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PCCaseUpdateArgs>(args: SelectSubset<T, PCCaseUpdateArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PCCases.
     * @param {PCCaseDeleteManyArgs} args - Arguments to filter PCCases to delete.
     * @example
     * // Delete a few PCCases
     * const { count } = await prisma.pCCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PCCaseDeleteManyArgs>(args?: SelectSubset<T, PCCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PCCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PCCases
     * const pCCase = await prisma.pCCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PCCaseUpdateManyArgs>(args: SelectSubset<T, PCCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PCCase.
     * @param {PCCaseUpsertArgs} args - Arguments to update or create a PCCase.
     * @example
     * // Update or create a PCCase
     * const pCCase = await prisma.pCCase.upsert({
     *   create: {
     *     // ... data to create a PCCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PCCase we want to update
     *   }
     * })
     */
    upsert<T extends PCCaseUpsertArgs>(args: SelectSubset<T, PCCaseUpsertArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PCCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseCountArgs} args - Arguments to filter PCCases to count.
     * @example
     * // Count the number of PCCases
     * const count = await prisma.pCCase.count({
     *   where: {
     *     // ... the filter for the PCCases we want to count
     *   }
     * })
    **/
    count<T extends PCCaseCountArgs>(
      args?: Subset<T, PCCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PCCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PCCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PCCaseAggregateArgs>(args: Subset<T, PCCaseAggregateArgs>): Prisma.PrismaPromise<GetPCCaseAggregateType<T>>

    /**
     * Group by PCCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PCCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PCCaseGroupByArgs['orderBy'] }
        : { orderBy?: PCCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PCCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPCCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PCCase model
   */
  readonly fields: PCCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PCCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PCCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configurations<T extends PCCase$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, PCCase$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    partial<T extends PCCase$partialArgs<ExtArgs> = {}>(args?: Subset<T, PCCase$partialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PCCase model
   */ 
  interface PCCaseFieldRefs {
    readonly id: FieldRef<"PCCase", 'String'>
    readonly formFactor: FieldRef<"PCCase", 'String'>
    readonly componentId: FieldRef<"PCCase", 'String'>
    readonly deletedAt: FieldRef<"PCCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PCCase findUnique
   */
  export type PCCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * Filter, which PCCase to fetch.
     */
    where: PCCaseWhereUniqueInput
  }

  /**
   * PCCase findUniqueOrThrow
   */
  export type PCCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * Filter, which PCCase to fetch.
     */
    where: PCCaseWhereUniqueInput
  }

  /**
   * PCCase findFirst
   */
  export type PCCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * Filter, which PCCase to fetch.
     */
    where?: PCCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCCases to fetch.
     */
    orderBy?: PCCaseOrderByWithRelationInput | PCCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PCCases.
     */
    cursor?: PCCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PCCases.
     */
    distinct?: PCCaseScalarFieldEnum | PCCaseScalarFieldEnum[]
  }

  /**
   * PCCase findFirstOrThrow
   */
  export type PCCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * Filter, which PCCase to fetch.
     */
    where?: PCCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCCases to fetch.
     */
    orderBy?: PCCaseOrderByWithRelationInput | PCCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PCCases.
     */
    cursor?: PCCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PCCases.
     */
    distinct?: PCCaseScalarFieldEnum | PCCaseScalarFieldEnum[]
  }

  /**
   * PCCase findMany
   */
  export type PCCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * Filter, which PCCases to fetch.
     */
    where?: PCCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCCases to fetch.
     */
    orderBy?: PCCaseOrderByWithRelationInput | PCCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PCCases.
     */
    cursor?: PCCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCCases.
     */
    skip?: number
    distinct?: PCCaseScalarFieldEnum | PCCaseScalarFieldEnum[]
  }

  /**
   * PCCase create
   */
  export type PCCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a PCCase.
     */
    data: XOR<PCCaseCreateInput, PCCaseUncheckedCreateInput>
  }

  /**
   * PCCase createMany
   */
  export type PCCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PCCases.
     */
    data: PCCaseCreateManyInput | PCCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PCCase createManyAndReturn
   */
  export type PCCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PCCases.
     */
    data: PCCaseCreateManyInput | PCCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PCCase update
   */
  export type PCCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a PCCase.
     */
    data: XOR<PCCaseUpdateInput, PCCaseUncheckedUpdateInput>
    /**
     * Choose, which PCCase to update.
     */
    where: PCCaseWhereUniqueInput
  }

  /**
   * PCCase updateMany
   */
  export type PCCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PCCases.
     */
    data: XOR<PCCaseUpdateManyMutationInput, PCCaseUncheckedUpdateManyInput>
    /**
     * Filter which PCCases to update
     */
    where?: PCCaseWhereInput
  }

  /**
   * PCCase upsert
   */
  export type PCCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the PCCase to update in case it exists.
     */
    where: PCCaseWhereUniqueInput
    /**
     * In case the PCCase found by the `where` argument doesn't exist, create a new PCCase with this data.
     */
    create: XOR<PCCaseCreateInput, PCCaseUncheckedCreateInput>
    /**
     * In case the PCCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PCCaseUpdateInput, PCCaseUncheckedUpdateInput>
  }

  /**
   * PCCase delete
   */
  export type PCCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    /**
     * Filter which PCCase to delete.
     */
    where: PCCaseWhereUniqueInput
  }

  /**
   * PCCase deleteMany
   */
  export type PCCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PCCases to delete
     */
    where?: PCCaseWhereInput
  }

  /**
   * PCCase.configurations
   */
  export type PCCase$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    cursor?: PCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * PCCase.partial
   */
  export type PCCase$partialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    cursor?: ParcialPCConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * PCCase without action
   */
  export type PCCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
  }


  /**
   * Model ParcialPCConfiguration
   */

  export type AggregateParcialPCConfiguration = {
    _count: ParcialPCConfigurationCountAggregateOutputType | null
    _min: ParcialPCConfigurationMinAggregateOutputType | null
    _max: ParcialPCConfigurationMaxAggregateOutputType | null
  }

  export type ParcialPCConfigurationMinAggregateOutputType = {
    id: string | null
    configurationType: $Enums.ConfigurationType | null
    motherboardId: string | null
    processorId: string | null
    gpuId: string | null
    powerSupplyId: string | null
    pcCaseId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ParcialPCConfigurationMaxAggregateOutputType = {
    id: string | null
    configurationType: $Enums.ConfigurationType | null
    motherboardId: string | null
    processorId: string | null
    gpuId: string | null
    powerSupplyId: string | null
    pcCaseId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ParcialPCConfigurationCountAggregateOutputType = {
    id: number
    configurationType: number
    motherboardId: number
    processorId: number
    gpuId: number
    powerSupplyId: number
    pcCaseId: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ParcialPCConfigurationMinAggregateInputType = {
    id?: true
    configurationType?: true
    motherboardId?: true
    processorId?: true
    gpuId?: true
    powerSupplyId?: true
    pcCaseId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ParcialPCConfigurationMaxAggregateInputType = {
    id?: true
    configurationType?: true
    motherboardId?: true
    processorId?: true
    gpuId?: true
    powerSupplyId?: true
    pcCaseId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ParcialPCConfigurationCountAggregateInputType = {
    id?: true
    configurationType?: true
    motherboardId?: true
    processorId?: true
    gpuId?: true
    powerSupplyId?: true
    pcCaseId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ParcialPCConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParcialPCConfiguration to aggregate.
     */
    where?: ParcialPCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParcialPCConfigurations to fetch.
     */
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParcialPCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParcialPCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParcialPCConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParcialPCConfigurations
    **/
    _count?: true | ParcialPCConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParcialPCConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParcialPCConfigurationMaxAggregateInputType
  }

  export type GetParcialPCConfigurationAggregateType<T extends ParcialPCConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateParcialPCConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcialPCConfiguration[P]>
      : GetScalarType<T[P], AggregateParcialPCConfiguration[P]>
  }




  export type ParcialPCConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcialPCConfigurationWhereInput
    orderBy?: ParcialPCConfigurationOrderByWithAggregationInput | ParcialPCConfigurationOrderByWithAggregationInput[]
    by: ParcialPCConfigurationScalarFieldEnum[] | ParcialPCConfigurationScalarFieldEnum
    having?: ParcialPCConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParcialPCConfigurationCountAggregateInputType | true
    _min?: ParcialPCConfigurationMinAggregateInputType
    _max?: ParcialPCConfigurationMaxAggregateInputType
  }

  export type ParcialPCConfigurationGroupByOutputType = {
    id: string
    configurationType: $Enums.ConfigurationType
    motherboardId: string | null
    processorId: string | null
    gpuId: string | null
    powerSupplyId: string | null
    pcCaseId: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ParcialPCConfigurationCountAggregateOutputType | null
    _min: ParcialPCConfigurationMinAggregateOutputType | null
    _max: ParcialPCConfigurationMaxAggregateOutputType | null
  }

  type GetParcialPCConfigurationGroupByPayload<T extends ParcialPCConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParcialPCConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParcialPCConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcialPCConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ParcialPCConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ParcialPCConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configurationType?: boolean
    motherboardId?: boolean
    processorId?: boolean
    gpuId?: boolean
    powerSupplyId?: boolean
    pcCaseId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    motherboard?: boolean | ParcialPCConfiguration$motherboardArgs<ExtArgs>
    processor?: boolean | ParcialPCConfiguration$processorArgs<ExtArgs>
    rams?: boolean | ParcialPCConfiguration$ramsArgs<ExtArgs>
    gpu?: boolean | ParcialPCConfiguration$gpuArgs<ExtArgs>
    storages?: boolean | ParcialPCConfiguration$storagesArgs<ExtArgs>
    powerSupply?: boolean | ParcialPCConfiguration$powerSupplyArgs<ExtArgs>
    pcCase?: boolean | ParcialPCConfiguration$pcCaseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ParcialPCConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parcialPCConfiguration"]>

  export type ParcialPCConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configurationType?: boolean
    motherboardId?: boolean
    processorId?: boolean
    gpuId?: boolean
    powerSupplyId?: boolean
    pcCaseId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    motherboard?: boolean | ParcialPCConfiguration$motherboardArgs<ExtArgs>
    processor?: boolean | ParcialPCConfiguration$processorArgs<ExtArgs>
    gpu?: boolean | ParcialPCConfiguration$gpuArgs<ExtArgs>
    powerSupply?: boolean | ParcialPCConfiguration$powerSupplyArgs<ExtArgs>
    pcCase?: boolean | ParcialPCConfiguration$pcCaseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parcialPCConfiguration"]>

  export type ParcialPCConfigurationSelectScalar = {
    id?: boolean
    configurationType?: boolean
    motherboardId?: boolean
    processorId?: boolean
    gpuId?: boolean
    powerSupplyId?: boolean
    pcCaseId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ParcialPCConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motherboard?: boolean | ParcialPCConfiguration$motherboardArgs<ExtArgs>
    processor?: boolean | ParcialPCConfiguration$processorArgs<ExtArgs>
    rams?: boolean | ParcialPCConfiguration$ramsArgs<ExtArgs>
    gpu?: boolean | ParcialPCConfiguration$gpuArgs<ExtArgs>
    storages?: boolean | ParcialPCConfiguration$storagesArgs<ExtArgs>
    powerSupply?: boolean | ParcialPCConfiguration$powerSupplyArgs<ExtArgs>
    pcCase?: boolean | ParcialPCConfiguration$pcCaseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ParcialPCConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParcialPCConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motherboard?: boolean | ParcialPCConfiguration$motherboardArgs<ExtArgs>
    processor?: boolean | ParcialPCConfiguration$processorArgs<ExtArgs>
    gpu?: boolean | ParcialPCConfiguration$gpuArgs<ExtArgs>
    powerSupply?: boolean | ParcialPCConfiguration$powerSupplyArgs<ExtArgs>
    pcCase?: boolean | ParcialPCConfiguration$pcCaseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ParcialPCConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParcialPCConfiguration"
    objects: {
      motherboard: Prisma.$MotherboardPayload<ExtArgs> | null
      processor: Prisma.$ProcessorPayload<ExtArgs> | null
      rams: Prisma.$RAMPayload<ExtArgs>[]
      gpu: Prisma.$GPUPayload<ExtArgs> | null
      storages: Prisma.$StoragePayload<ExtArgs>[]
      powerSupply: Prisma.$PowerSupplyPayload<ExtArgs> | null
      pcCase: Prisma.$PCCasePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      configurationType: $Enums.ConfigurationType
      motherboardId: string | null
      processorId: string | null
      gpuId: string | null
      powerSupplyId: string | null
      pcCaseId: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["parcialPCConfiguration"]>
    composites: {}
  }

  type ParcialPCConfigurationGetPayload<S extends boolean | null | undefined | ParcialPCConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ParcialPCConfigurationPayload, S>

  type ParcialPCConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParcialPCConfigurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParcialPCConfigurationCountAggregateInputType | true
    }

  export interface ParcialPCConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParcialPCConfiguration'], meta: { name: 'ParcialPCConfiguration' } }
    /**
     * Find zero or one ParcialPCConfiguration that matches the filter.
     * @param {ParcialPCConfigurationFindUniqueArgs} args - Arguments to find a ParcialPCConfiguration
     * @example
     * // Get one ParcialPCConfiguration
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParcialPCConfigurationFindUniqueArgs>(args: SelectSubset<T, ParcialPCConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParcialPCConfiguration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParcialPCConfigurationFindUniqueOrThrowArgs} args - Arguments to find a ParcialPCConfiguration
     * @example
     * // Get one ParcialPCConfiguration
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParcialPCConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ParcialPCConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParcialPCConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationFindFirstArgs} args - Arguments to find a ParcialPCConfiguration
     * @example
     * // Get one ParcialPCConfiguration
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParcialPCConfigurationFindFirstArgs>(args?: SelectSubset<T, ParcialPCConfigurationFindFirstArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParcialPCConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationFindFirstOrThrowArgs} args - Arguments to find a ParcialPCConfiguration
     * @example
     * // Get one ParcialPCConfiguration
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParcialPCConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ParcialPCConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParcialPCConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParcialPCConfigurations
     * const parcialPCConfigurations = await prisma.parcialPCConfiguration.findMany()
     * 
     * // Get first 10 ParcialPCConfigurations
     * const parcialPCConfigurations = await prisma.parcialPCConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parcialPCConfigurationWithIdOnly = await prisma.parcialPCConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParcialPCConfigurationFindManyArgs>(args?: SelectSubset<T, ParcialPCConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParcialPCConfiguration.
     * @param {ParcialPCConfigurationCreateArgs} args - Arguments to create a ParcialPCConfiguration.
     * @example
     * // Create one ParcialPCConfiguration
     * const ParcialPCConfiguration = await prisma.parcialPCConfiguration.create({
     *   data: {
     *     // ... data to create a ParcialPCConfiguration
     *   }
     * })
     * 
     */
    create<T extends ParcialPCConfigurationCreateArgs>(args: SelectSubset<T, ParcialPCConfigurationCreateArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParcialPCConfigurations.
     * @param {ParcialPCConfigurationCreateManyArgs} args - Arguments to create many ParcialPCConfigurations.
     * @example
     * // Create many ParcialPCConfigurations
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParcialPCConfigurationCreateManyArgs>(args?: SelectSubset<T, ParcialPCConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParcialPCConfigurations and returns the data saved in the database.
     * @param {ParcialPCConfigurationCreateManyAndReturnArgs} args - Arguments to create many ParcialPCConfigurations.
     * @example
     * // Create many ParcialPCConfigurations
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParcialPCConfigurations and only return the `id`
     * const parcialPCConfigurationWithIdOnly = await prisma.parcialPCConfiguration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParcialPCConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ParcialPCConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParcialPCConfiguration.
     * @param {ParcialPCConfigurationDeleteArgs} args - Arguments to delete one ParcialPCConfiguration.
     * @example
     * // Delete one ParcialPCConfiguration
     * const ParcialPCConfiguration = await prisma.parcialPCConfiguration.delete({
     *   where: {
     *     // ... filter to delete one ParcialPCConfiguration
     *   }
     * })
     * 
     */
    delete<T extends ParcialPCConfigurationDeleteArgs>(args: SelectSubset<T, ParcialPCConfigurationDeleteArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParcialPCConfiguration.
     * @param {ParcialPCConfigurationUpdateArgs} args - Arguments to update one ParcialPCConfiguration.
     * @example
     * // Update one ParcialPCConfiguration
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParcialPCConfigurationUpdateArgs>(args: SelectSubset<T, ParcialPCConfigurationUpdateArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParcialPCConfigurations.
     * @param {ParcialPCConfigurationDeleteManyArgs} args - Arguments to filter ParcialPCConfigurations to delete.
     * @example
     * // Delete a few ParcialPCConfigurations
     * const { count } = await prisma.parcialPCConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParcialPCConfigurationDeleteManyArgs>(args?: SelectSubset<T, ParcialPCConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParcialPCConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParcialPCConfigurations
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParcialPCConfigurationUpdateManyArgs>(args: SelectSubset<T, ParcialPCConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParcialPCConfiguration.
     * @param {ParcialPCConfigurationUpsertArgs} args - Arguments to update or create a ParcialPCConfiguration.
     * @example
     * // Update or create a ParcialPCConfiguration
     * const parcialPCConfiguration = await prisma.parcialPCConfiguration.upsert({
     *   create: {
     *     // ... data to create a ParcialPCConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParcialPCConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends ParcialPCConfigurationUpsertArgs>(args: SelectSubset<T, ParcialPCConfigurationUpsertArgs<ExtArgs>>): Prisma__ParcialPCConfigurationClient<$Result.GetResult<Prisma.$ParcialPCConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParcialPCConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationCountArgs} args - Arguments to filter ParcialPCConfigurations to count.
     * @example
     * // Count the number of ParcialPCConfigurations
     * const count = await prisma.parcialPCConfiguration.count({
     *   where: {
     *     // ... the filter for the ParcialPCConfigurations we want to count
     *   }
     * })
    **/
    count<T extends ParcialPCConfigurationCountArgs>(
      args?: Subset<T, ParcialPCConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcialPCConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParcialPCConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParcialPCConfigurationAggregateArgs>(args: Subset<T, ParcialPCConfigurationAggregateArgs>): Prisma.PrismaPromise<GetParcialPCConfigurationAggregateType<T>>

    /**
     * Group by ParcialPCConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcialPCConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParcialPCConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParcialPCConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ParcialPCConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParcialPCConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcialPCConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParcialPCConfiguration model
   */
  readonly fields: ParcialPCConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParcialPCConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParcialPCConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    motherboard<T extends ParcialPCConfiguration$motherboardArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$motherboardArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processor<T extends ParcialPCConfiguration$processorArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$processorArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rams<T extends ParcialPCConfiguration$ramsArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$ramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findMany"> | Null>
    gpu<T extends ParcialPCConfiguration$gpuArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$gpuArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    storages<T extends ParcialPCConfiguration$storagesArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$storagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findMany"> | Null>
    powerSupply<T extends ParcialPCConfiguration$powerSupplyArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$powerSupplyArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pcCase<T extends ParcialPCConfiguration$pcCaseArgs<ExtArgs> = {}>(args?: Subset<T, ParcialPCConfiguration$pcCaseArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParcialPCConfiguration model
   */ 
  interface ParcialPCConfigurationFieldRefs {
    readonly id: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly configurationType: FieldRef<"ParcialPCConfiguration", 'ConfigurationType'>
    readonly motherboardId: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly processorId: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly gpuId: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly powerSupplyId: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly pcCaseId: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly userId: FieldRef<"ParcialPCConfiguration", 'String'>
    readonly createdAt: FieldRef<"ParcialPCConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"ParcialPCConfiguration", 'DateTime'>
    readonly deletedAt: FieldRef<"ParcialPCConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParcialPCConfiguration findUnique
   */
  export type ParcialPCConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ParcialPCConfiguration to fetch.
     */
    where: ParcialPCConfigurationWhereUniqueInput
  }

  /**
   * ParcialPCConfiguration findUniqueOrThrow
   */
  export type ParcialPCConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ParcialPCConfiguration to fetch.
     */
    where: ParcialPCConfigurationWhereUniqueInput
  }

  /**
   * ParcialPCConfiguration findFirst
   */
  export type ParcialPCConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ParcialPCConfiguration to fetch.
     */
    where?: ParcialPCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParcialPCConfigurations to fetch.
     */
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParcialPCConfigurations.
     */
    cursor?: ParcialPCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParcialPCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParcialPCConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParcialPCConfigurations.
     */
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * ParcialPCConfiguration findFirstOrThrow
   */
  export type ParcialPCConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ParcialPCConfiguration to fetch.
     */
    where?: ParcialPCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParcialPCConfigurations to fetch.
     */
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParcialPCConfigurations.
     */
    cursor?: ParcialPCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParcialPCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParcialPCConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParcialPCConfigurations.
     */
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * ParcialPCConfiguration findMany
   */
  export type ParcialPCConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ParcialPCConfigurations to fetch.
     */
    where?: ParcialPCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParcialPCConfigurations to fetch.
     */
    orderBy?: ParcialPCConfigurationOrderByWithRelationInput | ParcialPCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParcialPCConfigurations.
     */
    cursor?: ParcialPCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParcialPCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParcialPCConfigurations.
     */
    skip?: number
    distinct?: ParcialPCConfigurationScalarFieldEnum | ParcialPCConfigurationScalarFieldEnum[]
  }

  /**
   * ParcialPCConfiguration create
   */
  export type ParcialPCConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a ParcialPCConfiguration.
     */
    data: XOR<ParcialPCConfigurationCreateInput, ParcialPCConfigurationUncheckedCreateInput>
  }

  /**
   * ParcialPCConfiguration createMany
   */
  export type ParcialPCConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParcialPCConfigurations.
     */
    data: ParcialPCConfigurationCreateManyInput | ParcialPCConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParcialPCConfiguration createManyAndReturn
   */
  export type ParcialPCConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParcialPCConfigurations.
     */
    data: ParcialPCConfigurationCreateManyInput | ParcialPCConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParcialPCConfiguration update
   */
  export type ParcialPCConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a ParcialPCConfiguration.
     */
    data: XOR<ParcialPCConfigurationUpdateInput, ParcialPCConfigurationUncheckedUpdateInput>
    /**
     * Choose, which ParcialPCConfiguration to update.
     */
    where: ParcialPCConfigurationWhereUniqueInput
  }

  /**
   * ParcialPCConfiguration updateMany
   */
  export type ParcialPCConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParcialPCConfigurations.
     */
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which ParcialPCConfigurations to update
     */
    where?: ParcialPCConfigurationWhereInput
  }

  /**
   * ParcialPCConfiguration upsert
   */
  export type ParcialPCConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the ParcialPCConfiguration to update in case it exists.
     */
    where: ParcialPCConfigurationWhereUniqueInput
    /**
     * In case the ParcialPCConfiguration found by the `where` argument doesn't exist, create a new ParcialPCConfiguration with this data.
     */
    create: XOR<ParcialPCConfigurationCreateInput, ParcialPCConfigurationUncheckedCreateInput>
    /**
     * In case the ParcialPCConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParcialPCConfigurationUpdateInput, ParcialPCConfigurationUncheckedUpdateInput>
  }

  /**
   * ParcialPCConfiguration delete
   */
  export type ParcialPCConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
    /**
     * Filter which ParcialPCConfiguration to delete.
     */
    where: ParcialPCConfigurationWhereUniqueInput
  }

  /**
   * ParcialPCConfiguration deleteMany
   */
  export type ParcialPCConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParcialPCConfigurations to delete
     */
    where?: ParcialPCConfigurationWhereInput
  }

  /**
   * ParcialPCConfiguration.motherboard
   */
  export type ParcialPCConfiguration$motherboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motherboard
     */
    select?: MotherboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherboardInclude<ExtArgs> | null
    where?: MotherboardWhereInput
  }

  /**
   * ParcialPCConfiguration.processor
   */
  export type ParcialPCConfiguration$processorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processor
     */
    select?: ProcessorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessorInclude<ExtArgs> | null
    where?: ProcessorWhereInput
  }

  /**
   * ParcialPCConfiguration.rams
   */
  export type ParcialPCConfiguration$ramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    where?: RAMWhereInput
    orderBy?: RAMOrderByWithRelationInput | RAMOrderByWithRelationInput[]
    cursor?: RAMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RAMScalarFieldEnum | RAMScalarFieldEnum[]
  }

  /**
   * ParcialPCConfiguration.gpu
   */
  export type ParcialPCConfiguration$gpuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPU
     */
    select?: GPUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPUInclude<ExtArgs> | null
    where?: GPUWhereInput
  }

  /**
   * ParcialPCConfiguration.storages
   */
  export type ParcialPCConfiguration$storagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    cursor?: StorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }

  /**
   * ParcialPCConfiguration.powerSupply
   */
  export type ParcialPCConfiguration$powerSupplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerSupply
     */
    select?: PowerSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerSupplyInclude<ExtArgs> | null
    where?: PowerSupplyWhereInput
  }

  /**
   * ParcialPCConfiguration.pcCase
   */
  export type ParcialPCConfiguration$pcCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCCase
     */
    select?: PCCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCCaseInclude<ExtArgs> | null
    where?: PCCaseWhereInput
  }

  /**
   * ParcialPCConfiguration without action
   */
  export type ParcialPCConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParcialPCConfiguration
     */
    select?: ParcialPCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcialPCConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model PCConfiguration
   */

  export type AggregatePCConfiguration = {
    _count: PCConfigurationCountAggregateOutputType | null
    _avg: PCConfigurationAvgAggregateOutputType | null
    _sum: PCConfigurationSumAggregateOutputType | null
    _min: PCConfigurationMinAggregateOutputType | null
    _max: PCConfigurationMaxAggregateOutputType | null
  }

  export type PCConfigurationAvgAggregateOutputType = {
    totalPrice: number | null
  }

  export type PCConfigurationSumAggregateOutputType = {
    totalPrice: number | null
  }

  export type PCConfigurationMinAggregateOutputType = {
    id: string | null
    totalPrice: number | null
    configurationType: $Enums.ConfigurationType | null
    motherboardId: string | null
    processorId: string | null
    gpuId: string | null
    powerSupplyId: string | null
    pcCaseId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PCConfigurationMaxAggregateOutputType = {
    id: string | null
    totalPrice: number | null
    configurationType: $Enums.ConfigurationType | null
    motherboardId: string | null
    processorId: string | null
    gpuId: string | null
    powerSupplyId: string | null
    pcCaseId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PCConfigurationCountAggregateOutputType = {
    id: number
    totalPrice: number
    configurationType: number
    motherboardId: number
    processorId: number
    gpuId: number
    powerSupplyId: number
    pcCaseId: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PCConfigurationAvgAggregateInputType = {
    totalPrice?: true
  }

  export type PCConfigurationSumAggregateInputType = {
    totalPrice?: true
  }

  export type PCConfigurationMinAggregateInputType = {
    id?: true
    totalPrice?: true
    configurationType?: true
    motherboardId?: true
    processorId?: true
    gpuId?: true
    powerSupplyId?: true
    pcCaseId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PCConfigurationMaxAggregateInputType = {
    id?: true
    totalPrice?: true
    configurationType?: true
    motherboardId?: true
    processorId?: true
    gpuId?: true
    powerSupplyId?: true
    pcCaseId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PCConfigurationCountAggregateInputType = {
    id?: true
    totalPrice?: true
    configurationType?: true
    motherboardId?: true
    processorId?: true
    gpuId?: true
    powerSupplyId?: true
    pcCaseId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PCConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PCConfiguration to aggregate.
     */
    where?: PCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCConfigurations to fetch.
     */
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PCConfigurations
    **/
    _count?: true | PCConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PCConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PCConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PCConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PCConfigurationMaxAggregateInputType
  }

  export type GetPCConfigurationAggregateType<T extends PCConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregatePCConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePCConfiguration[P]>
      : GetScalarType<T[P], AggregatePCConfiguration[P]>
  }




  export type PCConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PCConfigurationWhereInput
    orderBy?: PCConfigurationOrderByWithAggregationInput | PCConfigurationOrderByWithAggregationInput[]
    by: PCConfigurationScalarFieldEnum[] | PCConfigurationScalarFieldEnum
    having?: PCConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PCConfigurationCountAggregateInputType | true
    _avg?: PCConfigurationAvgAggregateInputType
    _sum?: PCConfigurationSumAggregateInputType
    _min?: PCConfigurationMinAggregateInputType
    _max?: PCConfigurationMaxAggregateInputType
  }

  export type PCConfigurationGroupByOutputType = {
    id: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PCConfigurationCountAggregateOutputType | null
    _avg: PCConfigurationAvgAggregateOutputType | null
    _sum: PCConfigurationSumAggregateOutputType | null
    _min: PCConfigurationMinAggregateOutputType | null
    _max: PCConfigurationMaxAggregateOutputType | null
  }

  type GetPCConfigurationGroupByPayload<T extends PCConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PCConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PCConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PCConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], PCConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type PCConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalPrice?: boolean
    configurationType?: boolean
    motherboardId?: boolean
    processorId?: boolean
    gpuId?: boolean
    powerSupplyId?: boolean
    pcCaseId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    motherboard?: boolean | MotherboardDefaultArgs<ExtArgs>
    processor?: boolean | ProcessorDefaultArgs<ExtArgs>
    rams?: boolean | PCConfiguration$ramsArgs<ExtArgs>
    gpu?: boolean | GPUDefaultArgs<ExtArgs>
    storages?: boolean | PCConfiguration$storagesArgs<ExtArgs>
    powerSupply?: boolean | PowerSupplyDefaultArgs<ExtArgs>
    pcCase?: boolean | PCCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PCConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pCConfiguration"]>

  export type PCConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalPrice?: boolean
    configurationType?: boolean
    motherboardId?: boolean
    processorId?: boolean
    gpuId?: boolean
    powerSupplyId?: boolean
    pcCaseId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    motherboard?: boolean | MotherboardDefaultArgs<ExtArgs>
    processor?: boolean | ProcessorDefaultArgs<ExtArgs>
    gpu?: boolean | GPUDefaultArgs<ExtArgs>
    powerSupply?: boolean | PowerSupplyDefaultArgs<ExtArgs>
    pcCase?: boolean | PCCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pCConfiguration"]>

  export type PCConfigurationSelectScalar = {
    id?: boolean
    totalPrice?: boolean
    configurationType?: boolean
    motherboardId?: boolean
    processorId?: boolean
    gpuId?: boolean
    powerSupplyId?: boolean
    pcCaseId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PCConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motherboard?: boolean | MotherboardDefaultArgs<ExtArgs>
    processor?: boolean | ProcessorDefaultArgs<ExtArgs>
    rams?: boolean | PCConfiguration$ramsArgs<ExtArgs>
    gpu?: boolean | GPUDefaultArgs<ExtArgs>
    storages?: boolean | PCConfiguration$storagesArgs<ExtArgs>
    powerSupply?: boolean | PowerSupplyDefaultArgs<ExtArgs>
    pcCase?: boolean | PCCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PCConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PCConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motherboard?: boolean | MotherboardDefaultArgs<ExtArgs>
    processor?: boolean | ProcessorDefaultArgs<ExtArgs>
    gpu?: boolean | GPUDefaultArgs<ExtArgs>
    powerSupply?: boolean | PowerSupplyDefaultArgs<ExtArgs>
    pcCase?: boolean | PCCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PCConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PCConfiguration"
    objects: {
      motherboard: Prisma.$MotherboardPayload<ExtArgs>
      processor: Prisma.$ProcessorPayload<ExtArgs>
      rams: Prisma.$RAMPayload<ExtArgs>[]
      gpu: Prisma.$GPUPayload<ExtArgs>
      storages: Prisma.$StoragePayload<ExtArgs>[]
      powerSupply: Prisma.$PowerSupplyPayload<ExtArgs>
      pcCase: Prisma.$PCCasePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      totalPrice: number
      configurationType: $Enums.ConfigurationType
      motherboardId: string
      processorId: string
      gpuId: string
      powerSupplyId: string
      pcCaseId: string
      userId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["pCConfiguration"]>
    composites: {}
  }

  type PCConfigurationGetPayload<S extends boolean | null | undefined | PCConfigurationDefaultArgs> = $Result.GetResult<Prisma.$PCConfigurationPayload, S>

  type PCConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PCConfigurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PCConfigurationCountAggregateInputType | true
    }

  export interface PCConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PCConfiguration'], meta: { name: 'PCConfiguration' } }
    /**
     * Find zero or one PCConfiguration that matches the filter.
     * @param {PCConfigurationFindUniqueArgs} args - Arguments to find a PCConfiguration
     * @example
     * // Get one PCConfiguration
     * const pCConfiguration = await prisma.pCConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PCConfigurationFindUniqueArgs>(args: SelectSubset<T, PCConfigurationFindUniqueArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PCConfiguration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PCConfigurationFindUniqueOrThrowArgs} args - Arguments to find a PCConfiguration
     * @example
     * // Get one PCConfiguration
     * const pCConfiguration = await prisma.pCConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PCConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, PCConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PCConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationFindFirstArgs} args - Arguments to find a PCConfiguration
     * @example
     * // Get one PCConfiguration
     * const pCConfiguration = await prisma.pCConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PCConfigurationFindFirstArgs>(args?: SelectSubset<T, PCConfigurationFindFirstArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PCConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationFindFirstOrThrowArgs} args - Arguments to find a PCConfiguration
     * @example
     * // Get one PCConfiguration
     * const pCConfiguration = await prisma.pCConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PCConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, PCConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PCConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PCConfigurations
     * const pCConfigurations = await prisma.pCConfiguration.findMany()
     * 
     * // Get first 10 PCConfigurations
     * const pCConfigurations = await prisma.pCConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pCConfigurationWithIdOnly = await prisma.pCConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PCConfigurationFindManyArgs>(args?: SelectSubset<T, PCConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PCConfiguration.
     * @param {PCConfigurationCreateArgs} args - Arguments to create a PCConfiguration.
     * @example
     * // Create one PCConfiguration
     * const PCConfiguration = await prisma.pCConfiguration.create({
     *   data: {
     *     // ... data to create a PCConfiguration
     *   }
     * })
     * 
     */
    create<T extends PCConfigurationCreateArgs>(args: SelectSubset<T, PCConfigurationCreateArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PCConfigurations.
     * @param {PCConfigurationCreateManyArgs} args - Arguments to create many PCConfigurations.
     * @example
     * // Create many PCConfigurations
     * const pCConfiguration = await prisma.pCConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PCConfigurationCreateManyArgs>(args?: SelectSubset<T, PCConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PCConfigurations and returns the data saved in the database.
     * @param {PCConfigurationCreateManyAndReturnArgs} args - Arguments to create many PCConfigurations.
     * @example
     * // Create many PCConfigurations
     * const pCConfiguration = await prisma.pCConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PCConfigurations and only return the `id`
     * const pCConfigurationWithIdOnly = await prisma.pCConfiguration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PCConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, PCConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PCConfiguration.
     * @param {PCConfigurationDeleteArgs} args - Arguments to delete one PCConfiguration.
     * @example
     * // Delete one PCConfiguration
     * const PCConfiguration = await prisma.pCConfiguration.delete({
     *   where: {
     *     // ... filter to delete one PCConfiguration
     *   }
     * })
     * 
     */
    delete<T extends PCConfigurationDeleteArgs>(args: SelectSubset<T, PCConfigurationDeleteArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PCConfiguration.
     * @param {PCConfigurationUpdateArgs} args - Arguments to update one PCConfiguration.
     * @example
     * // Update one PCConfiguration
     * const pCConfiguration = await prisma.pCConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PCConfigurationUpdateArgs>(args: SelectSubset<T, PCConfigurationUpdateArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PCConfigurations.
     * @param {PCConfigurationDeleteManyArgs} args - Arguments to filter PCConfigurations to delete.
     * @example
     * // Delete a few PCConfigurations
     * const { count } = await prisma.pCConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PCConfigurationDeleteManyArgs>(args?: SelectSubset<T, PCConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PCConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PCConfigurations
     * const pCConfiguration = await prisma.pCConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PCConfigurationUpdateManyArgs>(args: SelectSubset<T, PCConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PCConfiguration.
     * @param {PCConfigurationUpsertArgs} args - Arguments to update or create a PCConfiguration.
     * @example
     * // Update or create a PCConfiguration
     * const pCConfiguration = await prisma.pCConfiguration.upsert({
     *   create: {
     *     // ... data to create a PCConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PCConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends PCConfigurationUpsertArgs>(args: SelectSubset<T, PCConfigurationUpsertArgs<ExtArgs>>): Prisma__PCConfigurationClient<$Result.GetResult<Prisma.$PCConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PCConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationCountArgs} args - Arguments to filter PCConfigurations to count.
     * @example
     * // Count the number of PCConfigurations
     * const count = await prisma.pCConfiguration.count({
     *   where: {
     *     // ... the filter for the PCConfigurations we want to count
     *   }
     * })
    **/
    count<T extends PCConfigurationCountArgs>(
      args?: Subset<T, PCConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PCConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PCConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PCConfigurationAggregateArgs>(args: Subset<T, PCConfigurationAggregateArgs>): Prisma.PrismaPromise<GetPCConfigurationAggregateType<T>>

    /**
     * Group by PCConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PCConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PCConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PCConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: PCConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PCConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPCConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PCConfiguration model
   */
  readonly fields: PCConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PCConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PCConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    motherboard<T extends MotherboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MotherboardDefaultArgs<ExtArgs>>): Prisma__MotherboardClient<$Result.GetResult<Prisma.$MotherboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    processor<T extends ProcessorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessorDefaultArgs<ExtArgs>>): Prisma__ProcessorClient<$Result.GetResult<Prisma.$ProcessorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rams<T extends PCConfiguration$ramsArgs<ExtArgs> = {}>(args?: Subset<T, PCConfiguration$ramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RAMPayload<ExtArgs>, T, "findMany"> | Null>
    gpu<T extends GPUDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GPUDefaultArgs<ExtArgs>>): Prisma__GPUClient<$Result.GetResult<Prisma.$GPUPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    storages<T extends PCConfiguration$storagesArgs<ExtArgs> = {}>(args?: Subset<T, PCConfiguration$storagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, "findMany"> | Null>
    powerSupply<T extends PowerSupplyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PowerSupplyDefaultArgs<ExtArgs>>): Prisma__PowerSupplyClient<$Result.GetResult<Prisma.$PowerSupplyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pcCase<T extends PCCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PCCaseDefaultArgs<ExtArgs>>): Prisma__PCCaseClient<$Result.GetResult<Prisma.$PCCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PCConfiguration model
   */ 
  interface PCConfigurationFieldRefs {
    readonly id: FieldRef<"PCConfiguration", 'String'>
    readonly totalPrice: FieldRef<"PCConfiguration", 'Float'>
    readonly configurationType: FieldRef<"PCConfiguration", 'ConfigurationType'>
    readonly motherboardId: FieldRef<"PCConfiguration", 'String'>
    readonly processorId: FieldRef<"PCConfiguration", 'String'>
    readonly gpuId: FieldRef<"PCConfiguration", 'String'>
    readonly powerSupplyId: FieldRef<"PCConfiguration", 'String'>
    readonly pcCaseId: FieldRef<"PCConfiguration", 'String'>
    readonly userId: FieldRef<"PCConfiguration", 'String'>
    readonly createdAt: FieldRef<"PCConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"PCConfiguration", 'DateTime'>
    readonly deletedAt: FieldRef<"PCConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PCConfiguration findUnique
   */
  export type PCConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which PCConfiguration to fetch.
     */
    where: PCConfigurationWhereUniqueInput
  }

  /**
   * PCConfiguration findUniqueOrThrow
   */
  export type PCConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which PCConfiguration to fetch.
     */
    where: PCConfigurationWhereUniqueInput
  }

  /**
   * PCConfiguration findFirst
   */
  export type PCConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which PCConfiguration to fetch.
     */
    where?: PCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCConfigurations to fetch.
     */
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PCConfigurations.
     */
    cursor?: PCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PCConfigurations.
     */
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * PCConfiguration findFirstOrThrow
   */
  export type PCConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which PCConfiguration to fetch.
     */
    where?: PCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCConfigurations to fetch.
     */
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PCConfigurations.
     */
    cursor?: PCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PCConfigurations.
     */
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * PCConfiguration findMany
   */
  export type PCConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which PCConfigurations to fetch.
     */
    where?: PCConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PCConfigurations to fetch.
     */
    orderBy?: PCConfigurationOrderByWithRelationInput | PCConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PCConfigurations.
     */
    cursor?: PCConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PCConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PCConfigurations.
     */
    skip?: number
    distinct?: PCConfigurationScalarFieldEnum | PCConfigurationScalarFieldEnum[]
  }

  /**
   * PCConfiguration create
   */
  export type PCConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a PCConfiguration.
     */
    data: XOR<PCConfigurationCreateInput, PCConfigurationUncheckedCreateInput>
  }

  /**
   * PCConfiguration createMany
   */
  export type PCConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PCConfigurations.
     */
    data: PCConfigurationCreateManyInput | PCConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PCConfiguration createManyAndReturn
   */
  export type PCConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PCConfigurations.
     */
    data: PCConfigurationCreateManyInput | PCConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PCConfiguration update
   */
  export type PCConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a PCConfiguration.
     */
    data: XOR<PCConfigurationUpdateInput, PCConfigurationUncheckedUpdateInput>
    /**
     * Choose, which PCConfiguration to update.
     */
    where: PCConfigurationWhereUniqueInput
  }

  /**
   * PCConfiguration updateMany
   */
  export type PCConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PCConfigurations.
     */
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which PCConfigurations to update
     */
    where?: PCConfigurationWhereInput
  }

  /**
   * PCConfiguration upsert
   */
  export type PCConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the PCConfiguration to update in case it exists.
     */
    where: PCConfigurationWhereUniqueInput
    /**
     * In case the PCConfiguration found by the `where` argument doesn't exist, create a new PCConfiguration with this data.
     */
    create: XOR<PCConfigurationCreateInput, PCConfigurationUncheckedCreateInput>
    /**
     * In case the PCConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PCConfigurationUpdateInput, PCConfigurationUncheckedUpdateInput>
  }

  /**
   * PCConfiguration delete
   */
  export type PCConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
    /**
     * Filter which PCConfiguration to delete.
     */
    where: PCConfigurationWhereUniqueInput
  }

  /**
   * PCConfiguration deleteMany
   */
  export type PCConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PCConfigurations to delete
     */
    where?: PCConfigurationWhereInput
  }

  /**
   * PCConfiguration.rams
   */
  export type PCConfiguration$ramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAM
     */
    select?: RAMSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAMInclude<ExtArgs> | null
    where?: RAMWhereInput
    orderBy?: RAMOrderByWithRelationInput | RAMOrderByWithRelationInput[]
    cursor?: RAMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RAMScalarFieldEnum | RAMScalarFieldEnum[]
  }

  /**
   * PCConfiguration.storages
   */
  export type PCConfiguration$storagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    cursor?: StorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }

  /**
   * PCConfiguration without action
   */
  export type PCConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PCConfiguration
     */
    select?: PCConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PCConfigurationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    userId: 'userId',
    userType: 'userType'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    componentType: 'componentType',
    price: 'price',
    manufacturer: 'manufacturer',
    imageUrl: 'imageUrl',
    deletedAt: 'deletedAt'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    userType: 'userType'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MotherboardScalarFieldEnum: {
    id: 'id',
    socket: 'socket',
    formFactor: 'formFactor',
    ramSlots: 'ramSlots',
    ramType: 'ramType',
    gpuInterface: 'gpuInterface',
    stroageBusType: 'stroageBusType',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type MotherboardScalarFieldEnum = (typeof MotherboardScalarFieldEnum)[keyof typeof MotherboardScalarFieldEnum]


  export const ProcessorScalarFieldEnum: {
    id: 'id',
    architecture: 'architecture',
    cores: 'cores',
    threads: 'threads',
    bits: 'bits',
    socket: 'socket',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type ProcessorScalarFieldEnum = (typeof ProcessorScalarFieldEnum)[keyof typeof ProcessorScalarFieldEnum]


  export const GPUScalarFieldEnum: {
    id: 'id',
    memory: 'memory',
    powerConnector: 'powerConnector',
    interface: 'interface',
    power: 'power',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type GPUScalarFieldEnum = (typeof GPUScalarFieldEnum)[keyof typeof GPUScalarFieldEnum]


  export const RAMScalarFieldEnum: {
    id: 'id',
    memoryType: 'memoryType',
    capacity: 'capacity',
    computerType: 'computerType',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type RAMScalarFieldEnum = (typeof RAMScalarFieldEnum)[keyof typeof RAMScalarFieldEnum]


  export const StorageScalarFieldEnum: {
    id: 'id',
    storageType: 'storageType',
    capacity: 'capacity',
    busType: 'busType',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type StorageScalarFieldEnum = (typeof StorageScalarFieldEnum)[keyof typeof StorageScalarFieldEnum]


  export const PowerSupplyScalarFieldEnum: {
    id: 'id',
    powerOutput: 'powerOutput',
    efficiency: 'efficiency',
    formFactor: 'formFactor',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type PowerSupplyScalarFieldEnum = (typeof PowerSupplyScalarFieldEnum)[keyof typeof PowerSupplyScalarFieldEnum]


  export const PCCaseScalarFieldEnum: {
    id: 'id',
    formFactor: 'formFactor',
    componentId: 'componentId',
    deletedAt: 'deletedAt'
  };

  export type PCCaseScalarFieldEnum = (typeof PCCaseScalarFieldEnum)[keyof typeof PCCaseScalarFieldEnum]


  export const ParcialPCConfigurationScalarFieldEnum: {
    id: 'id',
    configurationType: 'configurationType',
    motherboardId: 'motherboardId',
    processorId: 'processorId',
    gpuId: 'gpuId',
    powerSupplyId: 'powerSupplyId',
    pcCaseId: 'pcCaseId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ParcialPCConfigurationScalarFieldEnum = (typeof ParcialPCConfigurationScalarFieldEnum)[keyof typeof ParcialPCConfigurationScalarFieldEnum]


  export const PCConfigurationScalarFieldEnum: {
    id: 'id',
    totalPrice: 'totalPrice',
    configurationType: 'configurationType',
    motherboardId: 'motherboardId',
    processorId: 'processorId',
    gpuId: 'gpuId',
    powerSupplyId: 'powerSupplyId',
    pcCaseId: 'pcCaseId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PCConfigurationScalarFieldEnum = (typeof PCConfigurationScalarFieldEnum)[keyof typeof PCConfigurationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'ComponentType'
   */
  export type EnumComponentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComponentType'>
    


  /**
   * Reference to a field of type 'ComponentType[]'
   */
  export type ListEnumComponentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComponentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ComputerType'
   */
  export type EnumComputerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComputerType'>
    


  /**
   * Reference to a field of type 'ComputerType[]'
   */
  export type ListEnumComputerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComputerType[]'>
    


  /**
   * Reference to a field of type 'ConfigurationType'
   */
  export type EnumConfigurationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfigurationType'>
    


  /**
   * Reference to a field of type 'ConfigurationType[]'
   */
  export type ListEnumConfigurationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfigurationType[]'>
    
  /**
   * Deep Input Types
   */


  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userId?: StringFilter<"Session"> | string
    userType?: EnumUserTypeFilter<"Session"> | $Enums.UserType
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userId?: StringFilter<"Session"> | string
    userType?: EnumUserTypeFilter<"Session"> | $Enums.UserType
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"Session"> | $Enums.UserType
  }

  export type ComponentWhereInput = {
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    id?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    componentType?: EnumComponentTypeFilter<"Component"> | $Enums.ComponentType
    price?: FloatFilter<"Component"> | number
    manufacturer?: StringFilter<"Component"> | string
    imageUrl?: StringFilter<"Component"> | string
    deletedAt?: DateTimeNullableFilter<"Component"> | Date | string | null
    motherboard?: XOR<MotherboardNullableRelationFilter, MotherboardWhereInput> | null
    processor?: XOR<ProcessorNullableRelationFilter, ProcessorWhereInput> | null
    gpu?: XOR<GPUNullableRelationFilter, GPUWhereInput> | null
    ram?: XOR<RAMNullableRelationFilter, RAMWhereInput> | null
    storage?: XOR<StorageNullableRelationFilter, StorageWhereInput> | null
    powerSupply?: XOR<PowerSupplyNullableRelationFilter, PowerSupplyWhereInput> | null
    pcCase?: XOR<PCCaseNullableRelationFilter, PCCaseWhereInput> | null
  }

  export type ComponentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    componentType?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    imageUrl?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    motherboard?: MotherboardOrderByWithRelationInput
    processor?: ProcessorOrderByWithRelationInput
    gpu?: GPUOrderByWithRelationInput
    ram?: RAMOrderByWithRelationInput
    storage?: StorageOrderByWithRelationInput
    powerSupply?: PowerSupplyOrderByWithRelationInput
    pcCase?: PCCaseOrderByWithRelationInput
  }

  export type ComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    name?: StringFilter<"Component"> | string
    componentType?: EnumComponentTypeFilter<"Component"> | $Enums.ComponentType
    price?: FloatFilter<"Component"> | number
    manufacturer?: StringFilter<"Component"> | string
    imageUrl?: StringFilter<"Component"> | string
    deletedAt?: DateTimeNullableFilter<"Component"> | Date | string | null
    motherboard?: XOR<MotherboardNullableRelationFilter, MotherboardWhereInput> | null
    processor?: XOR<ProcessorNullableRelationFilter, ProcessorWhereInput> | null
    gpu?: XOR<GPUNullableRelationFilter, GPUWhereInput> | null
    ram?: XOR<RAMNullableRelationFilter, RAMWhereInput> | null
    storage?: XOR<StorageNullableRelationFilter, StorageWhereInput> | null
    powerSupply?: XOR<PowerSupplyNullableRelationFilter, PowerSupplyWhereInput> | null
    pcCase?: XOR<PCCaseNullableRelationFilter, PCCaseWhereInput> | null
  }, "id">

  export type ComponentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    componentType?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    imageUrl?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ComponentCountOrderByAggregateInput
    _avg?: ComponentAvgOrderByAggregateInput
    _max?: ComponentMaxOrderByAggregateInput
    _min?: ComponentMinOrderByAggregateInput
    _sum?: ComponentSumOrderByAggregateInput
  }

  export type ComponentScalarWhereWithAggregatesInput = {
    AND?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    OR?: ComponentScalarWhereWithAggregatesInput[]
    NOT?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Component"> | string
    name?: StringWithAggregatesFilter<"Component"> | string
    componentType?: EnumComponentTypeWithAggregatesFilter<"Component"> | $Enums.ComponentType
    price?: FloatWithAggregatesFilter<"Component"> | number
    manufacturer?: StringWithAggregatesFilter<"Component"> | string
    imageUrl?: StringWithAggregatesFilter<"Component"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Component"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    userconfigurations?: PCConfigurationListRelationFilter
    partialUserConfiguration?: XOR<ParcialPCConfigurationNullableRelationFilter, ParcialPCConfigurationWhereInput> | null
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    userconfigurations?: PCConfigurationOrderByRelationAggregateInput
    partialUserConfiguration?: ParcialPCConfigurationOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    userconfigurations?: PCConfigurationListRelationFilter
    partialUserConfiguration?: XOR<ParcialPCConfigurationNullableRelationFilter, ParcialPCConfigurationWhereInput> | null
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
  }

  export type MotherboardWhereInput = {
    AND?: MotherboardWhereInput | MotherboardWhereInput[]
    OR?: MotherboardWhereInput[]
    NOT?: MotherboardWhereInput | MotherboardWhereInput[]
    id?: StringFilter<"Motherboard"> | string
    socket?: StringFilter<"Motherboard"> | string
    formFactor?: StringFilter<"Motherboard"> | string
    ramSlots?: IntFilter<"Motherboard"> | number
    ramType?: StringFilter<"Motherboard"> | string
    gpuInterface?: StringFilter<"Motherboard"> | string
    stroageBusType?: StringFilter<"Motherboard"> | string
    componentId?: StringFilter<"Motherboard"> | string
    deletedAt?: DateTimeNullableFilter<"Motherboard"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type MotherboardOrderByWithRelationInput = {
    id?: SortOrder
    socket?: SortOrder
    formFactor?: SortOrder
    ramSlots?: SortOrder
    ramType?: SortOrder
    gpuInterface?: SortOrder
    stroageBusType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type MotherboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: MotherboardWhereInput | MotherboardWhereInput[]
    OR?: MotherboardWhereInput[]
    NOT?: MotherboardWhereInput | MotherboardWhereInput[]
    socket?: StringFilter<"Motherboard"> | string
    formFactor?: StringFilter<"Motherboard"> | string
    ramSlots?: IntFilter<"Motherboard"> | number
    ramType?: StringFilter<"Motherboard"> | string
    gpuInterface?: StringFilter<"Motherboard"> | string
    stroageBusType?: StringFilter<"Motherboard"> | string
    deletedAt?: DateTimeNullableFilter<"Motherboard"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type MotherboardOrderByWithAggregationInput = {
    id?: SortOrder
    socket?: SortOrder
    formFactor?: SortOrder
    ramSlots?: SortOrder
    ramType?: SortOrder
    gpuInterface?: SortOrder
    stroageBusType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MotherboardCountOrderByAggregateInput
    _avg?: MotherboardAvgOrderByAggregateInput
    _max?: MotherboardMaxOrderByAggregateInput
    _min?: MotherboardMinOrderByAggregateInput
    _sum?: MotherboardSumOrderByAggregateInput
  }

  export type MotherboardScalarWhereWithAggregatesInput = {
    AND?: MotherboardScalarWhereWithAggregatesInput | MotherboardScalarWhereWithAggregatesInput[]
    OR?: MotherboardScalarWhereWithAggregatesInput[]
    NOT?: MotherboardScalarWhereWithAggregatesInput | MotherboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Motherboard"> | string
    socket?: StringWithAggregatesFilter<"Motherboard"> | string
    formFactor?: StringWithAggregatesFilter<"Motherboard"> | string
    ramSlots?: IntWithAggregatesFilter<"Motherboard"> | number
    ramType?: StringWithAggregatesFilter<"Motherboard"> | string
    gpuInterface?: StringWithAggregatesFilter<"Motherboard"> | string
    stroageBusType?: StringWithAggregatesFilter<"Motherboard"> | string
    componentId?: StringWithAggregatesFilter<"Motherboard"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Motherboard"> | Date | string | null
  }

  export type ProcessorWhereInput = {
    AND?: ProcessorWhereInput | ProcessorWhereInput[]
    OR?: ProcessorWhereInput[]
    NOT?: ProcessorWhereInput | ProcessorWhereInput[]
    id?: StringFilter<"Processor"> | string
    architecture?: StringFilter<"Processor"> | string
    cores?: IntFilter<"Processor"> | number
    threads?: IntFilter<"Processor"> | number
    bits?: IntFilter<"Processor"> | number
    socket?: StringFilter<"Processor"> | string
    componentId?: StringFilter<"Processor"> | string
    deletedAt?: DateTimeNullableFilter<"Processor"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type ProcessorOrderByWithRelationInput = {
    id?: SortOrder
    architecture?: SortOrder
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
    socket?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type ProcessorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: ProcessorWhereInput | ProcessorWhereInput[]
    OR?: ProcessorWhereInput[]
    NOT?: ProcessorWhereInput | ProcessorWhereInput[]
    architecture?: StringFilter<"Processor"> | string
    cores?: IntFilter<"Processor"> | number
    threads?: IntFilter<"Processor"> | number
    bits?: IntFilter<"Processor"> | number
    socket?: StringFilter<"Processor"> | string
    deletedAt?: DateTimeNullableFilter<"Processor"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type ProcessorOrderByWithAggregationInput = {
    id?: SortOrder
    architecture?: SortOrder
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
    socket?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProcessorCountOrderByAggregateInput
    _avg?: ProcessorAvgOrderByAggregateInput
    _max?: ProcessorMaxOrderByAggregateInput
    _min?: ProcessorMinOrderByAggregateInput
    _sum?: ProcessorSumOrderByAggregateInput
  }

  export type ProcessorScalarWhereWithAggregatesInput = {
    AND?: ProcessorScalarWhereWithAggregatesInput | ProcessorScalarWhereWithAggregatesInput[]
    OR?: ProcessorScalarWhereWithAggregatesInput[]
    NOT?: ProcessorScalarWhereWithAggregatesInput | ProcessorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Processor"> | string
    architecture?: StringWithAggregatesFilter<"Processor"> | string
    cores?: IntWithAggregatesFilter<"Processor"> | number
    threads?: IntWithAggregatesFilter<"Processor"> | number
    bits?: IntWithAggregatesFilter<"Processor"> | number
    socket?: StringWithAggregatesFilter<"Processor"> | string
    componentId?: StringWithAggregatesFilter<"Processor"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Processor"> | Date | string | null
  }

  export type GPUWhereInput = {
    AND?: GPUWhereInput | GPUWhereInput[]
    OR?: GPUWhereInput[]
    NOT?: GPUWhereInput | GPUWhereInput[]
    id?: StringFilter<"GPU"> | string
    memory?: IntFilter<"GPU"> | number
    powerConnector?: StringFilter<"GPU"> | string
    interface?: StringFilter<"GPU"> | string
    power?: IntFilter<"GPU"> | number
    componentId?: StringFilter<"GPU"> | string
    deletedAt?: DateTimeNullableFilter<"GPU"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type GPUOrderByWithRelationInput = {
    id?: SortOrder
    memory?: SortOrder
    powerConnector?: SortOrder
    interface?: SortOrder
    power?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type GPUWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: GPUWhereInput | GPUWhereInput[]
    OR?: GPUWhereInput[]
    NOT?: GPUWhereInput | GPUWhereInput[]
    memory?: IntFilter<"GPU"> | number
    powerConnector?: StringFilter<"GPU"> | string
    interface?: StringFilter<"GPU"> | string
    power?: IntFilter<"GPU"> | number
    deletedAt?: DateTimeNullableFilter<"GPU"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type GPUOrderByWithAggregationInput = {
    id?: SortOrder
    memory?: SortOrder
    powerConnector?: SortOrder
    interface?: SortOrder
    power?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GPUCountOrderByAggregateInput
    _avg?: GPUAvgOrderByAggregateInput
    _max?: GPUMaxOrderByAggregateInput
    _min?: GPUMinOrderByAggregateInput
    _sum?: GPUSumOrderByAggregateInput
  }

  export type GPUScalarWhereWithAggregatesInput = {
    AND?: GPUScalarWhereWithAggregatesInput | GPUScalarWhereWithAggregatesInput[]
    OR?: GPUScalarWhereWithAggregatesInput[]
    NOT?: GPUScalarWhereWithAggregatesInput | GPUScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GPU"> | string
    memory?: IntWithAggregatesFilter<"GPU"> | number
    powerConnector?: StringWithAggregatesFilter<"GPU"> | string
    interface?: StringWithAggregatesFilter<"GPU"> | string
    power?: IntWithAggregatesFilter<"GPU"> | number
    componentId?: StringWithAggregatesFilter<"GPU"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"GPU"> | Date | string | null
  }

  export type RAMWhereInput = {
    AND?: RAMWhereInput | RAMWhereInput[]
    OR?: RAMWhereInput[]
    NOT?: RAMWhereInput | RAMWhereInput[]
    id?: StringFilter<"RAM"> | string
    memoryType?: StringFilter<"RAM"> | string
    capacity?: IntFilter<"RAM"> | number
    computerType?: EnumComputerTypeFilter<"RAM"> | $Enums.ComputerType
    componentId?: StringFilter<"RAM"> | string
    deletedAt?: DateTimeNullableFilter<"RAM"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type RAMOrderByWithRelationInput = {
    id?: SortOrder
    memoryType?: SortOrder
    capacity?: SortOrder
    computerType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type RAMWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: RAMWhereInput | RAMWhereInput[]
    OR?: RAMWhereInput[]
    NOT?: RAMWhereInput | RAMWhereInput[]
    memoryType?: StringFilter<"RAM"> | string
    capacity?: IntFilter<"RAM"> | number
    computerType?: EnumComputerTypeFilter<"RAM"> | $Enums.ComputerType
    deletedAt?: DateTimeNullableFilter<"RAM"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type RAMOrderByWithAggregationInput = {
    id?: SortOrder
    memoryType?: SortOrder
    capacity?: SortOrder
    computerType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RAMCountOrderByAggregateInput
    _avg?: RAMAvgOrderByAggregateInput
    _max?: RAMMaxOrderByAggregateInput
    _min?: RAMMinOrderByAggregateInput
    _sum?: RAMSumOrderByAggregateInput
  }

  export type RAMScalarWhereWithAggregatesInput = {
    AND?: RAMScalarWhereWithAggregatesInput | RAMScalarWhereWithAggregatesInput[]
    OR?: RAMScalarWhereWithAggregatesInput[]
    NOT?: RAMScalarWhereWithAggregatesInput | RAMScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RAM"> | string
    memoryType?: StringWithAggregatesFilter<"RAM"> | string
    capacity?: IntWithAggregatesFilter<"RAM"> | number
    computerType?: EnumComputerTypeWithAggregatesFilter<"RAM"> | $Enums.ComputerType
    componentId?: StringWithAggregatesFilter<"RAM"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RAM"> | Date | string | null
  }

  export type StorageWhereInput = {
    AND?: StorageWhereInput | StorageWhereInput[]
    OR?: StorageWhereInput[]
    NOT?: StorageWhereInput | StorageWhereInput[]
    id?: StringFilter<"Storage"> | string
    storageType?: StringFilter<"Storage"> | string
    capacity?: IntFilter<"Storage"> | number
    busType?: StringFilter<"Storage"> | string
    componentId?: StringFilter<"Storage"> | string
    deletedAt?: DateTimeNullableFilter<"Storage"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type StorageOrderByWithRelationInput = {
    id?: SortOrder
    storageType?: SortOrder
    capacity?: SortOrder
    busType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type StorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: StorageWhereInput | StorageWhereInput[]
    OR?: StorageWhereInput[]
    NOT?: StorageWhereInput | StorageWhereInput[]
    storageType?: StringFilter<"Storage"> | string
    capacity?: IntFilter<"Storage"> | number
    busType?: StringFilter<"Storage"> | string
    deletedAt?: DateTimeNullableFilter<"Storage"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type StorageOrderByWithAggregationInput = {
    id?: SortOrder
    storageType?: SortOrder
    capacity?: SortOrder
    busType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: StorageCountOrderByAggregateInput
    _avg?: StorageAvgOrderByAggregateInput
    _max?: StorageMaxOrderByAggregateInput
    _min?: StorageMinOrderByAggregateInput
    _sum?: StorageSumOrderByAggregateInput
  }

  export type StorageScalarWhereWithAggregatesInput = {
    AND?: StorageScalarWhereWithAggregatesInput | StorageScalarWhereWithAggregatesInput[]
    OR?: StorageScalarWhereWithAggregatesInput[]
    NOT?: StorageScalarWhereWithAggregatesInput | StorageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Storage"> | string
    storageType?: StringWithAggregatesFilter<"Storage"> | string
    capacity?: IntWithAggregatesFilter<"Storage"> | number
    busType?: StringWithAggregatesFilter<"Storage"> | string
    componentId?: StringWithAggregatesFilter<"Storage"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Storage"> | Date | string | null
  }

  export type PowerSupplyWhereInput = {
    AND?: PowerSupplyWhereInput | PowerSupplyWhereInput[]
    OR?: PowerSupplyWhereInput[]
    NOT?: PowerSupplyWhereInput | PowerSupplyWhereInput[]
    id?: StringFilter<"PowerSupply"> | string
    powerOutput?: IntFilter<"PowerSupply"> | number
    efficiency?: StringFilter<"PowerSupply"> | string
    formFactor?: StringFilter<"PowerSupply"> | string
    componentId?: StringFilter<"PowerSupply"> | string
    deletedAt?: DateTimeNullableFilter<"PowerSupply"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type PowerSupplyOrderByWithRelationInput = {
    id?: SortOrder
    powerOutput?: SortOrder
    efficiency?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type PowerSupplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: PowerSupplyWhereInput | PowerSupplyWhereInput[]
    OR?: PowerSupplyWhereInput[]
    NOT?: PowerSupplyWhereInput | PowerSupplyWhereInput[]
    powerOutput?: IntFilter<"PowerSupply"> | number
    efficiency?: StringFilter<"PowerSupply"> | string
    formFactor?: StringFilter<"PowerSupply"> | string
    deletedAt?: DateTimeNullableFilter<"PowerSupply"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type PowerSupplyOrderByWithAggregationInput = {
    id?: SortOrder
    powerOutput?: SortOrder
    efficiency?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PowerSupplyCountOrderByAggregateInput
    _avg?: PowerSupplyAvgOrderByAggregateInput
    _max?: PowerSupplyMaxOrderByAggregateInput
    _min?: PowerSupplyMinOrderByAggregateInput
    _sum?: PowerSupplySumOrderByAggregateInput
  }

  export type PowerSupplyScalarWhereWithAggregatesInput = {
    AND?: PowerSupplyScalarWhereWithAggregatesInput | PowerSupplyScalarWhereWithAggregatesInput[]
    OR?: PowerSupplyScalarWhereWithAggregatesInput[]
    NOT?: PowerSupplyScalarWhereWithAggregatesInput | PowerSupplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PowerSupply"> | string
    powerOutput?: IntWithAggregatesFilter<"PowerSupply"> | number
    efficiency?: StringWithAggregatesFilter<"PowerSupply"> | string
    formFactor?: StringWithAggregatesFilter<"PowerSupply"> | string
    componentId?: StringWithAggregatesFilter<"PowerSupply"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PowerSupply"> | Date | string | null
  }

  export type PCCaseWhereInput = {
    AND?: PCCaseWhereInput | PCCaseWhereInput[]
    OR?: PCCaseWhereInput[]
    NOT?: PCCaseWhereInput | PCCaseWhereInput[]
    id?: StringFilter<"PCCase"> | string
    formFactor?: StringFilter<"PCCase"> | string
    componentId?: StringFilter<"PCCase"> | string
    deletedAt?: DateTimeNullableFilter<"PCCase"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }

  export type PCCaseOrderByWithRelationInput = {
    id?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    configurations?: PCConfigurationOrderByRelationAggregateInput
    partial?: ParcialPCConfigurationOrderByRelationAggregateInput
  }

  export type PCCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    componentId?: string
    AND?: PCCaseWhereInput | PCCaseWhereInput[]
    OR?: PCCaseWhereInput[]
    NOT?: PCCaseWhereInput | PCCaseWhereInput[]
    formFactor?: StringFilter<"PCCase"> | string
    deletedAt?: DateTimeNullableFilter<"PCCase"> | Date | string | null
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
    configurations?: PCConfigurationListRelationFilter
    partial?: ParcialPCConfigurationListRelationFilter
  }, "id" | "componentId">

  export type PCCaseOrderByWithAggregationInput = {
    id?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PCCaseCountOrderByAggregateInput
    _max?: PCCaseMaxOrderByAggregateInput
    _min?: PCCaseMinOrderByAggregateInput
  }

  export type PCCaseScalarWhereWithAggregatesInput = {
    AND?: PCCaseScalarWhereWithAggregatesInput | PCCaseScalarWhereWithAggregatesInput[]
    OR?: PCCaseScalarWhereWithAggregatesInput[]
    NOT?: PCCaseScalarWhereWithAggregatesInput | PCCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PCCase"> | string
    formFactor?: StringWithAggregatesFilter<"PCCase"> | string
    componentId?: StringWithAggregatesFilter<"PCCase"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PCCase"> | Date | string | null
  }

  export type ParcialPCConfigurationWhereInput = {
    AND?: ParcialPCConfigurationWhereInput | ParcialPCConfigurationWhereInput[]
    OR?: ParcialPCConfigurationWhereInput[]
    NOT?: ParcialPCConfigurationWhereInput | ParcialPCConfigurationWhereInput[]
    id?: StringFilter<"ParcialPCConfiguration"> | string
    configurationType?: EnumConfigurationTypeFilter<"ParcialPCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    processorId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    gpuId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    powerSupplyId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    pcCaseId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    userId?: StringFilter<"ParcialPCConfiguration"> | string
    createdAt?: DateTimeFilter<"ParcialPCConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ParcialPCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ParcialPCConfiguration"> | Date | string | null
    motherboard?: XOR<MotherboardNullableRelationFilter, MotherboardWhereInput> | null
    processor?: XOR<ProcessorNullableRelationFilter, ProcessorWhereInput> | null
    rams?: RAMListRelationFilter
    gpu?: XOR<GPUNullableRelationFilter, GPUWhereInput> | null
    storages?: StorageListRelationFilter
    powerSupply?: XOR<PowerSupplyNullableRelationFilter, PowerSupplyWhereInput> | null
    pcCase?: XOR<PCCaseNullableRelationFilter, PCCaseWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ParcialPCConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrderInput | SortOrder
    processorId?: SortOrderInput | SortOrder
    gpuId?: SortOrderInput | SortOrder
    powerSupplyId?: SortOrderInput | SortOrder
    pcCaseId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    motherboard?: MotherboardOrderByWithRelationInput
    processor?: ProcessorOrderByWithRelationInput
    rams?: RAMOrderByRelationAggregateInput
    gpu?: GPUOrderByWithRelationInput
    storages?: StorageOrderByRelationAggregateInput
    powerSupply?: PowerSupplyOrderByWithRelationInput
    pcCase?: PCCaseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ParcialPCConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ParcialPCConfigurationWhereInput | ParcialPCConfigurationWhereInput[]
    OR?: ParcialPCConfigurationWhereInput[]
    NOT?: ParcialPCConfigurationWhereInput | ParcialPCConfigurationWhereInput[]
    configurationType?: EnumConfigurationTypeFilter<"ParcialPCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    processorId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    gpuId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    powerSupplyId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    pcCaseId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    createdAt?: DateTimeFilter<"ParcialPCConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ParcialPCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ParcialPCConfiguration"> | Date | string | null
    motherboard?: XOR<MotherboardNullableRelationFilter, MotherboardWhereInput> | null
    processor?: XOR<ProcessorNullableRelationFilter, ProcessorWhereInput> | null
    rams?: RAMListRelationFilter
    gpu?: XOR<GPUNullableRelationFilter, GPUWhereInput> | null
    storages?: StorageListRelationFilter
    powerSupply?: XOR<PowerSupplyNullableRelationFilter, PowerSupplyWhereInput> | null
    pcCase?: XOR<PCCaseNullableRelationFilter, PCCaseWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ParcialPCConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrderInput | SortOrder
    processorId?: SortOrderInput | SortOrder
    gpuId?: SortOrderInput | SortOrder
    powerSupplyId?: SortOrderInput | SortOrder
    pcCaseId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ParcialPCConfigurationCountOrderByAggregateInput
    _max?: ParcialPCConfigurationMaxOrderByAggregateInput
    _min?: ParcialPCConfigurationMinOrderByAggregateInput
  }

  export type ParcialPCConfigurationScalarWhereWithAggregatesInput = {
    AND?: ParcialPCConfigurationScalarWhereWithAggregatesInput | ParcialPCConfigurationScalarWhereWithAggregatesInput[]
    OR?: ParcialPCConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ParcialPCConfigurationScalarWhereWithAggregatesInput | ParcialPCConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParcialPCConfiguration"> | string
    configurationType?: EnumConfigurationTypeWithAggregatesFilter<"ParcialPCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringNullableWithAggregatesFilter<"ParcialPCConfiguration"> | string | null
    processorId?: StringNullableWithAggregatesFilter<"ParcialPCConfiguration"> | string | null
    gpuId?: StringNullableWithAggregatesFilter<"ParcialPCConfiguration"> | string | null
    powerSupplyId?: StringNullableWithAggregatesFilter<"ParcialPCConfiguration"> | string | null
    pcCaseId?: StringNullableWithAggregatesFilter<"ParcialPCConfiguration"> | string | null
    userId?: StringWithAggregatesFilter<"ParcialPCConfiguration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParcialPCConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParcialPCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ParcialPCConfiguration"> | Date | string | null
  }

  export type PCConfigurationWhereInput = {
    AND?: PCConfigurationWhereInput | PCConfigurationWhereInput[]
    OR?: PCConfigurationWhereInput[]
    NOT?: PCConfigurationWhereInput | PCConfigurationWhereInput[]
    id?: StringFilter<"PCConfiguration"> | string
    totalPrice?: FloatFilter<"PCConfiguration"> | number
    configurationType?: EnumConfigurationTypeFilter<"PCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringFilter<"PCConfiguration"> | string
    processorId?: StringFilter<"PCConfiguration"> | string
    gpuId?: StringFilter<"PCConfiguration"> | string
    powerSupplyId?: StringFilter<"PCConfiguration"> | string
    pcCaseId?: StringFilter<"PCConfiguration"> | string
    userId?: StringFilter<"PCConfiguration"> | string
    createdAt?: DateTimeFilter<"PCConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"PCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PCConfiguration"> | Date | string | null
    motherboard?: XOR<MotherboardRelationFilter, MotherboardWhereInput>
    processor?: XOR<ProcessorRelationFilter, ProcessorWhereInput>
    rams?: RAMListRelationFilter
    gpu?: XOR<GPURelationFilter, GPUWhereInput>
    storages?: StorageListRelationFilter
    powerSupply?: XOR<PowerSupplyRelationFilter, PowerSupplyWhereInput>
    pcCase?: XOR<PCCaseRelationFilter, PCCaseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PCConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    motherboard?: MotherboardOrderByWithRelationInput
    processor?: ProcessorOrderByWithRelationInput
    rams?: RAMOrderByRelationAggregateInput
    gpu?: GPUOrderByWithRelationInput
    storages?: StorageOrderByRelationAggregateInput
    powerSupply?: PowerSupplyOrderByWithRelationInput
    pcCase?: PCCaseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PCConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PCConfigurationWhereInput | PCConfigurationWhereInput[]
    OR?: PCConfigurationWhereInput[]
    NOT?: PCConfigurationWhereInput | PCConfigurationWhereInput[]
    totalPrice?: FloatFilter<"PCConfiguration"> | number
    configurationType?: EnumConfigurationTypeFilter<"PCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringFilter<"PCConfiguration"> | string
    processorId?: StringFilter<"PCConfiguration"> | string
    gpuId?: StringFilter<"PCConfiguration"> | string
    powerSupplyId?: StringFilter<"PCConfiguration"> | string
    pcCaseId?: StringFilter<"PCConfiguration"> | string
    userId?: StringFilter<"PCConfiguration"> | string
    createdAt?: DateTimeFilter<"PCConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"PCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PCConfiguration"> | Date | string | null
    motherboard?: XOR<MotherboardRelationFilter, MotherboardWhereInput>
    processor?: XOR<ProcessorRelationFilter, ProcessorWhereInput>
    rams?: RAMListRelationFilter
    gpu?: XOR<GPURelationFilter, GPUWhereInput>
    storages?: StorageListRelationFilter
    powerSupply?: XOR<PowerSupplyRelationFilter, PowerSupplyWhereInput>
    pcCase?: XOR<PCCaseRelationFilter, PCCaseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PCConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PCConfigurationCountOrderByAggregateInput
    _avg?: PCConfigurationAvgOrderByAggregateInput
    _max?: PCConfigurationMaxOrderByAggregateInput
    _min?: PCConfigurationMinOrderByAggregateInput
    _sum?: PCConfigurationSumOrderByAggregateInput
  }

  export type PCConfigurationScalarWhereWithAggregatesInput = {
    AND?: PCConfigurationScalarWhereWithAggregatesInput | PCConfigurationScalarWhereWithAggregatesInput[]
    OR?: PCConfigurationScalarWhereWithAggregatesInput[]
    NOT?: PCConfigurationScalarWhereWithAggregatesInput | PCConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PCConfiguration"> | string
    totalPrice?: FloatWithAggregatesFilter<"PCConfiguration"> | number
    configurationType?: EnumConfigurationTypeWithAggregatesFilter<"PCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringWithAggregatesFilter<"PCConfiguration"> | string
    processorId?: StringWithAggregatesFilter<"PCConfiguration"> | string
    gpuId?: StringWithAggregatesFilter<"PCConfiguration"> | string
    powerSupplyId?: StringWithAggregatesFilter<"PCConfiguration"> | string
    pcCaseId?: StringWithAggregatesFilter<"PCConfiguration"> | string
    userId?: StringWithAggregatesFilter<"PCConfiguration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PCConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PCConfiguration"> | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    userType: $Enums.UserType
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    userId: string
    userType: $Enums.UserType
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type SessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    userId: string
    userType: $Enums.UserType
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type ComponentCreateInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type ComponentCreateManyInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
  }

  export type ComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    userconfigurations?: PCConfigurationCreateNestedManyWithoutUserInput
    partialUserConfiguration?: ParcialPCConfigurationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    userconfigurations?: PCConfigurationUncheckedCreateNestedManyWithoutUserInput
    partialUserConfiguration?: ParcialPCConfigurationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    userconfigurations?: PCConfigurationUpdateManyWithoutUserNestedInput
    partialUserConfiguration?: ParcialPCConfigurationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    userconfigurations?: PCConfigurationUncheckedUpdateManyWithoutUserNestedInput
    partialUserConfiguration?: ParcialPCConfigurationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type MotherboardCreateInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutMotherboardInput
    configurations?: PCConfigurationCreateNestedManyWithoutMotherboardInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardUncheckedCreateInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutMotherboardNestedInput
    configurations?: PCConfigurationUpdateManyWithoutMotherboardNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutMotherboardNestedInput
  }

  export type MotherboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput
  }

  export type MotherboardCreateManyInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    componentId: string
    deletedAt?: Date | string | null
  }

  export type MotherboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MotherboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcessorCreateInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutProcessorInput
    configurations?: PCConfigurationCreateNestedManyWithoutProcessorInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorUncheckedCreateInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutProcessorInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutProcessorNestedInput
    configurations?: PCConfigurationUpdateManyWithoutProcessorNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutProcessorNestedInput
  }

  export type ProcessorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput
  }

  export type ProcessorCreateManyInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    componentId: string
    deletedAt?: Date | string | null
  }

  export type ProcessorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcessorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GPUCreateInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutGpuInput
    configurations?: PCConfigurationCreateNestedManyWithoutGpuInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutGpuInput
  }

  export type GPUUncheckedCreateInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutGpuInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutGpuInput
  }

  export type GPUUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutGpuNestedInput
    configurations?: PCConfigurationUpdateManyWithoutGpuNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutGpuNestedInput
  }

  export type GPUUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutGpuNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutGpuNestedInput
  }

  export type GPUCreateManyInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    componentId: string
    deletedAt?: Date | string | null
  }

  export type GPUUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GPUUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RAMCreateInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutRamInput
    configurations?: PCConfigurationCreateNestedManyWithoutRamsInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutRamsInput
  }

  export type RAMUncheckedCreateInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutRamsInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutRamsInput
  }

  export type RAMUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutRamNestedInput
    configurations?: PCConfigurationUpdateManyWithoutRamsNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutRamsNestedInput
  }

  export type RAMUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutRamsNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutRamsNestedInput
  }

  export type RAMCreateManyInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    componentId: string
    deletedAt?: Date | string | null
  }

  export type RAMUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RAMUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StorageCreateInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutStorageInput
    configurations?: PCConfigurationCreateNestedManyWithoutStoragesInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutStoragesInput
  }

  export type StorageUncheckedCreateInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutStoragesInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutStoragesInput
  }

  export type StorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutStorageNestedInput
    configurations?: PCConfigurationUpdateManyWithoutStoragesNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutStoragesNestedInput
  }

  export type StorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput
  }

  export type StorageCreateManyInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    componentId: string
    deletedAt?: Date | string | null
  }

  export type StorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PowerSupplyCreateInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutPowerSupplyInput
    configurations?: PCConfigurationCreateNestedManyWithoutPowerSupplyInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyUncheckedCreateInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutPowerSupplyNestedInput
    configurations?: PCConfigurationUpdateManyWithoutPowerSupplyNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PowerSupplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PowerSupplyCreateManyInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
  }

  export type PowerSupplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PowerSupplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCCaseCreateInput = {
    id?: string
    formFactor: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutPcCaseInput
    configurations?: PCConfigurationCreateNestedManyWithoutPcCaseInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseUncheckedCreateInput = {
    id?: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutPcCaseNestedInput
    configurations?: PCConfigurationUpdateManyWithoutPcCaseNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutPcCaseNestedInput
  }

  export type PCCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput
  }

  export type PCCaseCreateManyInput = {
    id?: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
  }

  export type PCCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationCreateInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationCreateManyInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ParcialPCConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationCreateInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationCreateManyInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PCConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type EnumComponentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentType | EnumComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentTypeFilter<$PrismaModel> | $Enums.ComponentType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MotherboardNullableRelationFilter = {
    is?: MotherboardWhereInput | null
    isNot?: MotherboardWhereInput | null
  }

  export type ProcessorNullableRelationFilter = {
    is?: ProcessorWhereInput | null
    isNot?: ProcessorWhereInput | null
  }

  export type GPUNullableRelationFilter = {
    is?: GPUWhereInput | null
    isNot?: GPUWhereInput | null
  }

  export type RAMNullableRelationFilter = {
    is?: RAMWhereInput | null
    isNot?: RAMWhereInput | null
  }

  export type StorageNullableRelationFilter = {
    is?: StorageWhereInput | null
    isNot?: StorageWhereInput | null
  }

  export type PowerSupplyNullableRelationFilter = {
    is?: PowerSupplyWhereInput | null
    isNot?: PowerSupplyWhereInput | null
  }

  export type PCCaseNullableRelationFilter = {
    is?: PCCaseWhereInput | null
    isNot?: PCCaseWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ComponentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    componentType?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    imageUrl?: SortOrder
    deletedAt?: SortOrder
  }

  export type ComponentAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    componentType?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    imageUrl?: SortOrder
    deletedAt?: SortOrder
  }

  export type ComponentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    componentType?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    imageUrl?: SortOrder
    deletedAt?: SortOrder
  }

  export type ComponentSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumComponentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentType | EnumComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ComponentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComponentTypeFilter<$PrismaModel>
    _max?: NestedEnumComponentTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PCConfigurationListRelationFilter = {
    every?: PCConfigurationWhereInput
    some?: PCConfigurationWhereInput
    none?: PCConfigurationWhereInput
  }

  export type ParcialPCConfigurationNullableRelationFilter = {
    is?: ParcialPCConfigurationWhereInput | null
    isNot?: ParcialPCConfigurationWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PCConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ComponentRelationFilter = {
    is?: ComponentWhereInput
    isNot?: ComponentWhereInput
  }

  export type ParcialPCConfigurationListRelationFilter = {
    every?: ParcialPCConfigurationWhereInput
    some?: ParcialPCConfigurationWhereInput
    none?: ParcialPCConfigurationWhereInput
  }

  export type ParcialPCConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MotherboardCountOrderByAggregateInput = {
    id?: SortOrder
    socket?: SortOrder
    formFactor?: SortOrder
    ramSlots?: SortOrder
    ramType?: SortOrder
    gpuInterface?: SortOrder
    stroageBusType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type MotherboardAvgOrderByAggregateInput = {
    ramSlots?: SortOrder
  }

  export type MotherboardMaxOrderByAggregateInput = {
    id?: SortOrder
    socket?: SortOrder
    formFactor?: SortOrder
    ramSlots?: SortOrder
    ramType?: SortOrder
    gpuInterface?: SortOrder
    stroageBusType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type MotherboardMinOrderByAggregateInput = {
    id?: SortOrder
    socket?: SortOrder
    formFactor?: SortOrder
    ramSlots?: SortOrder
    ramType?: SortOrder
    gpuInterface?: SortOrder
    stroageBusType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type MotherboardSumOrderByAggregateInput = {
    ramSlots?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProcessorCountOrderByAggregateInput = {
    id?: SortOrder
    architecture?: SortOrder
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
    socket?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProcessorAvgOrderByAggregateInput = {
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
  }

  export type ProcessorMaxOrderByAggregateInput = {
    id?: SortOrder
    architecture?: SortOrder
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
    socket?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProcessorMinOrderByAggregateInput = {
    id?: SortOrder
    architecture?: SortOrder
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
    socket?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProcessorSumOrderByAggregateInput = {
    cores?: SortOrder
    threads?: SortOrder
    bits?: SortOrder
  }

  export type GPUCountOrderByAggregateInput = {
    id?: SortOrder
    memory?: SortOrder
    powerConnector?: SortOrder
    interface?: SortOrder
    power?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type GPUAvgOrderByAggregateInput = {
    memory?: SortOrder
    power?: SortOrder
  }

  export type GPUMaxOrderByAggregateInput = {
    id?: SortOrder
    memory?: SortOrder
    powerConnector?: SortOrder
    interface?: SortOrder
    power?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type GPUMinOrderByAggregateInput = {
    id?: SortOrder
    memory?: SortOrder
    powerConnector?: SortOrder
    interface?: SortOrder
    power?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type GPUSumOrderByAggregateInput = {
    memory?: SortOrder
    power?: SortOrder
  }

  export type EnumComputerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ComputerType | EnumComputerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComputerTypeFilter<$PrismaModel> | $Enums.ComputerType
  }

  export type RAMCountOrderByAggregateInput = {
    id?: SortOrder
    memoryType?: SortOrder
    capacity?: SortOrder
    computerType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type RAMAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type RAMMaxOrderByAggregateInput = {
    id?: SortOrder
    memoryType?: SortOrder
    capacity?: SortOrder
    computerType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type RAMMinOrderByAggregateInput = {
    id?: SortOrder
    memoryType?: SortOrder
    capacity?: SortOrder
    computerType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type RAMSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type EnumComputerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComputerType | EnumComputerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComputerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ComputerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComputerTypeFilter<$PrismaModel>
    _max?: NestedEnumComputerTypeFilter<$PrismaModel>
  }

  export type StorageCountOrderByAggregateInput = {
    id?: SortOrder
    storageType?: SortOrder
    capacity?: SortOrder
    busType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type StorageAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type StorageMaxOrderByAggregateInput = {
    id?: SortOrder
    storageType?: SortOrder
    capacity?: SortOrder
    busType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type StorageMinOrderByAggregateInput = {
    id?: SortOrder
    storageType?: SortOrder
    capacity?: SortOrder
    busType?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type StorageSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type PowerSupplyCountOrderByAggregateInput = {
    id?: SortOrder
    powerOutput?: SortOrder
    efficiency?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PowerSupplyAvgOrderByAggregateInput = {
    powerOutput?: SortOrder
  }

  export type PowerSupplyMaxOrderByAggregateInput = {
    id?: SortOrder
    powerOutput?: SortOrder
    efficiency?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PowerSupplyMinOrderByAggregateInput = {
    id?: SortOrder
    powerOutput?: SortOrder
    efficiency?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PowerSupplySumOrderByAggregateInput = {
    powerOutput?: SortOrder
  }

  export type PCCaseCountOrderByAggregateInput = {
    id?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PCCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PCCaseMinOrderByAggregateInput = {
    id?: SortOrder
    formFactor?: SortOrder
    componentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumConfigurationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigurationType | EnumConfigurationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigurationTypeFilter<$PrismaModel> | $Enums.ConfigurationType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RAMListRelationFilter = {
    every?: RAMWhereInput
    some?: RAMWhereInput
    none?: RAMWhereInput
  }

  export type StorageListRelationFilter = {
    every?: StorageWhereInput
    some?: StorageWhereInput
    none?: StorageWhereInput
  }

  export type RAMOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParcialPCConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ParcialPCConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ParcialPCConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumConfigurationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigurationType | EnumConfigurationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigurationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConfigurationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfigurationTypeFilter<$PrismaModel>
    _max?: NestedEnumConfigurationTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MotherboardRelationFilter = {
    is?: MotherboardWhereInput
    isNot?: MotherboardWhereInput
  }

  export type ProcessorRelationFilter = {
    is?: ProcessorWhereInput
    isNot?: ProcessorWhereInput
  }

  export type GPURelationFilter = {
    is?: GPUWhereInput
    isNot?: GPUWhereInput
  }

  export type PowerSupplyRelationFilter = {
    is?: PowerSupplyWhereInput
    isNot?: PowerSupplyWhereInput
  }

  export type PCCaseRelationFilter = {
    is?: PCCaseWhereInput
    isNot?: PCCaseWhereInput
  }

  export type PCConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PCConfigurationAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type PCConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PCConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    configurationType?: SortOrder
    motherboardId?: SortOrder
    processorId?: SortOrder
    gpuId?: SortOrder
    powerSupplyId?: SortOrder
    pcCaseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PCConfigurationSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type MotherboardCreateNestedOneWithoutComponentInput = {
    create?: XOR<MotherboardCreateWithoutComponentInput, MotherboardUncheckedCreateWithoutComponentInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutComponentInput
    connect?: MotherboardWhereUniqueInput
  }

  export type ProcessorCreateNestedOneWithoutComponentInput = {
    create?: XOR<ProcessorCreateWithoutComponentInput, ProcessorUncheckedCreateWithoutComponentInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutComponentInput
    connect?: ProcessorWhereUniqueInput
  }

  export type GPUCreateNestedOneWithoutComponentInput = {
    create?: XOR<GPUCreateWithoutComponentInput, GPUUncheckedCreateWithoutComponentInput>
    connectOrCreate?: GPUCreateOrConnectWithoutComponentInput
    connect?: GPUWhereUniqueInput
  }

  export type RAMCreateNestedOneWithoutComponentInput = {
    create?: XOR<RAMCreateWithoutComponentInput, RAMUncheckedCreateWithoutComponentInput>
    connectOrCreate?: RAMCreateOrConnectWithoutComponentInput
    connect?: RAMWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutComponentInput = {
    create?: XOR<StorageCreateWithoutComponentInput, StorageUncheckedCreateWithoutComponentInput>
    connectOrCreate?: StorageCreateOrConnectWithoutComponentInput
    connect?: StorageWhereUniqueInput
  }

  export type PowerSupplyCreateNestedOneWithoutComponentInput = {
    create?: XOR<PowerSupplyCreateWithoutComponentInput, PowerSupplyUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutComponentInput
    connect?: PowerSupplyWhereUniqueInput
  }

  export type PCCaseCreateNestedOneWithoutComponentInput = {
    create?: XOR<PCCaseCreateWithoutComponentInput, PCCaseUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutComponentInput
    connect?: PCCaseWhereUniqueInput
  }

  export type MotherboardUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<MotherboardCreateWithoutComponentInput, MotherboardUncheckedCreateWithoutComponentInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutComponentInput
    connect?: MotherboardWhereUniqueInput
  }

  export type ProcessorUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<ProcessorCreateWithoutComponentInput, ProcessorUncheckedCreateWithoutComponentInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutComponentInput
    connect?: ProcessorWhereUniqueInput
  }

  export type GPUUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<GPUCreateWithoutComponentInput, GPUUncheckedCreateWithoutComponentInput>
    connectOrCreate?: GPUCreateOrConnectWithoutComponentInput
    connect?: GPUWhereUniqueInput
  }

  export type RAMUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<RAMCreateWithoutComponentInput, RAMUncheckedCreateWithoutComponentInput>
    connectOrCreate?: RAMCreateOrConnectWithoutComponentInput
    connect?: RAMWhereUniqueInput
  }

  export type StorageUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<StorageCreateWithoutComponentInput, StorageUncheckedCreateWithoutComponentInput>
    connectOrCreate?: StorageCreateOrConnectWithoutComponentInput
    connect?: StorageWhereUniqueInput
  }

  export type PowerSupplyUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<PowerSupplyCreateWithoutComponentInput, PowerSupplyUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutComponentInput
    connect?: PowerSupplyWhereUniqueInput
  }

  export type PCCaseUncheckedCreateNestedOneWithoutComponentInput = {
    create?: XOR<PCCaseCreateWithoutComponentInput, PCCaseUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutComponentInput
    connect?: PCCaseWhereUniqueInput
  }

  export type EnumComponentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ComponentType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MotherboardUpdateOneWithoutComponentNestedInput = {
    create?: XOR<MotherboardCreateWithoutComponentInput, MotherboardUncheckedCreateWithoutComponentInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutComponentInput
    upsert?: MotherboardUpsertWithoutComponentInput
    disconnect?: MotherboardWhereInput | boolean
    delete?: MotherboardWhereInput | boolean
    connect?: MotherboardWhereUniqueInput
    update?: XOR<XOR<MotherboardUpdateToOneWithWhereWithoutComponentInput, MotherboardUpdateWithoutComponentInput>, MotherboardUncheckedUpdateWithoutComponentInput>
  }

  export type ProcessorUpdateOneWithoutComponentNestedInput = {
    create?: XOR<ProcessorCreateWithoutComponentInput, ProcessorUncheckedCreateWithoutComponentInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutComponentInput
    upsert?: ProcessorUpsertWithoutComponentInput
    disconnect?: ProcessorWhereInput | boolean
    delete?: ProcessorWhereInput | boolean
    connect?: ProcessorWhereUniqueInput
    update?: XOR<XOR<ProcessorUpdateToOneWithWhereWithoutComponentInput, ProcessorUpdateWithoutComponentInput>, ProcessorUncheckedUpdateWithoutComponentInput>
  }

  export type GPUUpdateOneWithoutComponentNestedInput = {
    create?: XOR<GPUCreateWithoutComponentInput, GPUUncheckedCreateWithoutComponentInput>
    connectOrCreate?: GPUCreateOrConnectWithoutComponentInput
    upsert?: GPUUpsertWithoutComponentInput
    disconnect?: GPUWhereInput | boolean
    delete?: GPUWhereInput | boolean
    connect?: GPUWhereUniqueInput
    update?: XOR<XOR<GPUUpdateToOneWithWhereWithoutComponentInput, GPUUpdateWithoutComponentInput>, GPUUncheckedUpdateWithoutComponentInput>
  }

  export type RAMUpdateOneWithoutComponentNestedInput = {
    create?: XOR<RAMCreateWithoutComponentInput, RAMUncheckedCreateWithoutComponentInput>
    connectOrCreate?: RAMCreateOrConnectWithoutComponentInput
    upsert?: RAMUpsertWithoutComponentInput
    disconnect?: RAMWhereInput | boolean
    delete?: RAMWhereInput | boolean
    connect?: RAMWhereUniqueInput
    update?: XOR<XOR<RAMUpdateToOneWithWhereWithoutComponentInput, RAMUpdateWithoutComponentInput>, RAMUncheckedUpdateWithoutComponentInput>
  }

  export type StorageUpdateOneWithoutComponentNestedInput = {
    create?: XOR<StorageCreateWithoutComponentInput, StorageUncheckedCreateWithoutComponentInput>
    connectOrCreate?: StorageCreateOrConnectWithoutComponentInput
    upsert?: StorageUpsertWithoutComponentInput
    disconnect?: StorageWhereInput | boolean
    delete?: StorageWhereInput | boolean
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutComponentInput, StorageUpdateWithoutComponentInput>, StorageUncheckedUpdateWithoutComponentInput>
  }

  export type PowerSupplyUpdateOneWithoutComponentNestedInput = {
    create?: XOR<PowerSupplyCreateWithoutComponentInput, PowerSupplyUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutComponentInput
    upsert?: PowerSupplyUpsertWithoutComponentInput
    disconnect?: PowerSupplyWhereInput | boolean
    delete?: PowerSupplyWhereInput | boolean
    connect?: PowerSupplyWhereUniqueInput
    update?: XOR<XOR<PowerSupplyUpdateToOneWithWhereWithoutComponentInput, PowerSupplyUpdateWithoutComponentInput>, PowerSupplyUncheckedUpdateWithoutComponentInput>
  }

  export type PCCaseUpdateOneWithoutComponentNestedInput = {
    create?: XOR<PCCaseCreateWithoutComponentInput, PCCaseUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutComponentInput
    upsert?: PCCaseUpsertWithoutComponentInput
    disconnect?: PCCaseWhereInput | boolean
    delete?: PCCaseWhereInput | boolean
    connect?: PCCaseWhereUniqueInput
    update?: XOR<XOR<PCCaseUpdateToOneWithWhereWithoutComponentInput, PCCaseUpdateWithoutComponentInput>, PCCaseUncheckedUpdateWithoutComponentInput>
  }

  export type MotherboardUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<MotherboardCreateWithoutComponentInput, MotherboardUncheckedCreateWithoutComponentInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutComponentInput
    upsert?: MotherboardUpsertWithoutComponentInput
    disconnect?: MotherboardWhereInput | boolean
    delete?: MotherboardWhereInput | boolean
    connect?: MotherboardWhereUniqueInput
    update?: XOR<XOR<MotherboardUpdateToOneWithWhereWithoutComponentInput, MotherboardUpdateWithoutComponentInput>, MotherboardUncheckedUpdateWithoutComponentInput>
  }

  export type ProcessorUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<ProcessorCreateWithoutComponentInput, ProcessorUncheckedCreateWithoutComponentInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutComponentInput
    upsert?: ProcessorUpsertWithoutComponentInput
    disconnect?: ProcessorWhereInput | boolean
    delete?: ProcessorWhereInput | boolean
    connect?: ProcessorWhereUniqueInput
    update?: XOR<XOR<ProcessorUpdateToOneWithWhereWithoutComponentInput, ProcessorUpdateWithoutComponentInput>, ProcessorUncheckedUpdateWithoutComponentInput>
  }

  export type GPUUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<GPUCreateWithoutComponentInput, GPUUncheckedCreateWithoutComponentInput>
    connectOrCreate?: GPUCreateOrConnectWithoutComponentInput
    upsert?: GPUUpsertWithoutComponentInput
    disconnect?: GPUWhereInput | boolean
    delete?: GPUWhereInput | boolean
    connect?: GPUWhereUniqueInput
    update?: XOR<XOR<GPUUpdateToOneWithWhereWithoutComponentInput, GPUUpdateWithoutComponentInput>, GPUUncheckedUpdateWithoutComponentInput>
  }

  export type RAMUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<RAMCreateWithoutComponentInput, RAMUncheckedCreateWithoutComponentInput>
    connectOrCreate?: RAMCreateOrConnectWithoutComponentInput
    upsert?: RAMUpsertWithoutComponentInput
    disconnect?: RAMWhereInput | boolean
    delete?: RAMWhereInput | boolean
    connect?: RAMWhereUniqueInput
    update?: XOR<XOR<RAMUpdateToOneWithWhereWithoutComponentInput, RAMUpdateWithoutComponentInput>, RAMUncheckedUpdateWithoutComponentInput>
  }

  export type StorageUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<StorageCreateWithoutComponentInput, StorageUncheckedCreateWithoutComponentInput>
    connectOrCreate?: StorageCreateOrConnectWithoutComponentInput
    upsert?: StorageUpsertWithoutComponentInput
    disconnect?: StorageWhereInput | boolean
    delete?: StorageWhereInput | boolean
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutComponentInput, StorageUpdateWithoutComponentInput>, StorageUncheckedUpdateWithoutComponentInput>
  }

  export type PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<PowerSupplyCreateWithoutComponentInput, PowerSupplyUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutComponentInput
    upsert?: PowerSupplyUpsertWithoutComponentInput
    disconnect?: PowerSupplyWhereInput | boolean
    delete?: PowerSupplyWhereInput | boolean
    connect?: PowerSupplyWhereUniqueInput
    update?: XOR<XOR<PowerSupplyUpdateToOneWithWhereWithoutComponentInput, PowerSupplyUpdateWithoutComponentInput>, PowerSupplyUncheckedUpdateWithoutComponentInput>
  }

  export type PCCaseUncheckedUpdateOneWithoutComponentNestedInput = {
    create?: XOR<PCCaseCreateWithoutComponentInput, PCCaseUncheckedCreateWithoutComponentInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutComponentInput
    upsert?: PCCaseUpsertWithoutComponentInput
    disconnect?: PCCaseWhereInput | boolean
    delete?: PCCaseWhereInput | boolean
    connect?: PCCaseWhereUniqueInput
    update?: XOR<XOR<PCCaseUpdateToOneWithWhereWithoutComponentInput, PCCaseUpdateWithoutComponentInput>, PCCaseUncheckedUpdateWithoutComponentInput>
  }

  export type PCConfigurationCreateNestedManyWithoutUserInput = {
    create?: XOR<PCConfigurationCreateWithoutUserInput, PCConfigurationUncheckedCreateWithoutUserInput> | PCConfigurationCreateWithoutUserInput[] | PCConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutUserInput | PCConfigurationCreateOrConnectWithoutUserInput[]
    createMany?: PCConfigurationCreateManyUserInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedOneWithoutUserInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutUserInput, ParcialPCConfigurationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutUserInput
    connect?: ParcialPCConfigurationWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PCConfigurationCreateWithoutUserInput, PCConfigurationUncheckedCreateWithoutUserInput> | PCConfigurationCreateWithoutUserInput[] | PCConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutUserInput | PCConfigurationCreateOrConnectWithoutUserInput[]
    createMany?: PCConfigurationCreateManyUserInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutUserInput, ParcialPCConfigurationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutUserInput
    connect?: ParcialPCConfigurationWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PCConfigurationUpdateManyWithoutUserNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutUserInput, PCConfigurationUncheckedCreateWithoutUserInput> | PCConfigurationCreateWithoutUserInput[] | PCConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutUserInput | PCConfigurationCreateOrConnectWithoutUserInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutUserInput | PCConfigurationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PCConfigurationCreateManyUserInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutUserInput | PCConfigurationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutUserInput | PCConfigurationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutUserInput, ParcialPCConfigurationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutUserInput
    upsert?: ParcialPCConfigurationUpsertWithoutUserInput
    disconnect?: ParcialPCConfigurationWhereInput | boolean
    delete?: ParcialPCConfigurationWhereInput | boolean
    connect?: ParcialPCConfigurationWhereUniqueInput
    update?: XOR<XOR<ParcialPCConfigurationUpdateToOneWithWhereWithoutUserInput, ParcialPCConfigurationUpdateWithoutUserInput>, ParcialPCConfigurationUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutUserInput, PCConfigurationUncheckedCreateWithoutUserInput> | PCConfigurationCreateWithoutUserInput[] | PCConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutUserInput | PCConfigurationCreateOrConnectWithoutUserInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutUserInput | PCConfigurationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PCConfigurationCreateManyUserInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutUserInput | PCConfigurationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutUserInput | PCConfigurationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutUserInput, ParcialPCConfigurationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutUserInput
    upsert?: ParcialPCConfigurationUpsertWithoutUserInput
    disconnect?: ParcialPCConfigurationWhereInput | boolean
    delete?: ParcialPCConfigurationWhereInput | boolean
    connect?: ParcialPCConfigurationWhereUniqueInput
    update?: XOR<XOR<ParcialPCConfigurationUpdateToOneWithWhereWithoutUserInput, ParcialPCConfigurationUpdateWithoutUserInput>, ParcialPCConfigurationUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutMotherboardInput = {
    create?: XOR<ComponentCreateWithoutMotherboardInput, ComponentUncheckedCreateWithoutMotherboardInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutMotherboardInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutMotherboardInput = {
    create?: XOR<PCConfigurationCreateWithoutMotherboardInput, PCConfigurationUncheckedCreateWithoutMotherboardInput> | PCConfigurationCreateWithoutMotherboardInput[] | PCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutMotherboardInput | PCConfigurationCreateOrConnectWithoutMotherboardInput[]
    createMany?: PCConfigurationCreateManyMotherboardInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutMotherboardInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutMotherboardInput, ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput> | ParcialPCConfigurationCreateWithoutMotherboardInput[] | ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput | ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput[]
    createMany?: ParcialPCConfigurationCreateManyMotherboardInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput = {
    create?: XOR<PCConfigurationCreateWithoutMotherboardInput, PCConfigurationUncheckedCreateWithoutMotherboardInput> | PCConfigurationCreateWithoutMotherboardInput[] | PCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutMotherboardInput | PCConfigurationCreateOrConnectWithoutMotherboardInput[]
    createMany?: PCConfigurationCreateManyMotherboardInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutMotherboardInput, ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput> | ParcialPCConfigurationCreateWithoutMotherboardInput[] | ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput | ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput[]
    createMany?: ParcialPCConfigurationCreateManyMotherboardInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComponentUpdateOneRequiredWithoutMotherboardNestedInput = {
    create?: XOR<ComponentCreateWithoutMotherboardInput, ComponentUncheckedCreateWithoutMotherboardInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutMotherboardInput
    upsert?: ComponentUpsertWithoutMotherboardInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutMotherboardInput, ComponentUpdateWithoutMotherboardInput>, ComponentUncheckedUpdateWithoutMotherboardInput>
  }

  export type PCConfigurationUpdateManyWithoutMotherboardNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutMotherboardInput, PCConfigurationUncheckedCreateWithoutMotherboardInput> | PCConfigurationCreateWithoutMotherboardInput[] | PCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutMotherboardInput | PCConfigurationCreateOrConnectWithoutMotherboardInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput | PCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput[]
    createMany?: PCConfigurationCreateManyMotherboardInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput | PCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutMotherboardInput | PCConfigurationUpdateManyWithWhereWithoutMotherboardInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutMotherboardNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutMotherboardInput, ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput> | ParcialPCConfigurationCreateWithoutMotherboardInput[] | ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput | ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput[]
    createMany?: ParcialPCConfigurationCreateManyMotherboardInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutMotherboardInput | ParcialPCConfigurationUpdateManyWithWhereWithoutMotherboardInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutMotherboardInput, PCConfigurationUncheckedCreateWithoutMotherboardInput> | PCConfigurationCreateWithoutMotherboardInput[] | PCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutMotherboardInput | PCConfigurationCreateOrConnectWithoutMotherboardInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput | PCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput[]
    createMany?: PCConfigurationCreateManyMotherboardInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput | PCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutMotherboardInput | PCConfigurationUpdateManyWithWhereWithoutMotherboardInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutMotherboardInput, ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput> | ParcialPCConfigurationCreateWithoutMotherboardInput[] | ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput | ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput[]
    createMany?: ParcialPCConfigurationCreateManyMotherboardInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutMotherboardInput | ParcialPCConfigurationUpdateManyWithWhereWithoutMotherboardInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutProcessorInput = {
    create?: XOR<ComponentCreateWithoutProcessorInput, ComponentUncheckedCreateWithoutProcessorInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutProcessorInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutProcessorInput = {
    create?: XOR<PCConfigurationCreateWithoutProcessorInput, PCConfigurationUncheckedCreateWithoutProcessorInput> | PCConfigurationCreateWithoutProcessorInput[] | PCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutProcessorInput | PCConfigurationCreateOrConnectWithoutProcessorInput[]
    createMany?: PCConfigurationCreateManyProcessorInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutProcessorInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutProcessorInput, ParcialPCConfigurationUncheckedCreateWithoutProcessorInput> | ParcialPCConfigurationCreateWithoutProcessorInput[] | ParcialPCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutProcessorInput | ParcialPCConfigurationCreateOrConnectWithoutProcessorInput[]
    createMany?: ParcialPCConfigurationCreateManyProcessorInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutProcessorInput = {
    create?: XOR<PCConfigurationCreateWithoutProcessorInput, PCConfigurationUncheckedCreateWithoutProcessorInput> | PCConfigurationCreateWithoutProcessorInput[] | PCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutProcessorInput | PCConfigurationCreateOrConnectWithoutProcessorInput[]
    createMany?: PCConfigurationCreateManyProcessorInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutProcessorInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutProcessorInput, ParcialPCConfigurationUncheckedCreateWithoutProcessorInput> | ParcialPCConfigurationCreateWithoutProcessorInput[] | ParcialPCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutProcessorInput | ParcialPCConfigurationCreateOrConnectWithoutProcessorInput[]
    createMany?: ParcialPCConfigurationCreateManyProcessorInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type ComponentUpdateOneRequiredWithoutProcessorNestedInput = {
    create?: XOR<ComponentCreateWithoutProcessorInput, ComponentUncheckedCreateWithoutProcessorInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutProcessorInput
    upsert?: ComponentUpsertWithoutProcessorInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutProcessorInput, ComponentUpdateWithoutProcessorInput>, ComponentUncheckedUpdateWithoutProcessorInput>
  }

  export type PCConfigurationUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutProcessorInput, PCConfigurationUncheckedCreateWithoutProcessorInput> | PCConfigurationCreateWithoutProcessorInput[] | PCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutProcessorInput | PCConfigurationCreateOrConnectWithoutProcessorInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutProcessorInput | PCConfigurationUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: PCConfigurationCreateManyProcessorInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutProcessorInput | PCConfigurationUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutProcessorInput | PCConfigurationUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutProcessorInput, ParcialPCConfigurationUncheckedCreateWithoutProcessorInput> | ParcialPCConfigurationCreateWithoutProcessorInput[] | ParcialPCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutProcessorInput | ParcialPCConfigurationCreateOrConnectWithoutProcessorInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutProcessorInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: ParcialPCConfigurationCreateManyProcessorInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutProcessorInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutProcessorInput | ParcialPCConfigurationUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutProcessorInput, PCConfigurationUncheckedCreateWithoutProcessorInput> | PCConfigurationCreateWithoutProcessorInput[] | PCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutProcessorInput | PCConfigurationCreateOrConnectWithoutProcessorInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutProcessorInput | PCConfigurationUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: PCConfigurationCreateManyProcessorInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutProcessorInput | PCConfigurationUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutProcessorInput | PCConfigurationUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutProcessorInput, ParcialPCConfigurationUncheckedCreateWithoutProcessorInput> | ParcialPCConfigurationCreateWithoutProcessorInput[] | ParcialPCConfigurationUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutProcessorInput | ParcialPCConfigurationCreateOrConnectWithoutProcessorInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutProcessorInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: ParcialPCConfigurationCreateManyProcessorInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutProcessorInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutProcessorInput | ParcialPCConfigurationUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutGpuInput = {
    create?: XOR<ComponentCreateWithoutGpuInput, ComponentUncheckedCreateWithoutGpuInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutGpuInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutGpuInput = {
    create?: XOR<PCConfigurationCreateWithoutGpuInput, PCConfigurationUncheckedCreateWithoutGpuInput> | PCConfigurationCreateWithoutGpuInput[] | PCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutGpuInput | PCConfigurationCreateOrConnectWithoutGpuInput[]
    createMany?: PCConfigurationCreateManyGpuInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutGpuInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutGpuInput, ParcialPCConfigurationUncheckedCreateWithoutGpuInput> | ParcialPCConfigurationCreateWithoutGpuInput[] | ParcialPCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutGpuInput | ParcialPCConfigurationCreateOrConnectWithoutGpuInput[]
    createMany?: ParcialPCConfigurationCreateManyGpuInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutGpuInput = {
    create?: XOR<PCConfigurationCreateWithoutGpuInput, PCConfigurationUncheckedCreateWithoutGpuInput> | PCConfigurationCreateWithoutGpuInput[] | PCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutGpuInput | PCConfigurationCreateOrConnectWithoutGpuInput[]
    createMany?: PCConfigurationCreateManyGpuInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutGpuInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutGpuInput, ParcialPCConfigurationUncheckedCreateWithoutGpuInput> | ParcialPCConfigurationCreateWithoutGpuInput[] | ParcialPCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutGpuInput | ParcialPCConfigurationCreateOrConnectWithoutGpuInput[]
    createMany?: ParcialPCConfigurationCreateManyGpuInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type ComponentUpdateOneRequiredWithoutGpuNestedInput = {
    create?: XOR<ComponentCreateWithoutGpuInput, ComponentUncheckedCreateWithoutGpuInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutGpuInput
    upsert?: ComponentUpsertWithoutGpuInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutGpuInput, ComponentUpdateWithoutGpuInput>, ComponentUncheckedUpdateWithoutGpuInput>
  }

  export type PCConfigurationUpdateManyWithoutGpuNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutGpuInput, PCConfigurationUncheckedCreateWithoutGpuInput> | PCConfigurationCreateWithoutGpuInput[] | PCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutGpuInput | PCConfigurationCreateOrConnectWithoutGpuInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutGpuInput | PCConfigurationUpsertWithWhereUniqueWithoutGpuInput[]
    createMany?: PCConfigurationCreateManyGpuInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutGpuInput | PCConfigurationUpdateWithWhereUniqueWithoutGpuInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutGpuInput | PCConfigurationUpdateManyWithWhereWithoutGpuInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutGpuNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutGpuInput, ParcialPCConfigurationUncheckedCreateWithoutGpuInput> | ParcialPCConfigurationCreateWithoutGpuInput[] | ParcialPCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutGpuInput | ParcialPCConfigurationCreateOrConnectWithoutGpuInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutGpuInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutGpuInput[]
    createMany?: ParcialPCConfigurationCreateManyGpuInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutGpuInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutGpuInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutGpuInput | ParcialPCConfigurationUpdateManyWithWhereWithoutGpuInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutGpuNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutGpuInput, PCConfigurationUncheckedCreateWithoutGpuInput> | PCConfigurationCreateWithoutGpuInput[] | PCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutGpuInput | PCConfigurationCreateOrConnectWithoutGpuInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutGpuInput | PCConfigurationUpsertWithWhereUniqueWithoutGpuInput[]
    createMany?: PCConfigurationCreateManyGpuInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutGpuInput | PCConfigurationUpdateWithWhereUniqueWithoutGpuInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutGpuInput | PCConfigurationUpdateManyWithWhereWithoutGpuInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutGpuNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutGpuInput, ParcialPCConfigurationUncheckedCreateWithoutGpuInput> | ParcialPCConfigurationCreateWithoutGpuInput[] | ParcialPCConfigurationUncheckedCreateWithoutGpuInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutGpuInput | ParcialPCConfigurationCreateOrConnectWithoutGpuInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutGpuInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutGpuInput[]
    createMany?: ParcialPCConfigurationCreateManyGpuInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutGpuInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutGpuInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutGpuInput | ParcialPCConfigurationUpdateManyWithWhereWithoutGpuInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutRamInput = {
    create?: XOR<ComponentCreateWithoutRamInput, ComponentUncheckedCreateWithoutRamInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutRamInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutRamsInput = {
    create?: XOR<PCConfigurationCreateWithoutRamsInput, PCConfigurationUncheckedCreateWithoutRamsInput> | PCConfigurationCreateWithoutRamsInput[] | PCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutRamsInput | PCConfigurationCreateOrConnectWithoutRamsInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutRamsInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutRamsInput, ParcialPCConfigurationUncheckedCreateWithoutRamsInput> | ParcialPCConfigurationCreateWithoutRamsInput[] | ParcialPCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutRamsInput | ParcialPCConfigurationCreateOrConnectWithoutRamsInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutRamsInput = {
    create?: XOR<PCConfigurationCreateWithoutRamsInput, PCConfigurationUncheckedCreateWithoutRamsInput> | PCConfigurationCreateWithoutRamsInput[] | PCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutRamsInput | PCConfigurationCreateOrConnectWithoutRamsInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutRamsInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutRamsInput, ParcialPCConfigurationUncheckedCreateWithoutRamsInput> | ParcialPCConfigurationCreateWithoutRamsInput[] | ParcialPCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutRamsInput | ParcialPCConfigurationCreateOrConnectWithoutRamsInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type EnumComputerTypeFieldUpdateOperationsInput = {
    set?: $Enums.ComputerType
  }

  export type ComponentUpdateOneRequiredWithoutRamNestedInput = {
    create?: XOR<ComponentCreateWithoutRamInput, ComponentUncheckedCreateWithoutRamInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutRamInput
    upsert?: ComponentUpsertWithoutRamInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutRamInput, ComponentUpdateWithoutRamInput>, ComponentUncheckedUpdateWithoutRamInput>
  }

  export type PCConfigurationUpdateManyWithoutRamsNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutRamsInput, PCConfigurationUncheckedCreateWithoutRamsInput> | PCConfigurationCreateWithoutRamsInput[] | PCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutRamsInput | PCConfigurationCreateOrConnectWithoutRamsInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutRamsInput | PCConfigurationUpsertWithWhereUniqueWithoutRamsInput[]
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutRamsInput | PCConfigurationUpdateWithWhereUniqueWithoutRamsInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutRamsInput | PCConfigurationUpdateManyWithWhereWithoutRamsInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutRamsNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutRamsInput, ParcialPCConfigurationUncheckedCreateWithoutRamsInput> | ParcialPCConfigurationCreateWithoutRamsInput[] | ParcialPCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutRamsInput | ParcialPCConfigurationCreateOrConnectWithoutRamsInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutRamsInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutRamsInput[]
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutRamsInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutRamsInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutRamsInput | ParcialPCConfigurationUpdateManyWithWhereWithoutRamsInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutRamsNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutRamsInput, PCConfigurationUncheckedCreateWithoutRamsInput> | PCConfigurationCreateWithoutRamsInput[] | PCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutRamsInput | PCConfigurationCreateOrConnectWithoutRamsInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutRamsInput | PCConfigurationUpsertWithWhereUniqueWithoutRamsInput[]
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutRamsInput | PCConfigurationUpdateWithWhereUniqueWithoutRamsInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutRamsInput | PCConfigurationUpdateManyWithWhereWithoutRamsInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutRamsNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutRamsInput, ParcialPCConfigurationUncheckedCreateWithoutRamsInput> | ParcialPCConfigurationCreateWithoutRamsInput[] | ParcialPCConfigurationUncheckedCreateWithoutRamsInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutRamsInput | ParcialPCConfigurationCreateOrConnectWithoutRamsInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutRamsInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutRamsInput[]
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutRamsInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutRamsInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutRamsInput | ParcialPCConfigurationUpdateManyWithWhereWithoutRamsInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutStorageInput = {
    create?: XOR<ComponentCreateWithoutStorageInput, ComponentUncheckedCreateWithoutStorageInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutStorageInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutStoragesInput = {
    create?: XOR<PCConfigurationCreateWithoutStoragesInput, PCConfigurationUncheckedCreateWithoutStoragesInput> | PCConfigurationCreateWithoutStoragesInput[] | PCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutStoragesInput | PCConfigurationCreateOrConnectWithoutStoragesInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutStoragesInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutStoragesInput, ParcialPCConfigurationUncheckedCreateWithoutStoragesInput> | ParcialPCConfigurationCreateWithoutStoragesInput[] | ParcialPCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutStoragesInput | ParcialPCConfigurationCreateOrConnectWithoutStoragesInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutStoragesInput = {
    create?: XOR<PCConfigurationCreateWithoutStoragesInput, PCConfigurationUncheckedCreateWithoutStoragesInput> | PCConfigurationCreateWithoutStoragesInput[] | PCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutStoragesInput | PCConfigurationCreateOrConnectWithoutStoragesInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutStoragesInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutStoragesInput, ParcialPCConfigurationUncheckedCreateWithoutStoragesInput> | ParcialPCConfigurationCreateWithoutStoragesInput[] | ParcialPCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutStoragesInput | ParcialPCConfigurationCreateOrConnectWithoutStoragesInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type ComponentUpdateOneRequiredWithoutStorageNestedInput = {
    create?: XOR<ComponentCreateWithoutStorageInput, ComponentUncheckedCreateWithoutStorageInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutStorageInput
    upsert?: ComponentUpsertWithoutStorageInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutStorageInput, ComponentUpdateWithoutStorageInput>, ComponentUncheckedUpdateWithoutStorageInput>
  }

  export type PCConfigurationUpdateManyWithoutStoragesNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutStoragesInput, PCConfigurationUncheckedCreateWithoutStoragesInput> | PCConfigurationCreateWithoutStoragesInput[] | PCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutStoragesInput | PCConfigurationCreateOrConnectWithoutStoragesInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutStoragesInput | PCConfigurationUpsertWithWhereUniqueWithoutStoragesInput[]
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutStoragesInput | PCConfigurationUpdateWithWhereUniqueWithoutStoragesInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutStoragesInput | PCConfigurationUpdateManyWithWhereWithoutStoragesInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutStoragesNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutStoragesInput, ParcialPCConfigurationUncheckedCreateWithoutStoragesInput> | ParcialPCConfigurationCreateWithoutStoragesInput[] | ParcialPCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutStoragesInput | ParcialPCConfigurationCreateOrConnectWithoutStoragesInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutStoragesInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutStoragesInput[]
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutStoragesInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutStoragesInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutStoragesInput | ParcialPCConfigurationUpdateManyWithWhereWithoutStoragesInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutStoragesInput, PCConfigurationUncheckedCreateWithoutStoragesInput> | PCConfigurationCreateWithoutStoragesInput[] | PCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutStoragesInput | PCConfigurationCreateOrConnectWithoutStoragesInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutStoragesInput | PCConfigurationUpsertWithWhereUniqueWithoutStoragesInput[]
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutStoragesInput | PCConfigurationUpdateWithWhereUniqueWithoutStoragesInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutStoragesInput | PCConfigurationUpdateManyWithWhereWithoutStoragesInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutStoragesInput, ParcialPCConfigurationUncheckedCreateWithoutStoragesInput> | ParcialPCConfigurationCreateWithoutStoragesInput[] | ParcialPCConfigurationUncheckedCreateWithoutStoragesInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutStoragesInput | ParcialPCConfigurationCreateOrConnectWithoutStoragesInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutStoragesInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutStoragesInput[]
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutStoragesInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutStoragesInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutStoragesInput | ParcialPCConfigurationUpdateManyWithWhereWithoutStoragesInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutPowerSupplyInput = {
    create?: XOR<ComponentCreateWithoutPowerSupplyInput, ComponentUncheckedCreateWithoutPowerSupplyInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutPowerSupplyInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutPowerSupplyInput = {
    create?: XOR<PCConfigurationCreateWithoutPowerSupplyInput, PCConfigurationUncheckedCreateWithoutPowerSupplyInput> | PCConfigurationCreateWithoutPowerSupplyInput[] | PCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPowerSupplyInput | PCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    createMany?: PCConfigurationCreateManyPowerSupplyInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutPowerSupplyInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput> | ParcialPCConfigurationCreateWithoutPowerSupplyInput[] | ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput | ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    createMany?: ParcialPCConfigurationCreateManyPowerSupplyInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput = {
    create?: XOR<PCConfigurationCreateWithoutPowerSupplyInput, PCConfigurationUncheckedCreateWithoutPowerSupplyInput> | PCConfigurationCreateWithoutPowerSupplyInput[] | PCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPowerSupplyInput | PCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    createMany?: PCConfigurationCreateManyPowerSupplyInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput> | ParcialPCConfigurationCreateWithoutPowerSupplyInput[] | ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput | ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    createMany?: ParcialPCConfigurationCreateManyPowerSupplyInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type ComponentUpdateOneRequiredWithoutPowerSupplyNestedInput = {
    create?: XOR<ComponentCreateWithoutPowerSupplyInput, ComponentUncheckedCreateWithoutPowerSupplyInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutPowerSupplyInput
    upsert?: ComponentUpsertWithoutPowerSupplyInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutPowerSupplyInput, ComponentUpdateWithoutPowerSupplyInput>, ComponentUncheckedUpdateWithoutPowerSupplyInput>
  }

  export type PCConfigurationUpdateManyWithoutPowerSupplyNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutPowerSupplyInput, PCConfigurationUncheckedCreateWithoutPowerSupplyInput> | PCConfigurationCreateWithoutPowerSupplyInput[] | PCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPowerSupplyInput | PCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput | PCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput[]
    createMany?: PCConfigurationCreateManyPowerSupplyInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput | PCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput | PCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutPowerSupplyNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput> | ParcialPCConfigurationCreateWithoutPowerSupplyInput[] | ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput | ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput[]
    createMany?: ParcialPCConfigurationCreateManyPowerSupplyInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput | ParcialPCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutPowerSupplyInput, PCConfigurationUncheckedCreateWithoutPowerSupplyInput> | PCConfigurationCreateWithoutPowerSupplyInput[] | PCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPowerSupplyInput | PCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput | PCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput[]
    createMany?: PCConfigurationCreateManyPowerSupplyInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput | PCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput | PCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput> | ParcialPCConfigurationCreateWithoutPowerSupplyInput[] | ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput | ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput[]
    createMany?: ParcialPCConfigurationCreateManyPowerSupplyInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput | ParcialPCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type ComponentCreateNestedOneWithoutPcCaseInput = {
    create?: XOR<ComponentCreateWithoutPcCaseInput, ComponentUncheckedCreateWithoutPcCaseInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutPcCaseInput
    connect?: ComponentWhereUniqueInput
  }

  export type PCConfigurationCreateNestedManyWithoutPcCaseInput = {
    create?: XOR<PCConfigurationCreateWithoutPcCaseInput, PCConfigurationUncheckedCreateWithoutPcCaseInput> | PCConfigurationCreateWithoutPcCaseInput[] | PCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPcCaseInput | PCConfigurationCreateOrConnectWithoutPcCaseInput[]
    createMany?: PCConfigurationCreateManyPcCaseInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationCreateNestedManyWithoutPcCaseInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPcCaseInput, ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput> | ParcialPCConfigurationCreateWithoutPcCaseInput[] | ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput | ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput[]
    createMany?: ParcialPCConfigurationCreateManyPcCaseInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type PCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput = {
    create?: XOR<PCConfigurationCreateWithoutPcCaseInput, PCConfigurationUncheckedCreateWithoutPcCaseInput> | PCConfigurationCreateWithoutPcCaseInput[] | PCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPcCaseInput | PCConfigurationCreateOrConnectWithoutPcCaseInput[]
    createMany?: PCConfigurationCreateManyPcCaseInputEnvelope
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
  }

  export type ParcialPCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPcCaseInput, ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput> | ParcialPCConfigurationCreateWithoutPcCaseInput[] | ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput | ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput[]
    createMany?: ParcialPCConfigurationCreateManyPcCaseInputEnvelope
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
  }

  export type ComponentUpdateOneRequiredWithoutPcCaseNestedInput = {
    create?: XOR<ComponentCreateWithoutPcCaseInput, ComponentUncheckedCreateWithoutPcCaseInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutPcCaseInput
    upsert?: ComponentUpsertWithoutPcCaseInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutPcCaseInput, ComponentUpdateWithoutPcCaseInput>, ComponentUncheckedUpdateWithoutPcCaseInput>
  }

  export type PCConfigurationUpdateManyWithoutPcCaseNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutPcCaseInput, PCConfigurationUncheckedCreateWithoutPcCaseInput> | PCConfigurationCreateWithoutPcCaseInput[] | PCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPcCaseInput | PCConfigurationCreateOrConnectWithoutPcCaseInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput | PCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput[]
    createMany?: PCConfigurationCreateManyPcCaseInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput | PCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutPcCaseInput | PCConfigurationUpdateManyWithWhereWithoutPcCaseInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUpdateManyWithoutPcCaseNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPcCaseInput, ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput> | ParcialPCConfigurationCreateWithoutPcCaseInput[] | ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput | ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput[]
    createMany?: ParcialPCConfigurationCreateManyPcCaseInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutPcCaseInput | ParcialPCConfigurationUpdateManyWithWhereWithoutPcCaseInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type PCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput = {
    create?: XOR<PCConfigurationCreateWithoutPcCaseInput, PCConfigurationUncheckedCreateWithoutPcCaseInput> | PCConfigurationCreateWithoutPcCaseInput[] | PCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: PCConfigurationCreateOrConnectWithoutPcCaseInput | PCConfigurationCreateOrConnectWithoutPcCaseInput[]
    upsert?: PCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput | PCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput[]
    createMany?: PCConfigurationCreateManyPcCaseInputEnvelope
    set?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    disconnect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    delete?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    connect?: PCConfigurationWhereUniqueInput | PCConfigurationWhereUniqueInput[]
    update?: PCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput | PCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput[]
    updateMany?: PCConfigurationUpdateManyWithWhereWithoutPcCaseInput | PCConfigurationUpdateManyWithWhereWithoutPcCaseInput[]
    deleteMany?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput = {
    create?: XOR<ParcialPCConfigurationCreateWithoutPcCaseInput, ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput> | ParcialPCConfigurationCreateWithoutPcCaseInput[] | ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput[]
    connectOrCreate?: ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput | ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput[]
    upsert?: ParcialPCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput | ParcialPCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput[]
    createMany?: ParcialPCConfigurationCreateManyPcCaseInputEnvelope
    set?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    disconnect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    delete?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    connect?: ParcialPCConfigurationWhereUniqueInput | ParcialPCConfigurationWhereUniqueInput[]
    update?: ParcialPCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput | ParcialPCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput[]
    updateMany?: ParcialPCConfigurationUpdateManyWithWhereWithoutPcCaseInput | ParcialPCConfigurationUpdateManyWithWhereWithoutPcCaseInput[]
    deleteMany?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
  }

  export type MotherboardCreateNestedOneWithoutPartialInput = {
    create?: XOR<MotherboardCreateWithoutPartialInput, MotherboardUncheckedCreateWithoutPartialInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutPartialInput
    connect?: MotherboardWhereUniqueInput
  }

  export type ProcessorCreateNestedOneWithoutPartialInput = {
    create?: XOR<ProcessorCreateWithoutPartialInput, ProcessorUncheckedCreateWithoutPartialInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutPartialInput
    connect?: ProcessorWhereUniqueInput
  }

  export type RAMCreateNestedManyWithoutPartialInput = {
    create?: XOR<RAMCreateWithoutPartialInput, RAMUncheckedCreateWithoutPartialInput> | RAMCreateWithoutPartialInput[] | RAMUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutPartialInput | RAMCreateOrConnectWithoutPartialInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
  }

  export type GPUCreateNestedOneWithoutPartialInput = {
    create?: XOR<GPUCreateWithoutPartialInput, GPUUncheckedCreateWithoutPartialInput>
    connectOrCreate?: GPUCreateOrConnectWithoutPartialInput
    connect?: GPUWhereUniqueInput
  }

  export type StorageCreateNestedManyWithoutPartialInput = {
    create?: XOR<StorageCreateWithoutPartialInput, StorageUncheckedCreateWithoutPartialInput> | StorageCreateWithoutPartialInput[] | StorageUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutPartialInput | StorageCreateOrConnectWithoutPartialInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type PowerSupplyCreateNestedOneWithoutPartialInput = {
    create?: XOR<PowerSupplyCreateWithoutPartialInput, PowerSupplyUncheckedCreateWithoutPartialInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutPartialInput
    connect?: PowerSupplyWhereUniqueInput
  }

  export type PCCaseCreateNestedOneWithoutPartialInput = {
    create?: XOR<PCCaseCreateWithoutPartialInput, PCCaseUncheckedCreateWithoutPartialInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutPartialInput
    connect?: PCCaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPartialUserConfigurationInput = {
    create?: XOR<UserCreateWithoutPartialUserConfigurationInput, UserUncheckedCreateWithoutPartialUserConfigurationInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartialUserConfigurationInput
    connect?: UserWhereUniqueInput
  }

  export type RAMUncheckedCreateNestedManyWithoutPartialInput = {
    create?: XOR<RAMCreateWithoutPartialInput, RAMUncheckedCreateWithoutPartialInput> | RAMCreateWithoutPartialInput[] | RAMUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutPartialInput | RAMCreateOrConnectWithoutPartialInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
  }

  export type StorageUncheckedCreateNestedManyWithoutPartialInput = {
    create?: XOR<StorageCreateWithoutPartialInput, StorageUncheckedCreateWithoutPartialInput> | StorageCreateWithoutPartialInput[] | StorageUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutPartialInput | StorageCreateOrConnectWithoutPartialInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type EnumConfigurationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConfigurationType
  }

  export type MotherboardUpdateOneWithoutPartialNestedInput = {
    create?: XOR<MotherboardCreateWithoutPartialInput, MotherboardUncheckedCreateWithoutPartialInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutPartialInput
    upsert?: MotherboardUpsertWithoutPartialInput
    disconnect?: MotherboardWhereInput | boolean
    delete?: MotherboardWhereInput | boolean
    connect?: MotherboardWhereUniqueInput
    update?: XOR<XOR<MotherboardUpdateToOneWithWhereWithoutPartialInput, MotherboardUpdateWithoutPartialInput>, MotherboardUncheckedUpdateWithoutPartialInput>
  }

  export type ProcessorUpdateOneWithoutPartialNestedInput = {
    create?: XOR<ProcessorCreateWithoutPartialInput, ProcessorUncheckedCreateWithoutPartialInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutPartialInput
    upsert?: ProcessorUpsertWithoutPartialInput
    disconnect?: ProcessorWhereInput | boolean
    delete?: ProcessorWhereInput | boolean
    connect?: ProcessorWhereUniqueInput
    update?: XOR<XOR<ProcessorUpdateToOneWithWhereWithoutPartialInput, ProcessorUpdateWithoutPartialInput>, ProcessorUncheckedUpdateWithoutPartialInput>
  }

  export type RAMUpdateManyWithoutPartialNestedInput = {
    create?: XOR<RAMCreateWithoutPartialInput, RAMUncheckedCreateWithoutPartialInput> | RAMCreateWithoutPartialInput[] | RAMUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutPartialInput | RAMCreateOrConnectWithoutPartialInput[]
    upsert?: RAMUpsertWithWhereUniqueWithoutPartialInput | RAMUpsertWithWhereUniqueWithoutPartialInput[]
    set?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    disconnect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    delete?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    update?: RAMUpdateWithWhereUniqueWithoutPartialInput | RAMUpdateWithWhereUniqueWithoutPartialInput[]
    updateMany?: RAMUpdateManyWithWhereWithoutPartialInput | RAMUpdateManyWithWhereWithoutPartialInput[]
    deleteMany?: RAMScalarWhereInput | RAMScalarWhereInput[]
  }

  export type GPUUpdateOneWithoutPartialNestedInput = {
    create?: XOR<GPUCreateWithoutPartialInput, GPUUncheckedCreateWithoutPartialInput>
    connectOrCreate?: GPUCreateOrConnectWithoutPartialInput
    upsert?: GPUUpsertWithoutPartialInput
    disconnect?: GPUWhereInput | boolean
    delete?: GPUWhereInput | boolean
    connect?: GPUWhereUniqueInput
    update?: XOR<XOR<GPUUpdateToOneWithWhereWithoutPartialInput, GPUUpdateWithoutPartialInput>, GPUUncheckedUpdateWithoutPartialInput>
  }

  export type StorageUpdateManyWithoutPartialNestedInput = {
    create?: XOR<StorageCreateWithoutPartialInput, StorageUncheckedCreateWithoutPartialInput> | StorageCreateWithoutPartialInput[] | StorageUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutPartialInput | StorageCreateOrConnectWithoutPartialInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutPartialInput | StorageUpsertWithWhereUniqueWithoutPartialInput[]
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutPartialInput | StorageUpdateWithWhereUniqueWithoutPartialInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutPartialInput | StorageUpdateManyWithWhereWithoutPartialInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type PowerSupplyUpdateOneWithoutPartialNestedInput = {
    create?: XOR<PowerSupplyCreateWithoutPartialInput, PowerSupplyUncheckedCreateWithoutPartialInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutPartialInput
    upsert?: PowerSupplyUpsertWithoutPartialInput
    disconnect?: PowerSupplyWhereInput | boolean
    delete?: PowerSupplyWhereInput | boolean
    connect?: PowerSupplyWhereUniqueInput
    update?: XOR<XOR<PowerSupplyUpdateToOneWithWhereWithoutPartialInput, PowerSupplyUpdateWithoutPartialInput>, PowerSupplyUncheckedUpdateWithoutPartialInput>
  }

  export type PCCaseUpdateOneWithoutPartialNestedInput = {
    create?: XOR<PCCaseCreateWithoutPartialInput, PCCaseUncheckedCreateWithoutPartialInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutPartialInput
    upsert?: PCCaseUpsertWithoutPartialInput
    disconnect?: PCCaseWhereInput | boolean
    delete?: PCCaseWhereInput | boolean
    connect?: PCCaseWhereUniqueInput
    update?: XOR<XOR<PCCaseUpdateToOneWithWhereWithoutPartialInput, PCCaseUpdateWithoutPartialInput>, PCCaseUncheckedUpdateWithoutPartialInput>
  }

  export type UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput = {
    create?: XOR<UserCreateWithoutPartialUserConfigurationInput, UserUncheckedCreateWithoutPartialUserConfigurationInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartialUserConfigurationInput
    upsert?: UserUpsertWithoutPartialUserConfigurationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPartialUserConfigurationInput, UserUpdateWithoutPartialUserConfigurationInput>, UserUncheckedUpdateWithoutPartialUserConfigurationInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RAMUncheckedUpdateManyWithoutPartialNestedInput = {
    create?: XOR<RAMCreateWithoutPartialInput, RAMUncheckedCreateWithoutPartialInput> | RAMCreateWithoutPartialInput[] | RAMUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutPartialInput | RAMCreateOrConnectWithoutPartialInput[]
    upsert?: RAMUpsertWithWhereUniqueWithoutPartialInput | RAMUpsertWithWhereUniqueWithoutPartialInput[]
    set?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    disconnect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    delete?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    update?: RAMUpdateWithWhereUniqueWithoutPartialInput | RAMUpdateWithWhereUniqueWithoutPartialInput[]
    updateMany?: RAMUpdateManyWithWhereWithoutPartialInput | RAMUpdateManyWithWhereWithoutPartialInput[]
    deleteMany?: RAMScalarWhereInput | RAMScalarWhereInput[]
  }

  export type StorageUncheckedUpdateManyWithoutPartialNestedInput = {
    create?: XOR<StorageCreateWithoutPartialInput, StorageUncheckedCreateWithoutPartialInput> | StorageCreateWithoutPartialInput[] | StorageUncheckedCreateWithoutPartialInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutPartialInput | StorageCreateOrConnectWithoutPartialInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutPartialInput | StorageUpsertWithWhereUniqueWithoutPartialInput[]
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutPartialInput | StorageUpdateWithWhereUniqueWithoutPartialInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutPartialInput | StorageUpdateManyWithWhereWithoutPartialInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type MotherboardCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<MotherboardCreateWithoutConfigurationsInput, MotherboardUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutConfigurationsInput
    connect?: MotherboardWhereUniqueInput
  }

  export type ProcessorCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<ProcessorCreateWithoutConfigurationsInput, ProcessorUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutConfigurationsInput
    connect?: ProcessorWhereUniqueInput
  }

  export type RAMCreateNestedManyWithoutConfigurationsInput = {
    create?: XOR<RAMCreateWithoutConfigurationsInput, RAMUncheckedCreateWithoutConfigurationsInput> | RAMCreateWithoutConfigurationsInput[] | RAMUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutConfigurationsInput | RAMCreateOrConnectWithoutConfigurationsInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
  }

  export type GPUCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<GPUCreateWithoutConfigurationsInput, GPUUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: GPUCreateOrConnectWithoutConfigurationsInput
    connect?: GPUWhereUniqueInput
  }

  export type StorageCreateNestedManyWithoutConfigurationsInput = {
    create?: XOR<StorageCreateWithoutConfigurationsInput, StorageUncheckedCreateWithoutConfigurationsInput> | StorageCreateWithoutConfigurationsInput[] | StorageUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutConfigurationsInput | StorageCreateOrConnectWithoutConfigurationsInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type PowerSupplyCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<PowerSupplyCreateWithoutConfigurationsInput, PowerSupplyUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutConfigurationsInput
    connect?: PowerSupplyWhereUniqueInput
  }

  export type PCCaseCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<PCCaseCreateWithoutConfigurationsInput, PCCaseUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutConfigurationsInput
    connect?: PCCaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserconfigurationsInput = {
    create?: XOR<UserCreateWithoutUserconfigurationsInput, UserUncheckedCreateWithoutUserconfigurationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserconfigurationsInput
    connect?: UserWhereUniqueInput
  }

  export type RAMUncheckedCreateNestedManyWithoutConfigurationsInput = {
    create?: XOR<RAMCreateWithoutConfigurationsInput, RAMUncheckedCreateWithoutConfigurationsInput> | RAMCreateWithoutConfigurationsInput[] | RAMUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutConfigurationsInput | RAMCreateOrConnectWithoutConfigurationsInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
  }

  export type StorageUncheckedCreateNestedManyWithoutConfigurationsInput = {
    create?: XOR<StorageCreateWithoutConfigurationsInput, StorageUncheckedCreateWithoutConfigurationsInput> | StorageCreateWithoutConfigurationsInput[] | StorageUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutConfigurationsInput | StorageCreateOrConnectWithoutConfigurationsInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<MotherboardCreateWithoutConfigurationsInput, MotherboardUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: MotherboardCreateOrConnectWithoutConfigurationsInput
    upsert?: MotherboardUpsertWithoutConfigurationsInput
    connect?: MotherboardWhereUniqueInput
    update?: XOR<XOR<MotherboardUpdateToOneWithWhereWithoutConfigurationsInput, MotherboardUpdateWithoutConfigurationsInput>, MotherboardUncheckedUpdateWithoutConfigurationsInput>
  }

  export type ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<ProcessorCreateWithoutConfigurationsInput, ProcessorUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: ProcessorCreateOrConnectWithoutConfigurationsInput
    upsert?: ProcessorUpsertWithoutConfigurationsInput
    connect?: ProcessorWhereUniqueInput
    update?: XOR<XOR<ProcessorUpdateToOneWithWhereWithoutConfigurationsInput, ProcessorUpdateWithoutConfigurationsInput>, ProcessorUncheckedUpdateWithoutConfigurationsInput>
  }

  export type RAMUpdateManyWithoutConfigurationsNestedInput = {
    create?: XOR<RAMCreateWithoutConfigurationsInput, RAMUncheckedCreateWithoutConfigurationsInput> | RAMCreateWithoutConfigurationsInput[] | RAMUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutConfigurationsInput | RAMCreateOrConnectWithoutConfigurationsInput[]
    upsert?: RAMUpsertWithWhereUniqueWithoutConfigurationsInput | RAMUpsertWithWhereUniqueWithoutConfigurationsInput[]
    set?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    disconnect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    delete?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    update?: RAMUpdateWithWhereUniqueWithoutConfigurationsInput | RAMUpdateWithWhereUniqueWithoutConfigurationsInput[]
    updateMany?: RAMUpdateManyWithWhereWithoutConfigurationsInput | RAMUpdateManyWithWhereWithoutConfigurationsInput[]
    deleteMany?: RAMScalarWhereInput | RAMScalarWhereInput[]
  }

  export type GPUUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<GPUCreateWithoutConfigurationsInput, GPUUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: GPUCreateOrConnectWithoutConfigurationsInput
    upsert?: GPUUpsertWithoutConfigurationsInput
    connect?: GPUWhereUniqueInput
    update?: XOR<XOR<GPUUpdateToOneWithWhereWithoutConfigurationsInput, GPUUpdateWithoutConfigurationsInput>, GPUUncheckedUpdateWithoutConfigurationsInput>
  }

  export type StorageUpdateManyWithoutConfigurationsNestedInput = {
    create?: XOR<StorageCreateWithoutConfigurationsInput, StorageUncheckedCreateWithoutConfigurationsInput> | StorageCreateWithoutConfigurationsInput[] | StorageUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutConfigurationsInput | StorageCreateOrConnectWithoutConfigurationsInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutConfigurationsInput | StorageUpsertWithWhereUniqueWithoutConfigurationsInput[]
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutConfigurationsInput | StorageUpdateWithWhereUniqueWithoutConfigurationsInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutConfigurationsInput | StorageUpdateManyWithWhereWithoutConfigurationsInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<PowerSupplyCreateWithoutConfigurationsInput, PowerSupplyUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: PowerSupplyCreateOrConnectWithoutConfigurationsInput
    upsert?: PowerSupplyUpsertWithoutConfigurationsInput
    connect?: PowerSupplyWhereUniqueInput
    update?: XOR<XOR<PowerSupplyUpdateToOneWithWhereWithoutConfigurationsInput, PowerSupplyUpdateWithoutConfigurationsInput>, PowerSupplyUncheckedUpdateWithoutConfigurationsInput>
  }

  export type PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<PCCaseCreateWithoutConfigurationsInput, PCCaseUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: PCCaseCreateOrConnectWithoutConfigurationsInput
    upsert?: PCCaseUpsertWithoutConfigurationsInput
    connect?: PCCaseWhereUniqueInput
    update?: XOR<XOR<PCCaseUpdateToOneWithWhereWithoutConfigurationsInput, PCCaseUpdateWithoutConfigurationsInput>, PCCaseUncheckedUpdateWithoutConfigurationsInput>
  }

  export type UserUpdateOneRequiredWithoutUserconfigurationsNestedInput = {
    create?: XOR<UserCreateWithoutUserconfigurationsInput, UserUncheckedCreateWithoutUserconfigurationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserconfigurationsInput
    upsert?: UserUpsertWithoutUserconfigurationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserconfigurationsInput, UserUpdateWithoutUserconfigurationsInput>, UserUncheckedUpdateWithoutUserconfigurationsInput>
  }

  export type RAMUncheckedUpdateManyWithoutConfigurationsNestedInput = {
    create?: XOR<RAMCreateWithoutConfigurationsInput, RAMUncheckedCreateWithoutConfigurationsInput> | RAMCreateWithoutConfigurationsInput[] | RAMUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: RAMCreateOrConnectWithoutConfigurationsInput | RAMCreateOrConnectWithoutConfigurationsInput[]
    upsert?: RAMUpsertWithWhereUniqueWithoutConfigurationsInput | RAMUpsertWithWhereUniqueWithoutConfigurationsInput[]
    set?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    disconnect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    delete?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    connect?: RAMWhereUniqueInput | RAMWhereUniqueInput[]
    update?: RAMUpdateWithWhereUniqueWithoutConfigurationsInput | RAMUpdateWithWhereUniqueWithoutConfigurationsInput[]
    updateMany?: RAMUpdateManyWithWhereWithoutConfigurationsInput | RAMUpdateManyWithWhereWithoutConfigurationsInput[]
    deleteMany?: RAMScalarWhereInput | RAMScalarWhereInput[]
  }

  export type StorageUncheckedUpdateManyWithoutConfigurationsNestedInput = {
    create?: XOR<StorageCreateWithoutConfigurationsInput, StorageUncheckedCreateWithoutConfigurationsInput> | StorageCreateWithoutConfigurationsInput[] | StorageUncheckedCreateWithoutConfigurationsInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutConfigurationsInput | StorageCreateOrConnectWithoutConfigurationsInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutConfigurationsInput | StorageUpsertWithWhereUniqueWithoutConfigurationsInput[]
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutConfigurationsInput | StorageUpdateWithWhereUniqueWithoutConfigurationsInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutConfigurationsInput | StorageUpdateManyWithWhereWithoutConfigurationsInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumComponentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentType | EnumComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentTypeFilter<$PrismaModel> | $Enums.ComponentType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumComponentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentType | EnumComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentType[] | ListEnumComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ComponentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComponentTypeFilter<$PrismaModel>
    _max?: NestedEnumComponentTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumComputerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ComputerType | EnumComputerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComputerTypeFilter<$PrismaModel> | $Enums.ComputerType
  }

  export type NestedEnumComputerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComputerType | EnumComputerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComputerType[] | ListEnumComputerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComputerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ComputerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComputerTypeFilter<$PrismaModel>
    _max?: NestedEnumComputerTypeFilter<$PrismaModel>
  }

  export type NestedEnumConfigurationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigurationType | EnumConfigurationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigurationTypeFilter<$PrismaModel> | $Enums.ConfigurationType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumConfigurationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigurationType | EnumConfigurationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfigurationType[] | ListEnumConfigurationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigurationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConfigurationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfigurationTypeFilter<$PrismaModel>
    _max?: NestedEnumConfigurationTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    userconfigurations?: PCConfigurationCreateNestedManyWithoutUserInput
    partialUserConfiguration?: ParcialPCConfigurationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    userconfigurations?: PCConfigurationUncheckedCreateNestedManyWithoutUserInput
    partialUserConfiguration?: ParcialPCConfigurationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    userconfigurations?: PCConfigurationUpdateManyWithoutUserNestedInput
    partialUserConfiguration?: ParcialPCConfigurationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    userconfigurations?: PCConfigurationUncheckedUpdateManyWithoutUserNestedInput
    partialUserConfiguration?: ParcialPCConfigurationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type MotherboardCreateWithoutComponentInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutMotherboardInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardUncheckedCreateWithoutComponentInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardCreateOrConnectWithoutComponentInput = {
    where: MotherboardWhereUniqueInput
    create: XOR<MotherboardCreateWithoutComponentInput, MotherboardUncheckedCreateWithoutComponentInput>
  }

  export type ProcessorCreateWithoutComponentInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutProcessorInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorUncheckedCreateWithoutComponentInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutProcessorInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorCreateOrConnectWithoutComponentInput = {
    where: ProcessorWhereUniqueInput
    create: XOR<ProcessorCreateWithoutComponentInput, ProcessorUncheckedCreateWithoutComponentInput>
  }

  export type GPUCreateWithoutComponentInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutGpuInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutGpuInput
  }

  export type GPUUncheckedCreateWithoutComponentInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutGpuInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutGpuInput
  }

  export type GPUCreateOrConnectWithoutComponentInput = {
    where: GPUWhereUniqueInput
    create: XOR<GPUCreateWithoutComponentInput, GPUUncheckedCreateWithoutComponentInput>
  }

  export type RAMCreateWithoutComponentInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutRamsInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutRamsInput
  }

  export type RAMUncheckedCreateWithoutComponentInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutRamsInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutRamsInput
  }

  export type RAMCreateOrConnectWithoutComponentInput = {
    where: RAMWhereUniqueInput
    create: XOR<RAMCreateWithoutComponentInput, RAMUncheckedCreateWithoutComponentInput>
  }

  export type StorageCreateWithoutComponentInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutStoragesInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutStoragesInput
  }

  export type StorageUncheckedCreateWithoutComponentInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutStoragesInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutStoragesInput
  }

  export type StorageCreateOrConnectWithoutComponentInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutComponentInput, StorageUncheckedCreateWithoutComponentInput>
  }

  export type PowerSupplyCreateWithoutComponentInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutPowerSupplyInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyUncheckedCreateWithoutComponentInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyCreateOrConnectWithoutComponentInput = {
    where: PowerSupplyWhereUniqueInput
    create: XOR<PowerSupplyCreateWithoutComponentInput, PowerSupplyUncheckedCreateWithoutComponentInput>
  }

  export type PCCaseCreateWithoutComponentInput = {
    id?: string
    formFactor: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationCreateNestedManyWithoutPcCaseInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseUncheckedCreateWithoutComponentInput = {
    id?: string
    formFactor: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseCreateOrConnectWithoutComponentInput = {
    where: PCCaseWhereUniqueInput
    create: XOR<PCCaseCreateWithoutComponentInput, PCCaseUncheckedCreateWithoutComponentInput>
  }

  export type MotherboardUpsertWithoutComponentInput = {
    update: XOR<MotherboardUpdateWithoutComponentInput, MotherboardUncheckedUpdateWithoutComponentInput>
    create: XOR<MotherboardCreateWithoutComponentInput, MotherboardUncheckedCreateWithoutComponentInput>
    where?: MotherboardWhereInput
  }

  export type MotherboardUpdateToOneWithWhereWithoutComponentInput = {
    where?: MotherboardWhereInput
    data: XOR<MotherboardUpdateWithoutComponentInput, MotherboardUncheckedUpdateWithoutComponentInput>
  }

  export type MotherboardUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutMotherboardNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutMotherboardNestedInput
  }

  export type MotherboardUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput
  }

  export type ProcessorUpsertWithoutComponentInput = {
    update: XOR<ProcessorUpdateWithoutComponentInput, ProcessorUncheckedUpdateWithoutComponentInput>
    create: XOR<ProcessorCreateWithoutComponentInput, ProcessorUncheckedCreateWithoutComponentInput>
    where?: ProcessorWhereInput
  }

  export type ProcessorUpdateToOneWithWhereWithoutComponentInput = {
    where?: ProcessorWhereInput
    data: XOR<ProcessorUpdateWithoutComponentInput, ProcessorUncheckedUpdateWithoutComponentInput>
  }

  export type ProcessorUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutProcessorNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutProcessorNestedInput
  }

  export type ProcessorUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput
  }

  export type GPUUpsertWithoutComponentInput = {
    update: XOR<GPUUpdateWithoutComponentInput, GPUUncheckedUpdateWithoutComponentInput>
    create: XOR<GPUCreateWithoutComponentInput, GPUUncheckedCreateWithoutComponentInput>
    where?: GPUWhereInput
  }

  export type GPUUpdateToOneWithWhereWithoutComponentInput = {
    where?: GPUWhereInput
    data: XOR<GPUUpdateWithoutComponentInput, GPUUncheckedUpdateWithoutComponentInput>
  }

  export type GPUUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutGpuNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutGpuNestedInput
  }

  export type GPUUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutGpuNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutGpuNestedInput
  }

  export type RAMUpsertWithoutComponentInput = {
    update: XOR<RAMUpdateWithoutComponentInput, RAMUncheckedUpdateWithoutComponentInput>
    create: XOR<RAMCreateWithoutComponentInput, RAMUncheckedCreateWithoutComponentInput>
    where?: RAMWhereInput
  }

  export type RAMUpdateToOneWithWhereWithoutComponentInput = {
    where?: RAMWhereInput
    data: XOR<RAMUpdateWithoutComponentInput, RAMUncheckedUpdateWithoutComponentInput>
  }

  export type RAMUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutRamsNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutRamsNestedInput
  }

  export type RAMUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutRamsNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutRamsNestedInput
  }

  export type StorageUpsertWithoutComponentInput = {
    update: XOR<StorageUpdateWithoutComponentInput, StorageUncheckedUpdateWithoutComponentInput>
    create: XOR<StorageCreateWithoutComponentInput, StorageUncheckedCreateWithoutComponentInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutComponentInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutComponentInput, StorageUncheckedUpdateWithoutComponentInput>
  }

  export type StorageUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutStoragesNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutStoragesNestedInput
  }

  export type StorageUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput
  }

  export type PowerSupplyUpsertWithoutComponentInput = {
    update: XOR<PowerSupplyUpdateWithoutComponentInput, PowerSupplyUncheckedUpdateWithoutComponentInput>
    create: XOR<PowerSupplyCreateWithoutComponentInput, PowerSupplyUncheckedCreateWithoutComponentInput>
    where?: PowerSupplyWhereInput
  }

  export type PowerSupplyUpdateToOneWithWhereWithoutComponentInput = {
    where?: PowerSupplyWhereInput
    data: XOR<PowerSupplyUpdateWithoutComponentInput, PowerSupplyUncheckedUpdateWithoutComponentInput>
  }

  export type PowerSupplyUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutPowerSupplyNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PowerSupplyUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PCCaseUpsertWithoutComponentInput = {
    update: XOR<PCCaseUpdateWithoutComponentInput, PCCaseUncheckedUpdateWithoutComponentInput>
    create: XOR<PCCaseCreateWithoutComponentInput, PCCaseUncheckedCreateWithoutComponentInput>
    where?: PCCaseWhereInput
  }

  export type PCCaseUpdateToOneWithWhereWithoutComponentInput = {
    where?: PCCaseWhereInput
    data: XOR<PCCaseUpdateWithoutComponentInput, PCCaseUncheckedUpdateWithoutComponentInput>
  }

  export type PCCaseUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUpdateManyWithoutPcCaseNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutPcCaseNestedInput
  }

  export type PCCaseUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput
  }

  export type PCConfigurationCreateWithoutUserInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutUserInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutUserInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutUserInput, PCConfigurationUncheckedCreateWithoutUserInput>
  }

  export type PCConfigurationCreateManyUserInputEnvelope = {
    data: PCConfigurationCreateManyUserInput | PCConfigurationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ParcialPCConfigurationCreateWithoutUserInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutUserInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutUserInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutUserInput, ParcialPCConfigurationUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    userType: $Enums.UserType
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    userType: $Enums.UserType
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutUserInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutUserInput, PCConfigurationUncheckedUpdateWithoutUserInput>
    create: XOR<PCConfigurationCreateWithoutUserInput, PCConfigurationUncheckedCreateWithoutUserInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutUserInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutUserInput, PCConfigurationUncheckedUpdateWithoutUserInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutUserInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutUserInput>
  }

  export type PCConfigurationScalarWhereInput = {
    AND?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
    OR?: PCConfigurationScalarWhereInput[]
    NOT?: PCConfigurationScalarWhereInput | PCConfigurationScalarWhereInput[]
    id?: StringFilter<"PCConfiguration"> | string
    totalPrice?: FloatFilter<"PCConfiguration"> | number
    configurationType?: EnumConfigurationTypeFilter<"PCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringFilter<"PCConfiguration"> | string
    processorId?: StringFilter<"PCConfiguration"> | string
    gpuId?: StringFilter<"PCConfiguration"> | string
    powerSupplyId?: StringFilter<"PCConfiguration"> | string
    pcCaseId?: StringFilter<"PCConfiguration"> | string
    userId?: StringFilter<"PCConfiguration"> | string
    createdAt?: DateTimeFilter<"PCConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"PCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PCConfiguration"> | Date | string | null
  }

  export type ParcialPCConfigurationUpsertWithoutUserInput = {
    update: XOR<ParcialPCConfigurationUpdateWithoutUserInput, ParcialPCConfigurationUncheckedUpdateWithoutUserInput>
    create: XOR<ParcialPCConfigurationCreateWithoutUserInput, ParcialPCConfigurationUncheckedCreateWithoutUserInput>
    where?: ParcialPCConfigurationWhereInput
  }

  export type ParcialPCConfigurationUpdateToOneWithWhereWithoutUserInput = {
    where?: ParcialPCConfigurationWhereInput
    data: XOR<ParcialPCConfigurationUpdateWithoutUserInput, ParcialPCConfigurationUncheckedUpdateWithoutUserInput>
  }

  export type ParcialPCConfigurationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userId?: StringFilter<"Session"> | string
    userType?: EnumUserTypeFilter<"Session"> | $Enums.UserType
  }

  export type ComponentCreateWithoutMotherboardInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutMotherboardInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutMotherboardInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutMotherboardInput, ComponentUncheckedCreateWithoutMotherboardInput>
  }

  export type PCConfigurationCreateWithoutMotherboardInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutMotherboardInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutMotherboardInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutMotherboardInput, PCConfigurationUncheckedCreateWithoutMotherboardInput>
  }

  export type PCConfigurationCreateManyMotherboardInputEnvelope = {
    data: PCConfigurationCreateManyMotherboardInput | PCConfigurationCreateManyMotherboardInput[]
    skipDuplicates?: boolean
  }

  export type ParcialPCConfigurationCreateWithoutMotherboardInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutMotherboardInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutMotherboardInput, ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput>
  }

  export type ParcialPCConfigurationCreateManyMotherboardInputEnvelope = {
    data: ParcialPCConfigurationCreateManyMotherboardInput | ParcialPCConfigurationCreateManyMotherboardInput[]
    skipDuplicates?: boolean
  }

  export type ComponentUpsertWithoutMotherboardInput = {
    update: XOR<ComponentUpdateWithoutMotherboardInput, ComponentUncheckedUpdateWithoutMotherboardInput>
    create: XOR<ComponentCreateWithoutMotherboardInput, ComponentUncheckedCreateWithoutMotherboardInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutMotherboardInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutMotherboardInput, ComponentUncheckedUpdateWithoutMotherboardInput>
  }

  export type ComponentUpdateWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutMotherboardInput, PCConfigurationUncheckedUpdateWithoutMotherboardInput>
    create: XOR<PCConfigurationCreateWithoutMotherboardInput, PCConfigurationUncheckedCreateWithoutMotherboardInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutMotherboardInput, PCConfigurationUncheckedUpdateWithoutMotherboardInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutMotherboardInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutMotherboardInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutMotherboardInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutMotherboardInput, ParcialPCConfigurationUncheckedUpdateWithoutMotherboardInput>
    create: XOR<ParcialPCConfigurationCreateWithoutMotherboardInput, ParcialPCConfigurationUncheckedCreateWithoutMotherboardInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutMotherboardInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutMotherboardInput, ParcialPCConfigurationUncheckedUpdateWithoutMotherboardInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutMotherboardInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutMotherboardInput>
  }

  export type ParcialPCConfigurationScalarWhereInput = {
    AND?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
    OR?: ParcialPCConfigurationScalarWhereInput[]
    NOT?: ParcialPCConfigurationScalarWhereInput | ParcialPCConfigurationScalarWhereInput[]
    id?: StringFilter<"ParcialPCConfiguration"> | string
    configurationType?: EnumConfigurationTypeFilter<"ParcialPCConfiguration"> | $Enums.ConfigurationType
    motherboardId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    processorId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    gpuId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    powerSupplyId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    pcCaseId?: StringNullableFilter<"ParcialPCConfiguration"> | string | null
    userId?: StringFilter<"ParcialPCConfiguration"> | string
    createdAt?: DateTimeFilter<"ParcialPCConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ParcialPCConfiguration"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ParcialPCConfiguration"> | Date | string | null
  }

  export type ComponentCreateWithoutProcessorInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutProcessorInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutProcessorInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutProcessorInput, ComponentUncheckedCreateWithoutProcessorInput>
  }

  export type PCConfigurationCreateWithoutProcessorInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutProcessorInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutProcessorInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutProcessorInput, PCConfigurationUncheckedCreateWithoutProcessorInput>
  }

  export type PCConfigurationCreateManyProcessorInputEnvelope = {
    data: PCConfigurationCreateManyProcessorInput | PCConfigurationCreateManyProcessorInput[]
    skipDuplicates?: boolean
  }

  export type ParcialPCConfigurationCreateWithoutProcessorInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutProcessorInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutProcessorInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutProcessorInput, ParcialPCConfigurationUncheckedCreateWithoutProcessorInput>
  }

  export type ParcialPCConfigurationCreateManyProcessorInputEnvelope = {
    data: ParcialPCConfigurationCreateManyProcessorInput | ParcialPCConfigurationCreateManyProcessorInput[]
    skipDuplicates?: boolean
  }

  export type ComponentUpsertWithoutProcessorInput = {
    update: XOR<ComponentUpdateWithoutProcessorInput, ComponentUncheckedUpdateWithoutProcessorInput>
    create: XOR<ComponentCreateWithoutProcessorInput, ComponentUncheckedCreateWithoutProcessorInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutProcessorInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutProcessorInput, ComponentUncheckedUpdateWithoutProcessorInput>
  }

  export type ComponentUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutProcessorInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutProcessorInput, PCConfigurationUncheckedUpdateWithoutProcessorInput>
    create: XOR<PCConfigurationCreateWithoutProcessorInput, PCConfigurationUncheckedCreateWithoutProcessorInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutProcessorInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutProcessorInput, PCConfigurationUncheckedUpdateWithoutProcessorInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutProcessorInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutProcessorInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutProcessorInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutProcessorInput, ParcialPCConfigurationUncheckedUpdateWithoutProcessorInput>
    create: XOR<ParcialPCConfigurationCreateWithoutProcessorInput, ParcialPCConfigurationUncheckedCreateWithoutProcessorInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutProcessorInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutProcessorInput, ParcialPCConfigurationUncheckedUpdateWithoutProcessorInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutProcessorInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutProcessorInput>
  }

  export type ComponentCreateWithoutGpuInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutGpuInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutGpuInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutGpuInput, ComponentUncheckedCreateWithoutGpuInput>
  }

  export type PCConfigurationCreateWithoutGpuInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutGpuInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutGpuInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutGpuInput, PCConfigurationUncheckedCreateWithoutGpuInput>
  }

  export type PCConfigurationCreateManyGpuInputEnvelope = {
    data: PCConfigurationCreateManyGpuInput | PCConfigurationCreateManyGpuInput[]
    skipDuplicates?: boolean
  }

  export type ParcialPCConfigurationCreateWithoutGpuInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutGpuInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutGpuInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutGpuInput, ParcialPCConfigurationUncheckedCreateWithoutGpuInput>
  }

  export type ParcialPCConfigurationCreateManyGpuInputEnvelope = {
    data: ParcialPCConfigurationCreateManyGpuInput | ParcialPCConfigurationCreateManyGpuInput[]
    skipDuplicates?: boolean
  }

  export type ComponentUpsertWithoutGpuInput = {
    update: XOR<ComponentUpdateWithoutGpuInput, ComponentUncheckedUpdateWithoutGpuInput>
    create: XOR<ComponentCreateWithoutGpuInput, ComponentUncheckedCreateWithoutGpuInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutGpuInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutGpuInput, ComponentUncheckedUpdateWithoutGpuInput>
  }

  export type ComponentUpdateWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutGpuInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutGpuInput, PCConfigurationUncheckedUpdateWithoutGpuInput>
    create: XOR<PCConfigurationCreateWithoutGpuInput, PCConfigurationUncheckedCreateWithoutGpuInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutGpuInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutGpuInput, PCConfigurationUncheckedUpdateWithoutGpuInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutGpuInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutGpuInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutGpuInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutGpuInput, ParcialPCConfigurationUncheckedUpdateWithoutGpuInput>
    create: XOR<ParcialPCConfigurationCreateWithoutGpuInput, ParcialPCConfigurationUncheckedCreateWithoutGpuInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutGpuInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutGpuInput, ParcialPCConfigurationUncheckedUpdateWithoutGpuInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutGpuInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutGpuInput>
  }

  export type ComponentCreateWithoutRamInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutRamInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutRamInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutRamInput, ComponentUncheckedCreateWithoutRamInput>
  }

  export type PCConfigurationCreateWithoutRamsInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutRamsInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutRamsInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutRamsInput, PCConfigurationUncheckedCreateWithoutRamsInput>
  }

  export type ParcialPCConfigurationCreateWithoutRamsInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutRamsInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutRamsInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutRamsInput, ParcialPCConfigurationUncheckedCreateWithoutRamsInput>
  }

  export type ComponentUpsertWithoutRamInput = {
    update: XOR<ComponentUpdateWithoutRamInput, ComponentUncheckedUpdateWithoutRamInput>
    create: XOR<ComponentCreateWithoutRamInput, ComponentUncheckedCreateWithoutRamInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutRamInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutRamInput, ComponentUncheckedUpdateWithoutRamInput>
  }

  export type ComponentUpdateWithoutRamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutRamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutRamsInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutRamsInput, PCConfigurationUncheckedUpdateWithoutRamsInput>
    create: XOR<PCConfigurationCreateWithoutRamsInput, PCConfigurationUncheckedCreateWithoutRamsInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutRamsInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutRamsInput, PCConfigurationUncheckedUpdateWithoutRamsInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutRamsInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutRamsInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutRamsInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutRamsInput, ParcialPCConfigurationUncheckedUpdateWithoutRamsInput>
    create: XOR<ParcialPCConfigurationCreateWithoutRamsInput, ParcialPCConfigurationUncheckedCreateWithoutRamsInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutRamsInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutRamsInput, ParcialPCConfigurationUncheckedUpdateWithoutRamsInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutRamsInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutRamsInput>
  }

  export type ComponentCreateWithoutStorageInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutStorageInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutStorageInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutStorageInput, ComponentUncheckedCreateWithoutStorageInput>
  }

  export type PCConfigurationCreateWithoutStoragesInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutStoragesInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutStoragesInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutStoragesInput, PCConfigurationUncheckedCreateWithoutStoragesInput>
  }

  export type ParcialPCConfigurationCreateWithoutStoragesInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutStoragesInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutStoragesInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutStoragesInput, ParcialPCConfigurationUncheckedCreateWithoutStoragesInput>
  }

  export type ComponentUpsertWithoutStorageInput = {
    update: XOR<ComponentUpdateWithoutStorageInput, ComponentUncheckedUpdateWithoutStorageInput>
    create: XOR<ComponentCreateWithoutStorageInput, ComponentUncheckedCreateWithoutStorageInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutStorageInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutStorageInput, ComponentUncheckedUpdateWithoutStorageInput>
  }

  export type ComponentUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutStoragesInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutStoragesInput, PCConfigurationUncheckedUpdateWithoutStoragesInput>
    create: XOR<PCConfigurationCreateWithoutStoragesInput, PCConfigurationUncheckedCreateWithoutStoragesInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutStoragesInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutStoragesInput, PCConfigurationUncheckedUpdateWithoutStoragesInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutStoragesInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutStoragesInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutStoragesInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutStoragesInput, ParcialPCConfigurationUncheckedUpdateWithoutStoragesInput>
    create: XOR<ParcialPCConfigurationCreateWithoutStoragesInput, ParcialPCConfigurationUncheckedCreateWithoutStoragesInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutStoragesInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutStoragesInput, ParcialPCConfigurationUncheckedUpdateWithoutStoragesInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutStoragesInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutStoragesInput>
  }

  export type ComponentCreateWithoutPowerSupplyInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutPowerSupplyInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    pcCase?: PCCaseUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutPowerSupplyInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutPowerSupplyInput, ComponentUncheckedCreateWithoutPowerSupplyInput>
  }

  export type PCConfigurationCreateWithoutPowerSupplyInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    pcCase: PCCaseCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutPowerSupplyInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutPowerSupplyInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutPowerSupplyInput, PCConfigurationUncheckedCreateWithoutPowerSupplyInput>
  }

  export type PCConfigurationCreateManyPowerSupplyInputEnvelope = {
    data: PCConfigurationCreateManyPowerSupplyInput | PCConfigurationCreateManyPowerSupplyInput[]
    skipDuplicates?: boolean
  }

  export type ParcialPCConfigurationCreateWithoutPowerSupplyInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    pcCase?: PCCaseCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutPowerSupplyInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput>
  }

  export type ParcialPCConfigurationCreateManyPowerSupplyInputEnvelope = {
    data: ParcialPCConfigurationCreateManyPowerSupplyInput | ParcialPCConfigurationCreateManyPowerSupplyInput[]
    skipDuplicates?: boolean
  }

  export type ComponentUpsertWithoutPowerSupplyInput = {
    update: XOR<ComponentUpdateWithoutPowerSupplyInput, ComponentUncheckedUpdateWithoutPowerSupplyInput>
    create: XOR<ComponentCreateWithoutPowerSupplyInput, ComponentUncheckedCreateWithoutPowerSupplyInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutPowerSupplyInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutPowerSupplyInput, ComponentUncheckedUpdateWithoutPowerSupplyInput>
  }

  export type ComponentUpdateWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    pcCase?: PCCaseUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutPowerSupplyInput, PCConfigurationUncheckedUpdateWithoutPowerSupplyInput>
    create: XOR<PCConfigurationCreateWithoutPowerSupplyInput, PCConfigurationUncheckedCreateWithoutPowerSupplyInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutPowerSupplyInput, PCConfigurationUncheckedUpdateWithoutPowerSupplyInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutPowerSupplyInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutPowerSupplyInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedUpdateWithoutPowerSupplyInput>
    create: XOR<ParcialPCConfigurationCreateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedCreateWithoutPowerSupplyInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutPowerSupplyInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutPowerSupplyInput, ParcialPCConfigurationUncheckedUpdateWithoutPowerSupplyInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutPowerSupplyInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutPowerSupplyInput>
  }

  export type ComponentCreateWithoutPcCaseInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutComponentInput
    processor?: ProcessorCreateNestedOneWithoutComponentInput
    gpu?: GPUCreateNestedOneWithoutComponentInput
    ram?: RAMCreateNestedOneWithoutComponentInput
    storage?: StorageCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutPcCaseInput = {
    id?: string
    name: string
    componentType: $Enums.ComponentType
    price: number
    manufacturer: string
    imageUrl: string
    deletedAt?: Date | string | null
    motherboard?: MotherboardUncheckedCreateNestedOneWithoutComponentInput
    processor?: ProcessorUncheckedCreateNestedOneWithoutComponentInput
    gpu?: GPUUncheckedCreateNestedOneWithoutComponentInput
    ram?: RAMUncheckedCreateNestedOneWithoutComponentInput
    storage?: StorageUncheckedCreateNestedOneWithoutComponentInput
    powerSupply?: PowerSupplyUncheckedCreateNestedOneWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutPcCaseInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutPcCaseInput, ComponentUncheckedCreateWithoutPcCaseInput>
  }

  export type PCConfigurationCreateWithoutPcCaseInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard: MotherboardCreateNestedOneWithoutConfigurationsInput
    processor: ProcessorCreateNestedOneWithoutConfigurationsInput
    rams?: RAMCreateNestedManyWithoutConfigurationsInput
    gpu: GPUCreateNestedOneWithoutConfigurationsInput
    storages?: StorageCreateNestedManyWithoutConfigurationsInput
    powerSupply: PowerSupplyCreateNestedOneWithoutConfigurationsInput
    user: UserCreateNestedOneWithoutUserconfigurationsInput
  }

  export type PCConfigurationUncheckedCreateWithoutPcCaseInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutConfigurationsInput
    storages?: StorageUncheckedCreateNestedManyWithoutConfigurationsInput
  }

  export type PCConfigurationCreateOrConnectWithoutPcCaseInput = {
    where: PCConfigurationWhereUniqueInput
    create: XOR<PCConfigurationCreateWithoutPcCaseInput, PCConfigurationUncheckedCreateWithoutPcCaseInput>
  }

  export type PCConfigurationCreateManyPcCaseInputEnvelope = {
    data: PCConfigurationCreateManyPcCaseInput | PCConfigurationCreateManyPcCaseInput[]
    skipDuplicates?: boolean
  }

  export type ParcialPCConfigurationCreateWithoutPcCaseInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    motherboard?: MotherboardCreateNestedOneWithoutPartialInput
    processor?: ProcessorCreateNestedOneWithoutPartialInput
    rams?: RAMCreateNestedManyWithoutPartialInput
    gpu?: GPUCreateNestedOneWithoutPartialInput
    storages?: StorageCreateNestedManyWithoutPartialInput
    powerSupply?: PowerSupplyCreateNestedOneWithoutPartialInput
    user: UserCreateNestedOneWithoutPartialUserConfigurationInput
  }

  export type ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rams?: RAMUncheckedCreateNestedManyWithoutPartialInput
    storages?: StorageUncheckedCreateNestedManyWithoutPartialInput
  }

  export type ParcialPCConfigurationCreateOrConnectWithoutPcCaseInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    create: XOR<ParcialPCConfigurationCreateWithoutPcCaseInput, ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput>
  }

  export type ParcialPCConfigurationCreateManyPcCaseInputEnvelope = {
    data: ParcialPCConfigurationCreateManyPcCaseInput | ParcialPCConfigurationCreateManyPcCaseInput[]
    skipDuplicates?: boolean
  }

  export type ComponentUpsertWithoutPcCaseInput = {
    update: XOR<ComponentUpdateWithoutPcCaseInput, ComponentUncheckedUpdateWithoutPcCaseInput>
    create: XOR<ComponentCreateWithoutPcCaseInput, ComponentUncheckedCreateWithoutPcCaseInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutPcCaseInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutPcCaseInput, ComponentUncheckedUpdateWithoutPcCaseInput>
  }

  export type ComponentUpdateWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUpdateOneWithoutComponentNestedInput
    gpu?: GPUUpdateOneWithoutComponentNestedInput
    ram?: RAMUpdateOneWithoutComponentNestedInput
    storage?: StorageUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    componentType?: EnumComponentTypeFieldUpdateOperationsInput | $Enums.ComponentType
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUncheckedUpdateOneWithoutComponentNestedInput
    processor?: ProcessorUncheckedUpdateOneWithoutComponentNestedInput
    gpu?: GPUUncheckedUpdateOneWithoutComponentNestedInput
    ram?: RAMUncheckedUpdateOneWithoutComponentNestedInput
    storage?: StorageUncheckedUpdateOneWithoutComponentNestedInput
    powerSupply?: PowerSupplyUncheckedUpdateOneWithoutComponentNestedInput
  }

  export type PCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput = {
    where: PCConfigurationWhereUniqueInput
    update: XOR<PCConfigurationUpdateWithoutPcCaseInput, PCConfigurationUncheckedUpdateWithoutPcCaseInput>
    create: XOR<PCConfigurationCreateWithoutPcCaseInput, PCConfigurationUncheckedCreateWithoutPcCaseInput>
  }

  export type PCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput = {
    where: PCConfigurationWhereUniqueInput
    data: XOR<PCConfigurationUpdateWithoutPcCaseInput, PCConfigurationUncheckedUpdateWithoutPcCaseInput>
  }

  export type PCConfigurationUpdateManyWithWhereWithoutPcCaseInput = {
    where: PCConfigurationScalarWhereInput
    data: XOR<PCConfigurationUpdateManyMutationInput, PCConfigurationUncheckedUpdateManyWithoutPcCaseInput>
  }

  export type ParcialPCConfigurationUpsertWithWhereUniqueWithoutPcCaseInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    update: XOR<ParcialPCConfigurationUpdateWithoutPcCaseInput, ParcialPCConfigurationUncheckedUpdateWithoutPcCaseInput>
    create: XOR<ParcialPCConfigurationCreateWithoutPcCaseInput, ParcialPCConfigurationUncheckedCreateWithoutPcCaseInput>
  }

  export type ParcialPCConfigurationUpdateWithWhereUniqueWithoutPcCaseInput = {
    where: ParcialPCConfigurationWhereUniqueInput
    data: XOR<ParcialPCConfigurationUpdateWithoutPcCaseInput, ParcialPCConfigurationUncheckedUpdateWithoutPcCaseInput>
  }

  export type ParcialPCConfigurationUpdateManyWithWhereWithoutPcCaseInput = {
    where: ParcialPCConfigurationScalarWhereInput
    data: XOR<ParcialPCConfigurationUpdateManyMutationInput, ParcialPCConfigurationUncheckedUpdateManyWithoutPcCaseInput>
  }

  export type MotherboardCreateWithoutPartialInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutMotherboardInput
    configurations?: PCConfigurationCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardUncheckedCreateWithoutPartialInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardCreateOrConnectWithoutPartialInput = {
    where: MotherboardWhereUniqueInput
    create: XOR<MotherboardCreateWithoutPartialInput, MotherboardUncheckedCreateWithoutPartialInput>
  }

  export type ProcessorCreateWithoutPartialInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutProcessorInput
    configurations?: PCConfigurationCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorUncheckedCreateWithoutPartialInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorCreateOrConnectWithoutPartialInput = {
    where: ProcessorWhereUniqueInput
    create: XOR<ProcessorCreateWithoutPartialInput, ProcessorUncheckedCreateWithoutPartialInput>
  }

  export type RAMCreateWithoutPartialInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutRamInput
    configurations?: PCConfigurationCreateNestedManyWithoutRamsInput
  }

  export type RAMUncheckedCreateWithoutPartialInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutRamsInput
  }

  export type RAMCreateOrConnectWithoutPartialInput = {
    where: RAMWhereUniqueInput
    create: XOR<RAMCreateWithoutPartialInput, RAMUncheckedCreateWithoutPartialInput>
  }

  export type GPUCreateWithoutPartialInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutGpuInput
    configurations?: PCConfigurationCreateNestedManyWithoutGpuInput
  }

  export type GPUUncheckedCreateWithoutPartialInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutGpuInput
  }

  export type GPUCreateOrConnectWithoutPartialInput = {
    where: GPUWhereUniqueInput
    create: XOR<GPUCreateWithoutPartialInput, GPUUncheckedCreateWithoutPartialInput>
  }

  export type StorageCreateWithoutPartialInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutStorageInput
    configurations?: PCConfigurationCreateNestedManyWithoutStoragesInput
  }

  export type StorageUncheckedCreateWithoutPartialInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutStoragesInput
  }

  export type StorageCreateOrConnectWithoutPartialInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutPartialInput, StorageUncheckedCreateWithoutPartialInput>
  }

  export type PowerSupplyCreateWithoutPartialInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutPowerSupplyInput
    configurations?: PCConfigurationCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyUncheckedCreateWithoutPartialInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyCreateOrConnectWithoutPartialInput = {
    where: PowerSupplyWhereUniqueInput
    create: XOR<PowerSupplyCreateWithoutPartialInput, PowerSupplyUncheckedCreateWithoutPartialInput>
  }

  export type PCCaseCreateWithoutPartialInput = {
    id?: string
    formFactor: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutPcCaseInput
    configurations?: PCConfigurationCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseUncheckedCreateWithoutPartialInput = {
    id?: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
    configurations?: PCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseCreateOrConnectWithoutPartialInput = {
    where: PCCaseWhereUniqueInput
    create: XOR<PCCaseCreateWithoutPartialInput, PCCaseUncheckedCreateWithoutPartialInput>
  }

  export type UserCreateWithoutPartialUserConfigurationInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    userconfigurations?: PCConfigurationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPartialUserConfigurationInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    userconfigurations?: PCConfigurationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPartialUserConfigurationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPartialUserConfigurationInput, UserUncheckedCreateWithoutPartialUserConfigurationInput>
  }

  export type MotherboardUpsertWithoutPartialInput = {
    update: XOR<MotherboardUpdateWithoutPartialInput, MotherboardUncheckedUpdateWithoutPartialInput>
    create: XOR<MotherboardCreateWithoutPartialInput, MotherboardUncheckedCreateWithoutPartialInput>
    where?: MotherboardWhereInput
  }

  export type MotherboardUpdateToOneWithWhereWithoutPartialInput = {
    where?: MotherboardWhereInput
    data: XOR<MotherboardUpdateWithoutPartialInput, MotherboardUncheckedUpdateWithoutPartialInput>
  }

  export type MotherboardUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutMotherboardNestedInput
    configurations?: PCConfigurationUpdateManyWithoutMotherboardNestedInput
  }

  export type MotherboardUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput
  }

  export type ProcessorUpsertWithoutPartialInput = {
    update: XOR<ProcessorUpdateWithoutPartialInput, ProcessorUncheckedUpdateWithoutPartialInput>
    create: XOR<ProcessorCreateWithoutPartialInput, ProcessorUncheckedCreateWithoutPartialInput>
    where?: ProcessorWhereInput
  }

  export type ProcessorUpdateToOneWithWhereWithoutPartialInput = {
    where?: ProcessorWhereInput
    data: XOR<ProcessorUpdateWithoutPartialInput, ProcessorUncheckedUpdateWithoutPartialInput>
  }

  export type ProcessorUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutProcessorNestedInput
    configurations?: PCConfigurationUpdateManyWithoutProcessorNestedInput
  }

  export type ProcessorUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput
  }

  export type RAMUpsertWithWhereUniqueWithoutPartialInput = {
    where: RAMWhereUniqueInput
    update: XOR<RAMUpdateWithoutPartialInput, RAMUncheckedUpdateWithoutPartialInput>
    create: XOR<RAMCreateWithoutPartialInput, RAMUncheckedCreateWithoutPartialInput>
  }

  export type RAMUpdateWithWhereUniqueWithoutPartialInput = {
    where: RAMWhereUniqueInput
    data: XOR<RAMUpdateWithoutPartialInput, RAMUncheckedUpdateWithoutPartialInput>
  }

  export type RAMUpdateManyWithWhereWithoutPartialInput = {
    where: RAMScalarWhereInput
    data: XOR<RAMUpdateManyMutationInput, RAMUncheckedUpdateManyWithoutPartialInput>
  }

  export type RAMScalarWhereInput = {
    AND?: RAMScalarWhereInput | RAMScalarWhereInput[]
    OR?: RAMScalarWhereInput[]
    NOT?: RAMScalarWhereInput | RAMScalarWhereInput[]
    id?: StringFilter<"RAM"> | string
    memoryType?: StringFilter<"RAM"> | string
    capacity?: IntFilter<"RAM"> | number
    computerType?: EnumComputerTypeFilter<"RAM"> | $Enums.ComputerType
    componentId?: StringFilter<"RAM"> | string
    deletedAt?: DateTimeNullableFilter<"RAM"> | Date | string | null
  }

  export type GPUUpsertWithoutPartialInput = {
    update: XOR<GPUUpdateWithoutPartialInput, GPUUncheckedUpdateWithoutPartialInput>
    create: XOR<GPUCreateWithoutPartialInput, GPUUncheckedCreateWithoutPartialInput>
    where?: GPUWhereInput
  }

  export type GPUUpdateToOneWithWhereWithoutPartialInput = {
    where?: GPUWhereInput
    data: XOR<GPUUpdateWithoutPartialInput, GPUUncheckedUpdateWithoutPartialInput>
  }

  export type GPUUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutGpuNestedInput
    configurations?: PCConfigurationUpdateManyWithoutGpuNestedInput
  }

  export type GPUUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutGpuNestedInput
  }

  export type StorageUpsertWithWhereUniqueWithoutPartialInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutPartialInput, StorageUncheckedUpdateWithoutPartialInput>
    create: XOR<StorageCreateWithoutPartialInput, StorageUncheckedCreateWithoutPartialInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutPartialInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutPartialInput, StorageUncheckedUpdateWithoutPartialInput>
  }

  export type StorageUpdateManyWithWhereWithoutPartialInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutPartialInput>
  }

  export type StorageScalarWhereInput = {
    AND?: StorageScalarWhereInput | StorageScalarWhereInput[]
    OR?: StorageScalarWhereInput[]
    NOT?: StorageScalarWhereInput | StorageScalarWhereInput[]
    id?: StringFilter<"Storage"> | string
    storageType?: StringFilter<"Storage"> | string
    capacity?: IntFilter<"Storage"> | number
    busType?: StringFilter<"Storage"> | string
    componentId?: StringFilter<"Storage"> | string
    deletedAt?: DateTimeNullableFilter<"Storage"> | Date | string | null
  }

  export type PowerSupplyUpsertWithoutPartialInput = {
    update: XOR<PowerSupplyUpdateWithoutPartialInput, PowerSupplyUncheckedUpdateWithoutPartialInput>
    create: XOR<PowerSupplyCreateWithoutPartialInput, PowerSupplyUncheckedCreateWithoutPartialInput>
    where?: PowerSupplyWhereInput
  }

  export type PowerSupplyUpdateToOneWithWhereWithoutPartialInput = {
    where?: PowerSupplyWhereInput
    data: XOR<PowerSupplyUpdateWithoutPartialInput, PowerSupplyUncheckedUpdateWithoutPartialInput>
  }

  export type PowerSupplyUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutPowerSupplyNestedInput
    configurations?: PCConfigurationUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PowerSupplyUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PCCaseUpsertWithoutPartialInput = {
    update: XOR<PCCaseUpdateWithoutPartialInput, PCCaseUncheckedUpdateWithoutPartialInput>
    create: XOR<PCCaseCreateWithoutPartialInput, PCCaseUncheckedCreateWithoutPartialInput>
    where?: PCCaseWhereInput
  }

  export type PCCaseUpdateToOneWithWhereWithoutPartialInput = {
    where?: PCCaseWhereInput
    data: XOR<PCCaseUpdateWithoutPartialInput, PCCaseUncheckedUpdateWithoutPartialInput>
  }

  export type PCCaseUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutPcCaseNestedInput
    configurations?: PCConfigurationUpdateManyWithoutPcCaseNestedInput
  }

  export type PCCaseUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput
  }

  export type UserUpsertWithoutPartialUserConfigurationInput = {
    update: XOR<UserUpdateWithoutPartialUserConfigurationInput, UserUncheckedUpdateWithoutPartialUserConfigurationInput>
    create: XOR<UserCreateWithoutPartialUserConfigurationInput, UserUncheckedCreateWithoutPartialUserConfigurationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPartialUserConfigurationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPartialUserConfigurationInput, UserUncheckedUpdateWithoutPartialUserConfigurationInput>
  }

  export type UserUpdateWithoutPartialUserConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    userconfigurations?: PCConfigurationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPartialUserConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    userconfigurations?: PCConfigurationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MotherboardCreateWithoutConfigurationsInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutMotherboardInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    socket: string
    formFactor: string
    ramSlots: number
    ramType: string
    gpuInterface: string
    stroageBusType: string
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutMotherboardInput
  }

  export type MotherboardCreateOrConnectWithoutConfigurationsInput = {
    where: MotherboardWhereUniqueInput
    create: XOR<MotherboardCreateWithoutConfigurationsInput, MotherboardUncheckedCreateWithoutConfigurationsInput>
  }

  export type ProcessorCreateWithoutConfigurationsInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutProcessorInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    architecture: string
    cores: number
    threads: number
    bits: number
    socket: string
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutProcessorInput
  }

  export type ProcessorCreateOrConnectWithoutConfigurationsInput = {
    where: ProcessorWhereUniqueInput
    create: XOR<ProcessorCreateWithoutConfigurationsInput, ProcessorUncheckedCreateWithoutConfigurationsInput>
  }

  export type RAMCreateWithoutConfigurationsInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutRamInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutRamsInput
  }

  export type RAMUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    memoryType: string
    capacity: number
    computerType: $Enums.ComputerType
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutRamsInput
  }

  export type RAMCreateOrConnectWithoutConfigurationsInput = {
    where: RAMWhereUniqueInput
    create: XOR<RAMCreateWithoutConfigurationsInput, RAMUncheckedCreateWithoutConfigurationsInput>
  }

  export type GPUCreateWithoutConfigurationsInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutGpuInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutGpuInput
  }

  export type GPUUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    memory: number
    powerConnector: string
    interface: string
    power: number
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutGpuInput
  }

  export type GPUCreateOrConnectWithoutConfigurationsInput = {
    where: GPUWhereUniqueInput
    create: XOR<GPUCreateWithoutConfigurationsInput, GPUUncheckedCreateWithoutConfigurationsInput>
  }

  export type StorageCreateWithoutConfigurationsInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutStorageInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutStoragesInput
  }

  export type StorageUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    storageType: string
    capacity: number
    busType: string
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutStoragesInput
  }

  export type StorageCreateOrConnectWithoutConfigurationsInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutConfigurationsInput, StorageUncheckedCreateWithoutConfigurationsInput>
  }

  export type PowerSupplyCreateWithoutConfigurationsInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutPowerSupplyInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    powerOutput: number
    efficiency: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutPowerSupplyInput
  }

  export type PowerSupplyCreateOrConnectWithoutConfigurationsInput = {
    where: PowerSupplyWhereUniqueInput
    create: XOR<PowerSupplyCreateWithoutConfigurationsInput, PowerSupplyUncheckedCreateWithoutConfigurationsInput>
  }

  export type PCCaseCreateWithoutConfigurationsInput = {
    id?: string
    formFactor: string
    deletedAt?: Date | string | null
    component: ComponentCreateNestedOneWithoutPcCaseInput
    partial?: ParcialPCConfigurationCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    formFactor: string
    componentId: string
    deletedAt?: Date | string | null
    partial?: ParcialPCConfigurationUncheckedCreateNestedManyWithoutPcCaseInput
  }

  export type PCCaseCreateOrConnectWithoutConfigurationsInput = {
    where: PCCaseWhereUniqueInput
    create: XOR<PCCaseCreateWithoutConfigurationsInput, PCCaseUncheckedCreateWithoutConfigurationsInput>
  }

  export type UserCreateWithoutUserconfigurationsInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    partialUserConfiguration?: ParcialPCConfigurationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserconfigurationsInput = {
    id?: string
    username: string
    email: string
    password: string
    userType?: $Enums.UserType
    partialUserConfiguration?: ParcialPCConfigurationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserconfigurationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserconfigurationsInput, UserUncheckedCreateWithoutUserconfigurationsInput>
  }

  export type MotherboardUpsertWithoutConfigurationsInput = {
    update: XOR<MotherboardUpdateWithoutConfigurationsInput, MotherboardUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<MotherboardCreateWithoutConfigurationsInput, MotherboardUncheckedCreateWithoutConfigurationsInput>
    where?: MotherboardWhereInput
  }

  export type MotherboardUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: MotherboardWhereInput
    data: XOR<MotherboardUpdateWithoutConfigurationsInput, MotherboardUncheckedUpdateWithoutConfigurationsInput>
  }

  export type MotherboardUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutMotherboardNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutMotherboardNestedInput
  }

  export type MotherboardUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    socket?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    ramSlots?: IntFieldUpdateOperationsInput | number
    ramType?: StringFieldUpdateOperationsInput | string
    gpuInterface?: StringFieldUpdateOperationsInput | string
    stroageBusType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutMotherboardNestedInput
  }

  export type ProcessorUpsertWithoutConfigurationsInput = {
    update: XOR<ProcessorUpdateWithoutConfigurationsInput, ProcessorUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<ProcessorCreateWithoutConfigurationsInput, ProcessorUncheckedCreateWithoutConfigurationsInput>
    where?: ProcessorWhereInput
  }

  export type ProcessorUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: ProcessorWhereInput
    data: XOR<ProcessorUpdateWithoutConfigurationsInput, ProcessorUncheckedUpdateWithoutConfigurationsInput>
  }

  export type ProcessorUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutProcessorNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutProcessorNestedInput
  }

  export type ProcessorUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    architecture?: StringFieldUpdateOperationsInput | string
    cores?: IntFieldUpdateOperationsInput | number
    threads?: IntFieldUpdateOperationsInput | number
    bits?: IntFieldUpdateOperationsInput | number
    socket?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutProcessorNestedInput
  }

  export type RAMUpsertWithWhereUniqueWithoutConfigurationsInput = {
    where: RAMWhereUniqueInput
    update: XOR<RAMUpdateWithoutConfigurationsInput, RAMUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<RAMCreateWithoutConfigurationsInput, RAMUncheckedCreateWithoutConfigurationsInput>
  }

  export type RAMUpdateWithWhereUniqueWithoutConfigurationsInput = {
    where: RAMWhereUniqueInput
    data: XOR<RAMUpdateWithoutConfigurationsInput, RAMUncheckedUpdateWithoutConfigurationsInput>
  }

  export type RAMUpdateManyWithWhereWithoutConfigurationsInput = {
    where: RAMScalarWhereInput
    data: XOR<RAMUpdateManyMutationInput, RAMUncheckedUpdateManyWithoutConfigurationsInput>
  }

  export type GPUUpsertWithoutConfigurationsInput = {
    update: XOR<GPUUpdateWithoutConfigurationsInput, GPUUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<GPUCreateWithoutConfigurationsInput, GPUUncheckedCreateWithoutConfigurationsInput>
    where?: GPUWhereInput
  }

  export type GPUUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: GPUWhereInput
    data: XOR<GPUUpdateWithoutConfigurationsInput, GPUUncheckedUpdateWithoutConfigurationsInput>
  }

  export type GPUUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutGpuNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutGpuNestedInput
  }

  export type GPUUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    powerConnector?: StringFieldUpdateOperationsInput | string
    interface?: StringFieldUpdateOperationsInput | string
    power?: IntFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutGpuNestedInput
  }

  export type StorageUpsertWithWhereUniqueWithoutConfigurationsInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutConfigurationsInput, StorageUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<StorageCreateWithoutConfigurationsInput, StorageUncheckedCreateWithoutConfigurationsInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutConfigurationsInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutConfigurationsInput, StorageUncheckedUpdateWithoutConfigurationsInput>
  }

  export type StorageUpdateManyWithWhereWithoutConfigurationsInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutConfigurationsInput>
  }

  export type PowerSupplyUpsertWithoutConfigurationsInput = {
    update: XOR<PowerSupplyUpdateWithoutConfigurationsInput, PowerSupplyUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<PowerSupplyCreateWithoutConfigurationsInput, PowerSupplyUncheckedCreateWithoutConfigurationsInput>
    where?: PowerSupplyWhereInput
  }

  export type PowerSupplyUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: PowerSupplyWhereInput
    data: XOR<PowerSupplyUpdateWithoutConfigurationsInput, PowerSupplyUncheckedUpdateWithoutConfigurationsInput>
  }

  export type PowerSupplyUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutPowerSupplyNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PowerSupplyUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    powerOutput?: IntFieldUpdateOperationsInput | number
    efficiency?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutPowerSupplyNestedInput
  }

  export type PCCaseUpsertWithoutConfigurationsInput = {
    update: XOR<PCCaseUpdateWithoutConfigurationsInput, PCCaseUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<PCCaseCreateWithoutConfigurationsInput, PCCaseUncheckedCreateWithoutConfigurationsInput>
    where?: PCCaseWhereInput
  }

  export type PCCaseUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: PCCaseWhereInput
    data: XOR<PCCaseUpdateWithoutConfigurationsInput, PCCaseUncheckedUpdateWithoutConfigurationsInput>
  }

  export type PCCaseUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutPcCaseNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutPcCaseNestedInput
  }

  export type PCCaseUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFactor?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutPcCaseNestedInput
  }

  export type UserUpsertWithoutUserconfigurationsInput = {
    update: XOR<UserUpdateWithoutUserconfigurationsInput, UserUncheckedUpdateWithoutUserconfigurationsInput>
    create: XOR<UserCreateWithoutUserconfigurationsInput, UserUncheckedCreateWithoutUserconfigurationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserconfigurationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserconfigurationsInput, UserUncheckedUpdateWithoutUserconfigurationsInput>
  }

  export type UserUpdateWithoutUserconfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    partialUserConfiguration?: ParcialPCConfigurationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserconfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    partialUserConfiguration?: ParcialPCConfigurationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PCConfigurationCreateManyUserInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    userType: $Enums.UserType
  }

  export type PCConfigurationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
  }

  export type PCConfigurationCreateManyMotherboardInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    processorId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ParcialPCConfigurationCreateManyMotherboardInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PCConfigurationUpdateWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutMotherboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationCreateManyProcessorInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    gpuId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ParcialPCConfigurationCreateManyProcessorInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PCConfigurationUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationCreateManyGpuInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    powerSupplyId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ParcialPCConfigurationCreateManyGpuInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    powerSupplyId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PCConfigurationUpdateWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutGpuInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationUpdateWithoutRamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutRamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutRamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutRamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutRamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutRamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationUpdateWithoutStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationCreateManyPowerSupplyInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    pcCaseId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ParcialPCConfigurationCreateManyPowerSupplyInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    pcCaseId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PCConfigurationUpdateWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    pcCase?: PCCaseUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    pcCaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    pcCase?: PCCaseUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutPowerSupplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    pcCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PCConfigurationCreateManyPcCaseInput = {
    id?: string
    totalPrice: number
    configurationType: $Enums.ConfigurationType
    motherboardId: string
    processorId: string
    gpuId: string
    powerSupplyId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ParcialPCConfigurationCreateManyPcCaseInput = {
    id?: string
    configurationType: $Enums.ConfigurationType
    motherboardId?: string | null
    processorId?: string | null
    gpuId?: string | null
    powerSupplyId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PCConfigurationUpdateWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneRequiredWithoutConfigurationsNestedInput
    processor?: ProcessorUpdateOneRequiredWithoutConfigurationsNestedInput
    rams?: RAMUpdateManyWithoutConfigurationsNestedInput
    gpu?: GPUUpdateOneRequiredWithoutConfigurationsNestedInput
    storages?: StorageUpdateManyWithoutConfigurationsNestedInput
    powerSupply?: PowerSupplyUpdateOneRequiredWithoutConfigurationsNestedInput
    user?: UserUpdateOneRequiredWithoutUserconfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutConfigurationsNestedInput
    storages?: StorageUncheckedUpdateManyWithoutConfigurationsNestedInput
  }

  export type PCConfigurationUncheckedUpdateManyWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: StringFieldUpdateOperationsInput | string
    processorId?: StringFieldUpdateOperationsInput | string
    gpuId?: StringFieldUpdateOperationsInput | string
    powerSupplyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParcialPCConfigurationUpdateWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherboard?: MotherboardUpdateOneWithoutPartialNestedInput
    processor?: ProcessorUpdateOneWithoutPartialNestedInput
    rams?: RAMUpdateManyWithoutPartialNestedInput
    gpu?: GPUUpdateOneWithoutPartialNestedInput
    storages?: StorageUpdateManyWithoutPartialNestedInput
    powerSupply?: PowerSupplyUpdateOneWithoutPartialNestedInput
    user?: UserUpdateOneRequiredWithoutPartialUserConfigurationNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rams?: RAMUncheckedUpdateManyWithoutPartialNestedInput
    storages?: StorageUncheckedUpdateManyWithoutPartialNestedInput
  }

  export type ParcialPCConfigurationUncheckedUpdateManyWithoutPcCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    configurationType?: EnumConfigurationTypeFieldUpdateOperationsInput | $Enums.ConfigurationType
    motherboardId?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    gpuId?: NullableStringFieldUpdateOperationsInput | string | null
    powerSupplyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RAMUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutRamNestedInput
    configurations?: PCConfigurationUpdateManyWithoutRamsNestedInput
  }

  export type RAMUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutRamsNestedInput
  }

  export type RAMUncheckedUpdateManyWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StorageUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutStorageNestedInput
    configurations?: PCConfigurationUpdateManyWithoutStoragesNestedInput
  }

  export type StorageUncheckedUpdateWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configurations?: PCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutPartialInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RAMUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutRamNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutRamsNestedInput
  }

  export type RAMUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutRamsNestedInput
  }

  export type RAMUncheckedUpdateManyWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    memoryType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    computerType?: EnumComputerTypeFieldUpdateOperationsInput | $Enums.ComputerType
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StorageUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneRequiredWithoutStorageNestedInput
    partial?: ParcialPCConfigurationUpdateManyWithoutStoragesNestedInput
  }

  export type StorageUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partial?: ParcialPCConfigurationUncheckedUpdateManyWithoutStoragesNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageType?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    busType?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotherboardCountOutputTypeDefaultArgs instead
     */
    export type MotherboardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotherboardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessorCountOutputTypeDefaultArgs instead
     */
    export type ProcessorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GPUCountOutputTypeDefaultArgs instead
     */
    export type GPUCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GPUCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RAMCountOutputTypeDefaultArgs instead
     */
    export type RAMCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RAMCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageCountOutputTypeDefaultArgs instead
     */
    export type StorageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PowerSupplyCountOutputTypeDefaultArgs instead
     */
    export type PowerSupplyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PowerSupplyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PCCaseCountOutputTypeDefaultArgs instead
     */
    export type PCCaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PCCaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParcialPCConfigurationCountOutputTypeDefaultArgs instead
     */
    export type ParcialPCConfigurationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParcialPCConfigurationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PCConfigurationCountOutputTypeDefaultArgs instead
     */
    export type PCConfigurationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PCConfigurationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentDefaultArgs instead
     */
    export type ComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotherboardDefaultArgs instead
     */
    export type MotherboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotherboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessorDefaultArgs instead
     */
    export type ProcessorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GPUDefaultArgs instead
     */
    export type GPUArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GPUDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RAMDefaultArgs instead
     */
    export type RAMArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RAMDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageDefaultArgs instead
     */
    export type StorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PowerSupplyDefaultArgs instead
     */
    export type PowerSupplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PowerSupplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PCCaseDefaultArgs instead
     */
    export type PCCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PCCaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParcialPCConfigurationDefaultArgs instead
     */
    export type ParcialPCConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParcialPCConfigurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PCConfigurationDefaultArgs instead
     */
    export type PCConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PCConfigurationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}